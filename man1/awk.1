.\"	$OpenBSD: awk.1,v 1.44 2015/09/14 20:06:58 schwarze Exp $
.\"
.\" Copyright (C) Lucent Technologies 1997
.\" All Rights Reserved
.\"
.\" Permission to use, copy, modify, and distribute this software and
.\" its documentation for any purpose and without fee is hereby
.\" granted, provided that the above copyright notice appear in all
.\" copies and that both that the copyright notice and this
.\" permission notice and warranty disclaimer appear in supporting
.\" documentation, and that the name Lucent Technologies or any of
.\" its entities not be used in advertising or publicity pertaining
.\" to distribution of the software without specific, written prior
.\" permission.
.\"
.\" LUCENT DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
.\" INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
.\" IN NO EVENT SHALL LUCENT OR ANY OF ITS ENTITIES BE LIABLE FOR ANY
.\" SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
.\" WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
.\" IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
.\" ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
.\" THIS SOFTWARE.
.Dd 30 июля 2021 г.
.Dt AWK 1
.Os
.Sh ИМЯ
.Nm awk
.Nd pattern-directed scanning and processing language
.Sh СИНТАКСИС
.Nm awk
.Op Fl safe
.Op Fl version
.Op Fl d Ns Op Ar n
.Op Fl F Ar fs
.Op Fl v Ar var Ns = Ns Ar value
.Op Ar prog | Fl f Ar progfile
.Ar
.Sh ОПИСАНИЕ
.Nm
сканирует каждый вход
.Ar file
для строк, которые соответствуют любому из набора шаблонов, указанных буквально в
.Ar prog
или в одном или нескольких файлах, указанных как
.Fl f Ar progfile .
С каждым шаблоном может быть связано действие, которое будет выполнено.
когда линия a
.Ar file
соответствует рисунку.
Каждая строка сопоставляется с
часть шаблона каждого оператора шаблонного действия;
соответствующее действие выполняется для каждого совпавшего шаблона.
Имя файла
.Sq -
означает стандартный ввод.
Любой
.Ar file
формы
.Ar var Ns = Ns Ar value
рассматривается как задание, а не имя файла,
и выполняется в тот момент, когда он был бы открыт, если бы это было имя файла.
.Pp
Возможные варианты:
.Bl -tag -width "-safe "
.It Fl d Ns Op Ar n
Режим отладки.
Установите уровень отладки на
.Ar n ,
или 1, если
.Ar n
не указано.
Значение больше 1 вызывает
.Nm
сбрасывать ядро на фатальные ошибки.
.It Fl F Ar fs
Определите разделитель полей ввода как регулярное выражение.
.Ar fs .
.It Fl f Ar progfile
Прочитать код программы из указанного файла
.Ar progfile
а не из командной строки.
.It Fl safe
Отключить вывод файлов
.Pf ( Ic print No > ,
.Ic print No >> ) ,
создание процесса
.Po
.Ar cmd | Ic getline ,
.Ic print | ,
.Ic system
.P
и доступ к окружающей среде
.Pf ( Va ENVIRON ;
см. раздел о переменных ниже).
Это первый
.Pq and not very reliable
приближение к
.Dq safe
версия
.Nm .
.It Fl version
Распечатайте номер версии
.Nm
на стандартный вывод и выйти.
.It Fl v Ar var Ns = Ns Ar value
Назначать
.Ar value
в переменную
.Ar var
до
.Ar prog
выполняется;
любое количество
.Fl v
варианты могут присутствовать.
.El
.Pp
Ввод обычно состоит из строк ввода.
.Pq records
разделенные символами новой строки или значением
.Va RS .
Если
.Va RS
имеет значение NULL, то в качестве разделителя записей используется любое количество пустых строк,
и новые строки используются в качестве разделителей полей.
(помимо стоимости
.Va FS ) .
Это удобно при работе с многострочными записями.
.Pp
Строка ввода обычно состоит из полей, разделенных пробелами.
или расширенным регулярным выражением
.Va FS
как описано ниже.
Поля обозначены
.Va $1 , $2 , ... ,
пока
.Va $0
относится ко всей строке.
Если
.Va FS
имеет значение null, строка ввода разбивается на одно поле на каждый символ.
Хотя поведение gawk и mawk одинаковое, оно не указано в
.St -p1003.1-2008
стандарт.
Если
.Va FS
представляет собой один пробел, тогда начинаются и заканчиваются пробелы и символы новой строки.
пропущен.
Поля разделяются одним или несколькими пробелами или символами новой строки.
Пустой символ — это пробел или табуляция.
Если
.Va FS
представляет собой один символ, кроме пробела, поля разделяются каждым отдельным символом.
появление этого персонажа.

.Va FS
переменная по умолчанию равна одному пробелу.
.Pp
Обычно любое количество пробелов разделяет поля.
Чтобы установить в качестве разделителя полей один пробел, используйте
.Fl F
вариант со стоимостью
.Sq [\ \&] .
Если разделитель полей
.Sq t
указано,
.Nm
относится к этому так, как будто
.Sq \et
был указан и использует
.Aq TAB
в качестве разделителя полей.
Чтобы использовать буквальный
.Sq t
в качестве разделителя полей используйте
.Fl F
вариант со стоимостью
.Sq [t] .
.Pp
Оператор шаблон-действие имеет форму
.Pp
.D1 Ar pattern Ic \&{ Ar action Ic \&}
.Pp
Пропавший без вести
.Ic \&{ Ar action Ic \&}
означает печать строки;
отсутствующий образец всегда совпадает.
Операторы шаблонного действия разделяются символами новой строки или точкой с запятой.
.Pp
Символы новой строки допускаются после завершающего оператора или после запятой.
.Pq Sq ,\& ,
открытая скобка
.Pq Sq { ,
логическое И
.Pq Sq && ,
логическое ИЛИ
.Pq Sq || ,
после
.Sq do
или
.Sq else
ключевые слова,
или после закрывающей скобки
.Sq if ,
.Sq for ,
или
.Sq while
заявление.
Кроме того, обратная косая черта
.Pq Sq \e
может использоваться для экранирования новой строки между токенами.
.Pp
Действие – это последовательность утверждений.
Заявление может быть одним из следующих:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It Ic if Ar ( expression ) Ar statement Op Ic else Ar statement
.It Ic while Ar ( expression ) Ar statement
.It Ic for Ar ( expression ; expression ; expression ) statement
.It Ic for Ar ( var Ic in Ar array ) statement
.It Ic do Ar statement Ic while Ar ( expression )
.It Ic break
.It Ic continue
.It Xo Ic {
.Op Ar statement ...
.Ic }
.Xc
.It Xo Ar expression
.No # commonly
.Ar var No = Ar expression
.Xc
.It Xo Ic print
.Op Ar expression-list
.Op > Ns Ar expression
.Xc
.It Xo Ic printf Ar format
.Op Ar ... , expression-list
.Op > Ns Ar expression
.Xc
.It Ic return Op Ar expression
.It Xo Ic next
.No # skip remaining patterns on this input line
.Xc
.It Xo Ic nextfile
.No # skip rest of this file, open next, start at top
.Xc
.It Xo Ic delete
.Sm off
.Ar array Ic \&[ Ar expression Ic \&]
.Sm on
.No # удалить элемент массива
.Xc
.It Xo Ic delete Ar array
.No # удалить все элементы массива
.Xc
.It Xo Ic exit
.Op Ar expression
.No # немедленно выйти; статус — это выражение Ar
.Xc
.El
.Pp
Заявления прекращаются
точки с запятой, символы новой строки или правые фигурные скобки.
Пустой
.Ar expression-list
означает
.Ar $0 .
Строковые константы заключаются в кавычки
.Li \&"" ,
с обычными экранами C, распознаваемыми внутри
(смотреть
.Xr printf 1
полный их список).
Выражения принимают строковые или числовые значения в зависимости от ситуации.
и строятся с использованием операторов
.Ic + \- * / % ^
.Pq exponentiation ,
и конкатенация
.Pq indicated by whitespace .
Операторы
.Ic \&! ++ \-\- += \-= *= /= %= ^=
.Ic > >= < <= == != ?\&:
также доступны в выражениях.
Переменные могут быть скалярами, элементами массива.
(обозначается
.Li x[i] )
или поля.
Переменные инициализируются нулевой строкой.
Индексы массива могут быть любой строкой,
не обязательно числовой;
это допускает форму ассоциативной памяти.
Множественные индексы, такие как
.Li [i,j,k]
разрешены; составляющие объединяются,
разделенные по значению
.Va SUBSEP
.Pq see the section on variables below .
.Pp
The
.Ic print
оператор выводит свои аргументы на стандартный вывод
(или в файле, если
.Pf > Ar file
или
.Pf >> Ar file
присутствует или на трубе, если
.Pf |\ \& Ar cmd
присутствует), разделенный разделителем полей текущего вывода,
и завершается разделителем выходных записей.
.Ar file
и
.Ar cmd
могут быть буквальными именами или выражениями в скобках;
идентичные строковые значения в разных операторах обозначают
тот же открытый файл.

.Ic printf
оператор форматирует свой список выражений в соответствии с форматом
(смотреть
.Xr printf 1 ) .
.Pp
Шаблоны — это произвольные логические комбинации.
(с
.Ic "\&! || &&" )
регулярных выражений и
выражения отношения.
.Nm
поддерживает расширенные регулярные выражения
.Pq EREs .
Смотреть
.Xr re_format 7
для получения дополнительной информации о регулярных выражениях.
Изолированные регулярные выражения
в шаблоне применяются ко всей линии.
Регулярные выражения также могут встречаться в
выражения отношения с использованием операторов
.Ic ~
и
.Ic !~ .
.Pf / Ar re Ns /
— постоянное регулярное выражение;
можно использовать любую строку (константу или переменную)
как регулярное выражение, за исключением позиции изолированного регулярного выражения
в шаблоне.
.Pp
Шаблон может состоять из двух шаблонов, разделенных запятой;
в этом случае действие выполняется для всех строк
от появления первого шаблона
через возникновение второго.
.Pp
Реляционное выражение является одним из следующих:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It Ar expression matchop regular-expression
.It Ar expression relop expression
.It Ar expression Ic in Ar array-name
.It Xo Ic \&( Ns
.Ar expr , expr , \&... Ns Ic \&) in
.Ar array-name
.Xc
.El
.Pp
где
.Ar relop
— это любой из шести операторов отношений в C, а
.Ar matchop
либо
.Ic ~
(матчи)
или
.Ic !~
(не совпадает).
Условное выражение – это арифметическое выражение,
относительное выражение,
или логическая комбинация
из этих.
.Pp
Специальные узоры
.Ic BEGIN
и
.Ic END
может использоваться для захвата управления до того, как будет прочитана первая строка ввода
и после последнего.
.Ic BEGIN
и
.Ic END
не комбинируйте с другими узорами.
.Pp
Имена переменных со специальным значением:
.Pp
.Bl -tag -width "FILENAME " -compact
.It Va ARG
Количество аргументов, назначаемое.
.It Va ARGV
Массив аргументов, назначаемый;
ненулевые члены принимаются в качестве имен файлов.
.It Va CONVFMT
Формат преобразования при преобразовании чисел
(по умолчанию
.Qq Li %.6g ) .
.It Va ENVIRON
Массив переменных среды; индексы — это имена.
.It Va FILENAME
Имя текущего входного файла.
.It Va FNR
Порядковый номер текущей записи в текущем файле.
.It Va FS
Регулярное выражение, используемое для разделения полей; также настраиваемый
по выбору
.Fl F Ar fs .
.It Va NF
Количество полей в текущей записи.
.Va $NF
может использоваться для получения значения последнего поля в текущей записи.
.It Va NR
Порядковый номер текущей записи.
.It Va OFMT
.Qq Li %.6g ) .
.It Va OFS
Разделитель полей вывода (по умолчанию пустой).
.It Va ORS
Разделитель выходных записей (новая строка по умолчанию).
.It Va RLENGTH
Длина строки, соответствующей
.Fn match
функция.
.It Va RS
Разделитель входных записей (новая строка по умолчанию).
.It Va RSTART
Начальная позиция строки, совпадающей с
.Fn match
функция.
.It Va SUBSEP
Разделяет несколько индексов (по умолчанию 034).
.El
.Sh ФУНКЦИИ
Язык awk имеет множество встроенных функций:
арифметика, строка, ввод/вывод, общие сведения и битовые операции.
.Pp
Могут быть определены функции (в позиции оператора шаблона-действия).
таким образом:
.Pp
.Dl function foo(a, b, c) { ...; return x }
.Pp
Параметры передаются по значению, если скаляр, и по ссылке, если имя массива;
функции могут вызываться рекурсивно.
Параметры являются локальными для функции; все остальные переменные являются глобальными.
Таким образом, локальные переменные могут быть созданы путем предоставления избыточных параметров в
определение функции.
.Ss Arithmetic Functions
.Bl -tag -width "atan2(y, x)"
.It Fn atan2 y x
Вернуть арктангенс
.Fa y Ns / Ns Fa x
в радианах.
.It Fn cos x
Вернуть косинус
.Fa x ,
где
.Fa x
находится в радианах.
.It Fn exp x
Вернуть экспоненту
.Fa x .
.It Fn int x
Возвращаться
.Fa x
усекается до целочисленного значения.
.It Fn log x
Вернуть натуральный логарифм
.Fa x .
.It Fn rand
Вернуть случайное число,
.Fa n ,
такой, что
.Sm off
.Pf 0 \*(Le Fa n No \*(Lt 1 .
.Sm on
.It Fn sin x
Вернуть синус
.Fa x ,
где
.Fa x
находится в радианах.
.It Fn sqrt x
Вернуть квадратный корень из
.Fa x .
.It Fn srand expr
Устанавливает начальное значение для
.Fn rand
к
.Fa expr
и возвращает предыдущее семя.
Если
.Fa expr
опущено, вместо него используется время суток.
.El
.Ss String Functions
.Bl -tag -width "split(s, a, fs)"
.It Fn gsub r t s
Такой же как
.Fn sub
за исключением того, что заменяются все вхождения регулярного выражения.
.Fn gsub
возвращает количество замен.
.It Fn index s t
Позиция в
.Fa s
где строка
.Fa t
происходит, или 0, если это не происходит.
.It Fn length s
Длина
.Fa s
воспринимается как строка,
или из
.Va $0
если аргумент не указан.
.It Fn match s r
Позиция в
.Fa s
где регулярное выражение
.Fa r
происходит, или 0, если это не происходит.
Переменная
.Va RSTART
устанавливается в начальную позицию совпадающей строки
.Pq which is the same as the returned value
или ноль, если совпадение не найдено.
Переменная
.Va RLENGTH
устанавливается на длину совпадающей строки,
или \-1, если совпадение не найдено.
.It Fn split s a fs
Разбивает строку
.Fa s
в элементы массива
.Va a[1] , a[2] , ... , a[n]
и возвращается
.Va n .
Разделение осуществляется с помощью регулярного выражения
.Ar fs
или с разделителем полей
.Va FS
если
.Ar fs
не дано.
Пустая строка в качестве разделителя полей разделяет строку.
в один элемент массива на каждый символ.
.It Fn sprintf fmt expr ...
Строка, полученная в результате форматирования
.Fa expr , ...
согласно
.Xr printf 1
формат
.Fa fmt .
.It Fn sub r t s
Заменители
.Fa t
для первого появления регулярного выражения
.Fa r
в строке
.Fa s .
Если
.Fa s
не дано,
.Va $0
используется.
Амперсанд
.Pq Sq &
в
.Fa t
заменяется в строке
.Fa s
с регулярным выражением
.Fa r .
Буквальный амперсанд можно указать, поставив перед ним две обратную косую черту.
.Pq Sq \e\e .
Буквальную обратную косую черту можно указать, поставив перед ней другую обратную косую черту.
.Pq Sq \e\e .
.Fn sub
возвращает количество замен.
.It Fn substr s m n
Вернуть не более
.Fa n Ns -character
подстрока
.Fa s
который начинается с позиции
.Fa m
считается с 1.
Если
.Fa n
опущено, или если
.Fa n
указывает больше символов, чем осталось в строке,
длина подстроки ограничена длиной
.Fa s .
.It Fn tolower str
Возвращает копию
.Fa str
со всеми символами верхнего регистра, переведенными в их
соответствующие эквиваленты в нижнем регистре.
.It Fn toupper str
Возвращает копию
.Fa str
со всеми строчными буквами, переведенными в их
соответствующие эквиваленты в верхнем регистре.
.El
.Ss Input/Output and General Functions
.Bl -tag -width "getline [var] < file"
.It Fn close expr
Закрывает файл или канал
.Fa expr .
.Fa expr
должно соответствовать строке, которая использовалась для открытия файла или канала.
.It Ar cmd | Ic getline Op Va var
Считайте запись ввода из потока, передаваемого по конвейеру с выхода
.Ar cmd .
Если
.Va var
опущено, переменные
.Va $0
и
.Va NF
установлены.
В противном случае
.Va var
установлен.
Если поток не открыт, он открывается.
Пока поток остается открытым, последующие вызовы
будет читать последующие записи из потока.
Поток остается открытым до тех пор, пока он не будет явно закрыт вызовом
.Fn close .
.Ic getline
возвращает 1 в случае успешного ввода, 0 в случае конца файла и \-1 в случае ошибки.
.It Fn fflush [expr]
Сбрасывает любой буферизованный вывод для файла или канала.
.Fa expr ,
или все открытые файлы или каналы, если
.Fa expr
опущено.
.Fa expr
должно соответствовать строке, которая использовалась для открытия файла или канала.
.It Ic getline
Наборы
.Va $0
к следующей входной записи из текущего входного файла.
Эта форма
.Ic getline
устанавливает переменные
.Va NF ,
.Va NR ,
и
.Va FNR .
.Ic getline
возвращает 1 в случае успешного ввода, 0 в случае конца файла и \-1 в случае ошибки.
.It Ic getline Va var
Наборы
.Va $0
в переменную
.Va var .
Эта форма
.Ic getline
устанавливает переменные
.Va NR
и
.Va FNR .
.Ic getline
возвращает 1 в случае успешного ввода, 0 в случае конца файла и \-1 в случае ошибки.
.It Xo
.Ic getline Op Va var
.Pf \ \&< Ar file
.Xc
Наборы
.Va $0
к следующей записи из
.Ar file .
Если
.Va var
опущено, переменные
.Va $0
и
.Va NF
установлены.
В противном случае
.Va var
установлен.
Если
.Ar file
не открыт, он открыт.
Пока поток остается открытым, последующие вызовы будут читать последующие
записи из
.Ar file .
.Ar file
остается открытым до тех пор, пока не будет явно закрыт вызовом
.Fn close .
.It Fn system cmd
Выполняет
.Fa cmd
и возвращает статус выхода
.El
.Ss Bit-Operation Functions
.Bl -tag -width "lshift(a, b)"
.It Fn compl x
Возвращает побитовое дополнение целочисленного аргумента x.
.It Fn and v1 v2 ...
Выполняет побитовое И для всех предоставленных аргументов в виде целых чисел.
Должно быть как минимум два значения.
.It Fn or v1 v2 ...
Выполняет побитовое ИЛИ для всех предоставленных аргументов как целых чисел.
Должно быть как минимум два значения.
.It Fn xor v1 v2 ...
Выполняет поразрядное исключающее ИЛИ для всех предоставленных аргументов в виде целых чисел.
Должно быть как минимум два значения.
.It Fn lshift x n
Возвращает целочисленный аргумент x, сдвинутый на n бит влево.
.It Fn rshift x n
Возвращает целочисленный аргумент x, сдвинутый на n бит вправо.
.El
.Sh ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
.Ex -std awk
.Pp
Но учтите, что
.Ic exit
выражение может изменить статус выхода.
.Sh ПРИМЕРЫ
Вывести строки длиной более 72 символов:
.Pp
.Dl length($0) > 72
.Pp
Напечатайте первые два поля в обратном порядке:
.Pp
.Dl { print $2, $1 }
.Pp
То же самое, с полями ввода, разделенными запятыми и/или пробелами и табуляциями:
.Bd -literal -offset indent
BEGIN { FS = ",[ \et]*|[ \et]+" }
      { print $2, $1 }
.Ed
.Pp
Add up first column, print sum and average:
.Bd -literal -offset indent
{ s += $1 }
END { print "sum is", s, " average is", s/NR }
.Ed
.Pp
Print all lines between start/stop pairs:
.Pp
.Dl /start/, /stop/
.Pp
Simulate echo(1):
.Bd -literal -offset indent
BEGIN { # Simulate echo(1)
        for (i = 1; i < ARGC; i++) printf "%s ", ARGV[i]
        printf "\en"
        exit }
.Ed
.Pp
Распечатайте сообщение об ошибке в стандартную ошибку:
.Bd -literal -offset indent
{ print "error!" > "/dev/stderr" }
.Ed
.Sh СМОТРИТЕ ТАКЖЕ
.Xr cut 1 ,
.Xr lex 1 ,
.Xr printf 1 ,
.Xr sed 1 ,
.Xr re_format 7
.Rs
.%A A. V. Aho
.%A B. W. Kernighan
.%A P. J. Weinberger
.%T The AWK Programming Language
.%I Addison-Wesley
.%D 1988
.%O ISBN 0-201-07981-X
.Re
.Sh СТАНДАРТЫ
The
.Nm
утилита соответствует требованиям
.St -p1003.1-2008
Спецификация,
кроме
.Nm
не поддерживает сопоставление с образцом {n,m}.
.Pp
Флаги
.Fl d ,
.Fl safe ,
и
.Fl version
а также команды
.Cm fflush , compl , and , or ,
.Cm xor , lshift , rshift ,
являются расширениями этой спецификации.
.Sh ИСТОРИЯ
An
.Nm
утилита появилась в
.At v7 .
.Sh BUGS
Явных преобразований между числами и строками нет.
Чтобы заставить выражение рассматриваться как число, добавьте к нему 0;
чтобы заставить его рассматриваться как объединение строк
.Li \&""
к этому.
.Pp
Правила области видимости для переменных в функциях — это лажа;
синтаксис хуже.
.Sh УСТАРЕВШЕЕ ПОВЕДЕНИЕ
Один True Awk принял
.Fl F Ar t
означать то же самое, что и
.Fl F Ar <TAB>
чтобы упростить указание табуляции в качестве символа-разделителя.
Компания Upstream One True Awk отказалась от этой бородавки во имя лучшего
совместимость с другими реализациями awk, такими как gawk и mawk.
.Pp
Исторически,
.Nm
не принял
.Dq 0xкак шестнадцатеричная строка.
Однако, поскольку One True Awk использовал strtod для преобразования строк в числа с плавающей запятой, и поскольку
.Dq 0x12
является допустимым шестнадцатеричным представлением числа с плавающей запятой,
На
.Fx ,
.Nm
принял это обозначение как расширение, поскольку One True Awk был импортирован в
.Fx 5.0 .
Upstream One True Awk восстановил историческое поведение в лучшую сторону
совместимость между различными реализациями awk.
И gawk, и mawk уже ведут себя одинаково.
Начиная с
.Fx 14.0
.Nm
больше не будет принимать это расширение.
.Pp
The
.Fx
.Nm
устанавливает языковой стандарт на многие годы в соответствии со средой, в которой он работает.
Это приводит к появлению диапазонов шаблонов, например
.Dq "[A-Z]"
иногда совпадают символы нижнего регистра в некоторых локалях.
Такого нарушения никогда не было в исходной версии One True Awk, и оно было удалено как ошибка.
ошибка в
.Fx 12.3 ,
.Fx 13.1 ,
и
.Fx 14.0 .