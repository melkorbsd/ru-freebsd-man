.\"
.\" SPDX-License-Identifier: BSD-2-Clause
.\"
.\" Copyright (c) 2018-2023 Gavin D. Howard and contributors.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions are met:
.\"
.\" * Redistributions of source code must retain the above copyright notice,
.\"   this list of conditions and the following disclaimer.
.\"
.\" * Redistributions in binary form must reproduce the above copyright notice,
.\"   this list of conditions and the following disclaimer in the documentation
.\"   and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
.\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
.\" LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.TH "BC" "1" «Февраль 2023 г.» «Гэвин Д. Ховард» «Руководство по общим командованиям»
.nh
.ad l
.SH ИМЯ
.PP
bc - arbitrary-precision decimal arithmetic language and calculator
.SH СИНТАКСИС
.PP
\f[B]bc\f[R] [\f[B]-cCghilPqRsvVw\f[R]] [\f[B]--digit-clamp\f[R]]
[\f[B]--no-digit-clamp\f[R]] [\f[B]--global-stacks\f[R]]
[\f[B]--help\f[R]] [\f[B]--interactive\f[R]] [\f[B]--mathlib\f[R]]
[\f[B]--no-prompt\f[R]] [\f[B]--no-read-prompt\f[R]] [\f[B]--quiet\f[R]]
[\f[B]--standard\f[R]] [\f[B]--warn\f[R]] [\f[B]--version\f[R]]
[\f[B]-e\f[R] \f[I]expr\f[R]]
[\f[B]--expression\f[R]=\f[I]expr\f[R]\&...]
[\f[B]-f\f[R] \f[I]file\f[R]\&...]
[\f[B]--file\f[R]=\f[I]file\f[R]\&...]
[\f[I]file\f[R]\&...]
[\f[B]-I\f[R] \f[I]ibase\f[R]] [\f[B]--ibase\f[R]=\f[I]ibase\f[R]]
[\f[B]-O\f[R] \f[I]obase\f[R]] [\f[B]--obase\f[R]=\f[I]obase\f[R]]
[\f[B]-S\f[R] \f[I]scale\f[R]] [\f[B]--scale\f[R]=\f[I]scale\f[R]]
[\f[B]-E\f[R] \f[I]seed\f[R]] [\f[B]--seed\f[R]=\f[I]seed\f[R]]
.SH ОПИСАНИЕ
.PP
bc(1) — интерактивный процессор для языка, впервые стандартизированного в
1991 год, POSIX.
(See the \f[B]STANDARDS\f[R] section.)
Язык обеспечивает десятичную арифметику неограниченной точности и
чем-то похож на C, но есть различия.
Такие различия будут отмечены в этом документе.
.PP
После анализа и обработки опций этот bc(1) читает любые файлы, указанные в
командную строку и выполняет их перед чтением из \f[B]stdin\f[R].
.PP
Этот bc(1) является заменой \f[I]any\f[R] bc(1), включая
(и особенно) GNU bc(1).
Он также имеет множество расширений и дополнительных функций, помимо других.
реализации.
.PP
\f[B]Примечание\f[R]: При запуске этого bc(1) на \f[I]любом\f[R] скрипте, предназначенном для
другой bc(1) выдает ошибку синтаксического анализа, возможно, это связано с тем, что слово this
bc(1) резервирует как ключевое слово, используется как имя функции, переменной,
или массив.
Чтобы это исправить, используйте параметр командной строки \f[B]-r\f[R] \f[I]ключевое слово\f[R],
где \f[I]keyword\f[R] — ключевое слово, которое используется в качестве имени в
сценарий.
Дополнительную информацию см. в разделе \f[B]OPTIONS\f[R].
.PP
Если синтаксический анализ сценариев, предназначенных для других реализаций bc(1), все еще не работает
работает, это ошибка, о которой следует сообщить.
См. раздел \f[B]ОШИБКИ\f[R].
.SH ПАРАМЕТРЫ
.PP
Ниже приведены параметры, которые принимает bc(1).
.TP
\f[B]-C\f[R], \f[B]--без фиксации цифр\f[R]
Отключает ограничение цифр, больших или равных текущему.
\f[B]ibase\f[R] при разборе чисел.
.RS
.PP
Это означает, что значение, добавляемое к числу из цифры, всегда равно этому значению.
значение цифры\[cq]s, умноженное на значение ibase, возведенное в степень
позиции цифры\[cq]s, которая начинается как минимум с 0
значащая цифра.
.PP
Если это и/или параметры \f[B]-c\f[R] или \f[B]--digit-clamp\f[R]
задано несколько раз, используется последний заданный.
.PP
Эта опция переопределяет переменную среды \f[B]BC_DIGIT_CLAMP\f[R]
(см. раздел \f[B]ENVIRONMENT VARIABLES\f[R]) и значение по умолчанию, которое
можно запросить с помощью опций \f[B]-h\f[R] или \f[B]--help\f[R].
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-c\f[R], \f[B]--цифровой зажим\f[R]
Позволяет фиксировать цифры, большие или равные текущему.
\f[B]ibase\f[R] при разборе чисел.
.RS
.PP
Это означает, что цифры, которые значение, добавленное к числу из цифры,
которое больше или равно ibase, это значение ibase минус 1
все умножено на значение ibase, возведенное в степень
позиция цифры\[cq]s, которая начинается с 0 по наименее значимому значению
цифра.
.PP
Если это и/или параметры \f[B]-C\f[R] или \f[B]--no-digit-clamp\f[R]
заданы несколько раз, используется последний заданный.
.PP
Эта опция переопределяет переменную среды \f[B]BC_DIGIT_CLAMP\f[R]
(см. раздел \f[B]ENVIRONMENT VARIABLES\f[R]) и значение по умолчанию, которое
можно запросить с помощью опций \f[B]-h\f[R] или \f[B]--help\f[R].
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-c\f[R], \f[B]--digit-clamp\f[R]
Позволяет фиксировать цифры, большие или равные текущему.
\f[B]ibase\f[R] при разборе чисел.
.RS
.PP
Это означает, что цифры, которые значение, добавленное к числу из цифры,
которое больше или равно ibase, это значение ibase минус 1
все умножено на значение ibase, возведенное в степень
позиция цифры\[cq]s, которая начинается с 0 по наименее значимому значению
цифра
.PP
Если это и/или параметры \f[B]-C\f[R] или \f[B]--no-digit-clamp\f[R]
заданы несколько раз, используется последний заданный.
.PP
Эта опция переопределяет переменную среды \f[B]BC_DIGIT_CLAMP\f[R]
(см. раздел \f[B]ENVIRONMENT VARIABLES\f[R]) и значение по умолчанию, которое
можно запросить с помощью опций \f[B]-h\f[R] или \f[B]--help\f[R].
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-E\f[R] \f[I]семя\f[R], \f[B]--seed\f[R]=\f[I]семя\f[R]
Устанавливает встроенную переменную \f[B]seed\f[R] в значение \f[I]seed\f[R]
предполагая, что \f[I]seed\f[R] находится в базе 10.
Это фатальная ошибка, если \f[I]seed\f[R] не является допустимым числом.
.RS
.PP
Если задано несколько экземпляров этой опции, используется последний.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-e\f[R] \f[I]выражение\f[R], \f[B]--выражение\f[R]=\f[I]выражение\f[R]
Оценивает \f[I]выражение\f[R].
Если задано несколько выражений, они вычисляются по порядку.
Если также указаны файлы (см. \f[B]-f\f[R] и \f[B]--file\f[R]
options), выражения и файлы оцениваются в указанном порядке.
Это означает, что если файл указан перед выражением, файл
сначала прочтите и оцените.
.RS
.PP
Если эта опция задана в командной строке (т. е. не в
\f[B]BC_ENV_ARGS\f[R], см. раздел \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]),
то после обработки всех выражений и файлов bc(1) завершится, если только
\f[B]-\f[R] (\f[B]stdin\f[R]) был указан в качестве аргумента хотя бы один раз
\f[B]-f\f[R] или \f[B]--file\f[R], как в командной строке, так и в
\f[B]BC_ENV_ARGS\f[R].
Однако если любое другое \f[B]-e\f[R], \f[B]--expression\f[R],
Аргументы \f[B]-f\f[R] или \f[B]--file\f[R] указываются после
задан \f[B]-f-\f[R] или эквивалент, bc(1) выдаст фатальную ошибку и
Выход.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-f\f[R] \f[I]файл\f[R], \f[B]--файл\f[R]=\f[I]файл\f[R]
Считывает файл \f[I]file\f[R] и вычисляет его построчно, как если бы это
были прочитаны через \f[B]stdin\f[R].
Если также заданы выражения (см. \f[B]-e\f[R] и
опции \f[B]--expression\f[R]), выражения вычисляются в
приказ отдан.
.RS
.PP
Если эта опция задана в командной строке (т. е. не в
\f[B]BC_ENV_ARGS\f[R], см. раздел \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]),
то после обработки всех выражений и файлов bc(1) завершится, если только
\f[B]-\f[R] (\f[B]stdin\f[R]) был указан в качестве аргумента хотя бы один раз
\f[B]-f\f[R] или \f[B]--file\f[R].
Однако если любое другое \f[B]-e\f[R], \f[B]--expression\f[R],
Аргументы \f[B]-f\f[R] или \f[B]--file\f[R] указываются после
задан \f[B]-f-\f[R] или эквивалент, bc(1) выдаст фатальную ошибку и
Выход
.PP
Это \f[B]непереносимое расширение\f[R].\
.RE
.TP
\f[B]-g\f[R], \f[B]--global-stacks\f[R]
Превращает глобальные переменные \f[B]ibase\f[R], \f[B]obase\f[R], \f[B]scale\f[R] и
\f[B]seed\f[R] в стопки.
.RS
.PP
Это приводит к тому, что копия текущего значения всех четырех
помещается в стек при каждом вызове функции, а также извлекается при каждом вызове функции.
каждая функция возвращает результат.
Это означает, что функции могут присваивать значения любым из этих глобальных переменных.
не беспокоясь о том, что изменение повлияет на другие функции.
Таким образом, гипотетическая функция с именем \f[B]output(x,b)\f[R] которая просто
напечатанный \f[B]x\f[R] в базе \f[B]b\f[R] можно записать так:
.IP
.nf
\f[C]
define void output(x, b) {
    obase=b
    x
}
\f[R]
.fi
.PP
instead of like this:
.IP
.nf
\f[C]
define void output(x, b) {
    auto c
    c=obase
    obase=b
    x
    obase=c
}
\f[R]
.fi
.PP
Это значительно упрощает написание функций.
.PP
(\f[B]Примечание\f[R]: функция \f[B]output(x,b)\f[R] существует в
расширенная математическая библиотека.
См. раздел \f[B]LIBRARY\f[R].)
.PP
Однако, поскольку использование этого флага означает, что функции не могут устанавливать
\f[B]ibase\f[R], \f[B]obase\f[R], \f[B]масштаб\f[R] или \f[B]seed\f[R]
в глобальном масштабе функции, созданные для этого, больше не могут работать.
Для этого есть два возможных варианта использования, и каждый из них имеет решение.
.PP
Во-первых, если при запуске вызывается функция для преобразования bc(1) в число
конвертер, эту возможность можно заменить различными оболочками
псевдонимы.
Примеры:
.IP
.nf
\f[C]
alias d2o=\[dq]bc -e ibase=A -e obase=8\[dq]
alias h2b=\[dq]bc -e ibase=G -e obase=2\[dq]
\f[R]
.fi
.PP
Во-вторых, если целью функции является установка \f[B]ibase\f[R],
\f[B]obase\f[R], \f[B]scale\f[R] или \f[B]seed\f[R] глобально для любого
для других целей его можно разделить на одну-четыре функции (в зависимости от
сколько глобальных переменных он устанавливает), и каждая из этих функций может возвращать
желаемое значение для глобального значения.
.PP
Для функций, устанавливающих \f[B]seed\f[R], значение, присвоенное
\f[B]seed\f[R] не передается родительским функциям.
Это означает, что последовательность псевдослучайных чисел, которую они увидят, будет
не быть той же самой последовательностью псевдослучайных чисел, которую видит любой родитель.
Это происходит только в том случае, если установлено \f[B]seed\f[R].
.PP
Если функция не желает влиять на последовательность псевдослучайных
номера своих родителей, но хочет использовать одно и то же \f[B]сид\f[R], он может
используйте следующую строку:
.IP
.nf
\f[C]
seed = seed
\f[R]
.fi
.PP
Если поведение этой опции желательно для каждого запуска bc(1), то
пользователи могут обязательно определить \f[B]BC_ENV_ARGS\f[R] и включить это
(более подробную информацию см. в разделе \f[B]ENVIRONMENT VARIABLES\f[R]
подробности).
.PP
Если используются \f[B]-s\f[R], \f[B]-w\f[R] или любые их эквиваленты, эта опция
игнорируется.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-h\f[R], \f[B]--help\f[R]
Печатает сообщение об использовании и завершает работу.
.TP
\f[B]-I\f[R] \f[I]ibase\f[R], \f[B]--ibase\f[R]=\f[I]ibase\f[R]
Устанавливает встроенную переменную \f[B]ibase\f[R] в значение \f[I]ibase\f[R]
предполагая, что \f[I]ibase\f[R] находится в системе счисления 10.
Если \f[I]ibase\f[R] не является допустимым числом, это является фатальной ошибкой.
.RS
.PP
Если задано несколько экземпляров этой опции, используется последний.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-i\f[R], \f[B]--interactive\f[R]
Включает интерактивный режим.
(См. раздел \f[B]ИНТЕРАКТИВНЫЙ РЕЖИМ\f[R].)
.RE
.TP
\f[B]-L\f[R], \f[B]--no-line-length\f[R]
Отключает проверку длины строки и печатает числа без обратной косой черты и
новые строки.
Другими словами, эта опция устанавливает для \f[B]BC_LINE_LENGTH\f[R] значение \f[B]0\f[R]
(см. раздел \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]).
.RS
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-l\f[R], \f[B]--mathlib\f[R]
Устанавливает для \f[B]scale\f[R] (см. раздел \f[B]СИНТАКСИС\f[R]) значение \f[B]20\f[R]
и загружает включенную математическую библиотеку и расширенную математическую библиотеку перед
запуск любого кода, включая любые выражения или файлы, указанные в
командная строка.
.RS
.PP
Чтобы узнать, что находится в библиотеках, смотрите раздел \f[B]LIBRARY\f[R].
.RE
.TP
\f[B]-O\f[R] \f[I]obase\f[R], \f[B]--obase\f[R]=\f[I]obase\f[R]
Устанавливает встроенную переменную \f[B]obase\f[R] в значение \f[I]obase\f[R]
предполагая, что \f[I]obase\f[R] имеет систему счисления 10.
Если \f[I]obase\f[R] не является допустимым числом, это является фатальной ошибкой.
.RS
.PP
Если задано несколько экземпляров этой опции, используется последний.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-P\f[R], \f[B]--без подсказки\f[R]
Отключает подсказку в режиме TTY.
(Запрос доступен только в режиме телетайпа.
См. раздел \f[B]TTY MODE\f[R].)
Это в основном для тех пользователей, которым не нужна подсказка или которые не используются.
чтобы они были в bc(1).
Большинство из этих пользователей хотели бы включить эту опцию
\f[B]BC_ENV_ARGS\f[R] (см. раздел \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]).
.RS
.PP
Эти параметры переопределяют \f[B]BC_PROMPT\f[R] и \f[B]BC_TTY_MODE\f[R]
переменные среды (см. раздел \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]).
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-q\f[R], \f[B]--тихо\f[R]
Эта опция предназначена для совместимости с GNU bc(1).
(https://www.gnu.org/software/bc/); это не операция.
Без этой опции GNU bc(1) печатает заголовок об авторских правах.
Этот bc(1) печатает заголовок об авторских правах только в том случае, если один или несколько из
приведены опции \f[B]-v\f[R], \f[B]-V\f[R] или \f[B]--version\f[R]
если переменная среды \f[B]BC_BANNER\f[R] не установлена и не содержит
ненулевое целое число или если этот bc(1) был построен с отображаемым заголовком
по умолчанию.
Если \f[I]любое\f[R] из этого имеет место, то этот вариант \f[I]выполняет\f[R]
запретить bc(1) печатать заголовок.
.RS
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-R\f[R], \f[B]--без запроса на чтение\f[R]
Отключает запрос на чтение в режиме TTY.
(Запрос на чтение доступен только в режиме телетайпа.
См. раздел \f[B]TTY MODE\f[R].)
Это в основном для тех пользователей, которым не нужна подсказка о прочтении или нет
привык иметь их в bc(1).
Большинство из этих пользователей хотели бы включить эту опцию
\f[B]BC_ENV_ARGS\f[R] (см. раздел \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]).
Эта опция также полезна в строках хеширования сценариев bc(1), которые
запрос на ввод данных пользователем.
.RS
.PP
Эта опция не отключает обычный запрос, поскольку запрос на чтение
используется только при вызове встроенной функции \f[B]read()\f[R].
.PP
Эти параметры \f[I]do\f[R] переопределяют \f[B]BC_PROMPT\f[R] и
Переменные среды \f[B]BC_TTY_MODE\f[R] (см. раздел \f[B]ENVIRONMENT
раздел VARIABLES\f[R]), но только для приглашения на чтение.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-r\f[R] \f[I]ключевое слово\f[R], \f[B]--redefine\f[R]=\f[I]ключевое слово\f[R]
Переопределяет ключевое слово \f[I]\f[R], чтобы его можно было использовать в качестве
имя функции, переменной или массива.
Это полезно, когда этот bc(1) выдает ошибки синтаксического анализа при синтаксическом анализе сценариев.
предназначено для других реализаций bc(1).
.RS
.PP
Ключевые слова, которые этот bc(1) позволяет переопределить:
.IP \[bu] 2
\f[B]abs\f[R]
.IP \[bu] 2
\f[B]asciify\f[R]
.IP \[bu] 2
\f[B]continue\f[R]
.IP \[bu] 2
\f[B]divmod\f[R]
.IP \[bu] 2
\f[B]else\f[R]
.IP \[bu] 2
\f[B]halt\f[R]
.IP \[bu] 2
\f[B]irand\f[R]
.IP \[bu] 2
\f[B]last\f[R]
.IP \[bu] 2
\f[B]limits\f[R]
.IP \[bu] 2
\f[B]maxibase\f[R]
.IP \[bu] 2
\f[B]maxobase\f[R]
.IP \[bu] 2
\f[B]maxrand\f[R]
.IP \[bu] 2
\f[B]maxscale\f[R]
.IP \[bu] 2
\f[B]modexp\f[R]
.IP \[bu] 2
\f[B]print\f[R]
.IP \[bu] 2
\f[B]rand\f[R]
.IP \[bu] 2
\f[B]read\f[R]
.IP \[bu] 2
\f[B]seed\f[R]
.IP \[bu] 2
\f[B]stream\f[R]
.PP
Если какое-либо из этих ключевых слов используется в качестве имени функции, переменной или массива
в сценарии используйте эту опцию с ключевым словом в качестве аргумента.
Если используется несколько, используйте эту опцию для всех из них; его можно использовать
много раз.
.PP
Ключевые слова \f[I]not\f[R] переопределяются при анализе встроенных математических функций.
библиотека (см. раздел \f[B]LIBRARY\f[R]).
.PP
Переопределение ключевых слов, предусмотренных стандартом POSIX, является фатальной ошибкой.
(см. раздел \f[B]СТАНДАРТЫ\f[R]).
Попытка переопределить слова, которую делает этот bc(1), является фатальной ошибкой.
не резервировать в качестве ключевых слов.
.RE
.TP
\f[B]-S\f[R] \f[I]масштаб\f[R], \f[B]--масштаб\f[R]=\f[I]масштаб\f[R]
Устанавливает встроенную переменную \f[B]scale\f[R] в значение \f[I]scale\f[R]
предполагая, что \f[I]scale\f[R] находится в десятичной системе счисления.
Это фатальная ошибка, если \f[I]scale\f[R] не является допустимым числом.
.RS
.PP
Если задано несколько экземпляров этой опции, используется последний.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-s\f[R], \f[B]-стандартный\f[R]
Обрабатывать именно тот язык, который определен стандартом (см.
раздел \f[B]STANDARDS\f[R]) и ошибка, если используются какие-либо расширения.
.RS
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-v\f[R], \f[B]-V\f[R], \f[B]--версия\f[R]
Распечатайте информацию о версии (заголовок об авторских правах) и выйдите
.RS
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-w\f[R], \f[B]--предупреждать\f[R]
Подобно \f[B]-s\f[R] и \f[B]--standard\f[R], за исключением того, что предупреждения (и
не ошибки) печатаются при нестандартных расширениях и исполнении.
продолжается нормально.
.RS
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]-z\f[R], \f[B]--ведущие нули\f[R]
Заставляет bc(1) печатать все числа больше \f[B]-1\f[R] и меньше
\f[B]1\f[R], и не равен \f[B]0\f[R] с ведущим нулем.
.RS
.PP
Это можно установить для отдельных номеров с помощью \f[B]plz(x)\f[R],
Функции \f[B]plznl(x)\f[R], \f[B]pnlz(x)\f[R] и \f[B]pnlznl(x)\f[R]
в расширенной математической библиотеке (см. раздел \f[B]LIBRARY\f[R]).
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.PP
Все длинные параметры являются \f[B]непереносимыми расширениями\f[R].
.SH STDIN
.PP
Если в \f[B]-f\f[R] не указаны файлы или выражения,
\f[B]--file\f[R], \f[B]-e\f[R] или \f[B]--expression\f[R] параметры, затем
bc(1) читает из \f[B]stdin\f[R].
.PP
Однако здесь есть несколько предостережений.
.PP
Сначала \f[B]stdin\f[R] оценивается построчно.
Единственное исключение из этого правила — если синтаксический анализ не может быть завершен.
Это означает, что начало строки без ее завершения или начало
функция, оператор \f[B]if\f[R] или цикл без его завершения также будут
привести к тому, что bc(1) не будет выполнен.
.PP
Во-вторых, после оператора \f[B]if\f[R] bc(1) не знает\[cq]t, есть ли
Последует оператор \f[B]else\f[R], поэтому он не будет выполнен до тех пор, пока не будет
знает, что оператора \f[B]else\f[R] не будет.
.SH STDOUT
.PP
Любой вывод без ошибок записывается в \f[B]stdout\f[R].
Кроме того, если история (см. раздел \f[B]HISTORY\f[R]) и
подсказка (см. раздел \f[B]TTY MODE\f[R]) включены, оба выводятся
в \f[B]stdout\f[R].
.PP
\f[B]Примечание\f[R]: В отличие от других реализаций bc(1), этот bc(1) будет
выдать фатальную ошибку (см. раздел \f[B]EXIT STATUS\f[R]), если она не может
запись в \f[B]stdout\f[R], поэтому, если \f[B]stdout\f[R] закрыт, как в
\f[B]bc >&-\f[R], он завершится с ошибкой.
Это сделано для того, чтобы bc(1) мог сообщать о проблемах, когда \f[B]stdout\f[R]
перенаправлен в файл.
.PP
Если есть скрипты, зависящие от поведения других bc(1)
реализации, рекомендуется изменить эти сценарии на
перенаправить \f[B]stdout\f[R] на \f[B]/dev/null\f[R].
.SH СТДЕРР
.PP
Любой вывод ошибок записывается в \f[B]stderr\f[R].
.PP
\f[B]Примечание\f[R]: В отличие от других реализаций bc(1), этот bc(1) будет
выдать фатальную ошибку (см. раздел \f[B]EXIT STATUS\f[R]), если она не может
запись в \f[B]stderr\f[R], поэтому, если \f[B]stderr\f[R] закрыт, как в
\f[B]bc 2>&-\f[R], он завершится с ошибкой.
Это сделано для того, чтобы bc(1) мог завершить работу с кодом ошибки при
\f[B]stderr\f[R] перенаправляется в файл.
.PP
Если есть скрипты, зависящие от поведения других bc(1)
реализации, рекомендуется изменить эти сценарии на
перенаправить \f[B]stderr\f[R] на \f[B]/dev/null\f[R].
.SH СИНТАКСИС
.PP
Синтаксис программ bc(1) в основном похож на C, но с некоторыми отличиями.
Этот bc(1) соответствует стандарту POSIX (см. \f[B]STANDARDS\f[R]
раздел), который является гораздо более подробным ресурсом по данному языку.
bc(1) принимает.
Этот раздел предназначен для краткого изложения и перечисления всех
расширения стандарта.
.PP
В разделах ниже \f[B]E\f[R] означает выражение, \f[B]S\f[R] означает
оператор, а \f[B]I\f[R] означает идентификатор.
.PP
Идентификаторы (\f[B]I\f[R]) начинаются со строчной буквы и могут быть
за которым следует любое число (до \f[B]BC_NAME_MAX-1\f[R]) строчных букв
буквы (\f[B]a-z\f[R]), цифры (\f[B]0-9\f[R]) и подчеркивания
(\f[B]_\f[R]).
Регулярное выражение: \f[B][a-z][a-z0-9_]*\f[R].
Идентификаторы, содержащие более одного символа (буквы), являются
\f[B]непереносимое расширение\f[R].
.PP
\f[B]ibase\f[R] — глобальная переменная, определяющая, как интерпретировать
постоянные числа.
Это база \[lq]input\[rq] или система счисления, используемая для интерпретации.
ввод цифр.
\f[B]ibase\f[R] изначально равен \f[B]10\f[R].
Если \f[B]-s\f[R] (\f[B]--standard\f[R]) и \f[B]-w\f[R]
(\f[B]--warn\f[R]) флаги не были заданы в командной строке, макс.
допустимое значение для \f[B]ibase\f[R] — \f[B]36\f[R].
В противном случае это \f[B]16\f[R].
Минимально допустимое значение для \f[B]ibase\f[R] — \f[B]2\f[R].
Максимально допустимое значение для \f[B]ibase\f[R] можно запросить в bc(1)
программы со встроенной функцией \f[B]maxibase()\f[R].
.PP
\f[B]obase\f[R] — глобальная переменная, определяющая способ вывода результатов.
Это база \[lq]output\[rq] или система счисления, используемая для вывода.
цифры.
\f[B]obase\f[R] изначально равен \f[B]10\f[R].
Максимально допустимое значение для \f[B]obase\f[R] — \f[B]BC_BASE_MAX\f[R] и
могут быть запрошены в программах bc(1) с помощью встроенной функции \f[B]maxobase()\f[R]
функция.
Минимально допустимое значение для \f[B]obase\f[R] — \f[B]0\f[R].
Если \f[B]obase\f[R] равно \f[B]0\f[R], значения выводятся в научном формате.
нотации, и если \f[B]obase\f[R] равно \f[B]1\f[R], значения выводятся в
инженерные обозначения.
В противном случае значения выводятся в указанной базе.
.PP
Вывод в научной и инженерной нотации \f[B]непереносим.
расширения\f[R].
.PP
\f[I]масштаб\f[R] выражения — это количество цифр в
результат выражения справа от десятичной точки и \f[B]scale\f[R]
— глобальная переменная, определяющая точность любых операций, при этом
исключения.
\f[B]масштаб\f[R] изначально равен \f[B]0\f[R].
\f[B]масштаб\f[R] не может быть отрицательным.
Максимально допустимое значение \f[B]scale\f[R] — \f[B]BC_SCALE_MAX\f[R]
и может быть запрошен в программах bc(1) с помощью \f[B]maxscale()\f[R]
встроенная функция.
.PP
bc(1) имеет как \f[I]глобальные\f[R] переменные, так и \f[I]локальные\f[R] переменные.
Все переменные \f[I]local\f[R] являются локальными для функции; они есть
параметры или вводятся в список \f[B]auto\f[R] функции
(см. раздел \f[B]ФУНКЦИИ\f[R]).
Если осуществляется доступ к переменной, которая не является параметром или находится в
\f[B]auto\f[R] список, предполагается, что это \f[I]глобальный\f[R].
Если родительская функция имеет версию переменной \f[I]local\f[R]
переменная, которую дочерняя функция считает \f[I]global\f[R], значение
что переменная \f[I]global\f[R] в дочерней функции является значением
переменная в родительской функции, а не значение фактического
\f[I]глобальная\f[R] переменная.
.PP
Все вышесказанное относится и к массивам.
.PP
Значение оператора, который является выражением (т. е. любым из именованных
выражения или операнды) печатается, если только не указан самый низкий приоритет.
оператор является оператором присваивания \f[I]и\f[R] выражение
не заключен в круглые скобки.
.PP
Выведенное значение также присваивается специальной переменной.
\f[B]последний\f[R].
Одна точка (\f[B].\f[R]) также может использоваться как синоним
\f[B]последний\f[R].
Это \f[B]непереносимые расширения\f[R].
.PP
Операторы могут разделяться точкой с запятой или новой строкой.
.SS Comments
.PP
Есть два вида комментариев:
.IP "1." 3
Комментарии к блокам заключаются в \f[B]/*\f[R] и \f[B]*/\f[R].
.IP "2." 3
Комментарии к строке идут от \f[B]#\f[R] до следующей (не включая)
новая линия.
Это \f[B]непереносимое расширение\f[R].
.SS Named Expressions
.PP
Следующие выражения являются именованными в bc(1):
.IP "1." 3
Переменные: \f[B]I\f[R]
.IP "2." 3
Элементы массива: \f[B]I[E]\f[R]
.IP "3." 3
\f[B]ibase\f[R]
.IP "4." 3
\f[B]obase\f[R]
.IP "5." 3
\f[B]scale\f[R]
.IP "6." 3
\f[B]seed\f[R]
.IP "7." 3
\f[B]last\f[R] or a single dot (\f[B].\f[R])
.PP
Номера 6 и 7 — это \f[B]непереносимые расширения\f[R].
.PP
Значение \f[B]seed\f[R] зависит от текущего псевдослучайного значения.
генератор чисел, но гарантированно не изменится, за исключением новых основных
версии.
.PP
\f[I]масштаб\f[R] и знак значения могут иметь значение.
.PP
Если ранее использованное значение \f[B]seed\f[R] присвоено \f[B]seed\f[R]
и повторное использование генератора псевдослучайных чисел гарантированно
производят ту же последовательность псевдослучайных чисел, что и при
Ранее использовалось значение \f[B]seed\f[R].
.PP
Точное значение, присвоенное \f[B]seed\f[R], не гарантируется.
возвращается, если \f[B]seed\f[R] немедленно запрашивается снова.
Однако, если \f[B]seed\f[R] \f[I]\f[R] возвращает другое значение, оба
значения, присвоенные \f[B]seed\f[R], гарантированно создают
одна и та же последовательность псевдослучайных чисел.
Это означает, что определенные значения, присвоенные \f[B]seed\f[R], будут
\f[I]not\f[R] создают уникальные последовательности псевдослучайных чисел.
Значение \f[B]seed\f[R] изменится после любого использования
операнды \f[B]rand()\f[R] и \f[B]irand(E)\f[R] (см.
\f[I]Операнды\f[R] ниже), за исключением случаев, когда параметр передается в
\f[B]irand(E)\f[R] равен \f[B]0\f[R], \f[B]1\f[R] или отрицательно.
.PP
Длина (количество значащих десятичных цифр) не ограничена.
или \f[I]scale\f[R] значения, которое можно присвоить \f[B]seed\f[R].
.PP
Переменные и массивы не мешают; пользователи могут иметь массивы с именем
то же, что переменные.
Это также относится и к функциям (см. раздел \f[B]FUNCTIONS\f[R]), поэтому
пользователь может иметь переменную, массив и функцию, которые имеют одинаковый
name, и они не будут затенять друг друга, будь то внутри функций
или нет.
.PP
Именованные выражения необходимы в качестве операнда
\f[B]increment\f[R]/\f[B]декремент\f[R] операторы и в качестве левой части
операторов \f[B]присваивания\f[R] (см. \f[I]Операторы\f[R]
подраздел)
.SS Operands
.PP
Следующие операнды являются допустимыми в bc(1):
.IP " 1." 4
Числа (см. подраздел \f[I]Numbers\f[R] ниже).
.IP " 2." 4
Индексы массива (\f[B]I[E]\f[R]).
.IP " 3." 4
\f[B](E)\f[R]: значение \f[B]E\f[R] (используется для изменения приоритета).
.IP " 4." 4
\f[B]sqrt(E)\f[R]: квадратный корень из \f[B]E\f[R].
\f[B]E\f[R] должно быть неотрицательным.
.IP " 5." 4
\f[B]sqrt(E)\f[R]: квадратный корень из \f[B]E\f[R].
\f[B]E\f[R] должно быть неотрицательным.
.ИП "5." 4
\f[B]длина(E)\f[R]: количество значащих десятичных цифр в
\f[B]E\f[R].
Возвращает \f[B]1\f[R] для \f[B]0\f[R] без десятичных знаков.
Если задана строка, возвращается длина строки.
Передача строки в \f[B]length(E)\f[R] является \f[B]непереносимым
расширение\f[R].
.IP " 6." 4
\f[B]length(I[])\f[R]: количество элементов в массиве \f[B]I\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP " 7." 4
\f[B]scale(E)\f[R]: The \f[I]scale\f[R] of \f[B]E\f[R].
.IP " 8." 4
\f[B]abs(E)\f[R]: абсолютное значение \f[B]E\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP " 9." 4
\f[B]is_number(E)\f[R]: \f[B]1\f[R], если данный аргумент является числом,
\f[B]0\f[R], если это строка.
Это \f[B]непереносимое расширение\f[R].
.IP "10." 4
\f[B]is_string(E)\f[R]: \f[B]1\f[R], если данный аргумент является строкой,
\f[B]0\f[R], если это число.
Это \f[B]непереносимое расширение\f[R].
.IP "11." 4
\f[B]modexp(E, E, E)\f[R]: модульное возведение в степень, где первое
выражение является основанием, второе — показатель степени, а третье — степень.
модуль.
Все три значения должны быть целыми числами.
Второй аргумент должен быть неотрицательным.
Третий аргумент должен быть ненулевым.
Это \f[B]непереносимое расширение\f[R].
.IP "12." 4
\f[B]divmod(E, E, I[])\f[R]: деление и модуль за одну операцию.
Это для оптимизации.
Первое выражение — это делимое, а второе — делитель,
который должен быть ненулевым.
Возвращаемое значение — это частное, а модуль сохраняется в индексе.
\f[B]0\f[R] предоставленного массива (последний аргумент).
Это \f[B]непереносимое расширение\f[R].
.IP "13." 4
\f[B]asciify(E)\f[R]: если \f[B]E\f[R] — строка, возвращает строку, которая
— это первая буква его аргумента.
Если это число, вычисляет число по модулю \f[B]256\f[R] и возвращает
это число как односимвольная строка.
Это \f[B]непереносимое расширение\f[R].
.IP "14." 4
\f[B]asciify(I[])\f[R]: строка, состоящая из символов,
будет результатом выполнения \f[B]asciify(E)\f[R] для каждого элемента
массив, идентифицируемый аргументом.
Это позволяет создавать многосимвольные строки и хранить их.
Это \f[B]непереносимое расширение\f[R].
.IP "15." 4
\f[B]I()\f[R], \f[B]I(E)\f[R], \f[B]I(E, E)\f[R] и так далее, где
\f[B]I\f[R] — идентификатор функции, отличной от \f[B]void\f[R] (см.
\f[I]Void Functions\f[R] подраздел раздела \f[B]FUNCTIONS\f[R]).
Аргументы \f[B]E\f[R] также могут быть массивами вида
\f[B]I[]\f[R], которые будут автоматически преобразованы в ссылки на массивы.
(см. подраздел \f[I]Ссылки на массивы\f[R] руководства
раздел \f[B]FUNCTIONS\f[R]), если соответствующий параметр в
определение функции является ссылкой на массив.
.IP "16." 4
\f[B]read()\f[R]: считывает строку из \f[B]stdin\f[R] и использует ее как
выражение.
Результатом этого выражения является результат \f[B]read()\f[R]
операнд.
Это \f[B]непереносимое расширение\f[R].
.IP "17." 4
\f[B]maxibase()\f[R]: максимально допустимое значение \f[B]ibase\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP "18." 4
\f[B]maxobase()\f[R]: Максимально допустимое \f[B]obase\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP "19." 4
\f[B]maxscale()\f[R]: Максимально допустимый \f[B]масштаб\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP "20." 4
\f[B]line_length()\f[R]: длина строки, заданная с помощью
\f[B]BC_LINE_LENGTH\f[R] (см. \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]
раздел).
Это \f[B]непереносимое расширение\f[R].
.IP "21." 4
\f[B]global_stacks()\f[R]: \f[B]0\f[R], если глобальные стеки не включены
с параметрами \f[B]-g\f[R] или \f[B]--global-stacks\f[R], ненулевыми
в противном случае.
См. раздел \f[B]ОПЦИИ\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP "22." 4
\f[B]leading_zero()\f[R]: \f[B]0\f[R], если ведущие нули не включены
с параметрами \f[B]-z\f[R] или \f[B]\[en]ведущие нули\f[R], ненулевые
в противном случае.
См. раздел \f[B]ОПЦИИ\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP "23." 4
\f[B]rand()\f[R]: псевдослучайное целое число между \f[B]0\f[R]
(включительно) и \f[B]BC_RAND_MAX\f[R] (включительно).
Использование этого операнда изменит значение \f[B]seed\f[R].
Это \f[B]непереносимое расширение\f[R].
.IP "24." 4
\f[B]irand(E)\f[R]: псевдослучайное целое число между \f[B]0\f[R]
(включительно) и значение \f[B]E\f[R] (исключительно).
Если \f[B]E\f[R] отрицательное или нецелое число (\f[B]E\f[R]\[cq]s
\f[I]scale\f[R] не \f[B]0\f[R]), возникает ошибка и bc(1)
сбрасывается (см. раздел \f[B]RESET\f[R]), пока \f[B]seed\f[R] остается
без изменений.
Если \f[B]E\f[R] больше, чем \f[B]BC_RAND_MAX\f[R], верхняя граница равна
удостоился чести генерировать несколько псевдослучайных целых чисел и умножать их
соответствующими степенями \f[B]BC_RAND_MAX+1\f[R] и их сложения
вместе.
Таким образом, размер целого числа, которое может быть сгенерировано с помощью этого операнда, равен
неограниченный.
Использование этого операнда изменит значение \f[B]seed\f[R], если только
значение \f[B]E\f[R] равно \f[B]0\f[R] или \f[B]1\f[R].
В этом случае возвращается \f[B]0\f[R] и \f[B]seed\f[R]
\f[Я]не\f[R] изменился.
Это \f[B]непереносимое расширение\f[R].
.IP "25." 4
\f[B]maxrand()\f[R]: максимальное целое число, возвращаемое \f[B]rand()\f[R].
Это \f[B]непереносимое расширение\f[R].
.PP
Целые числа, сгенерированные \f[B]rand()\f[R] и \f[B]irand(E)\f[R]:
гарантированно будет максимально беспристрастным, с учетом ограничений
генератор псевдослучайных чисел.
.PP
\f[B]Примечание\f[R]: значения, возвращаемые псевдослучайным числом.
генератор с \f[B]rand()\f[R] и \f[B]irand(E)\f[R] гарантированно
\f[I]NOT\f[R] быть криптографически безопасным.
Это следствие использования генератора псевдослучайных чисел с затравкой.
Однако они \f[I]\f[R] гарантированно воспроизводятся с идентичными
\f[B]начальные\f[R] значения.
Это означает, что псевдослучайные значения из bc(1) следует использовать только
где воспроизводимый поток псевдослучайных чисел
\f[I]ОБЯЗАТЕЛЬНО\f[R].
В любом другом случае используйте генератор псевдослучайных чисел без начального числа.
.SS Numbers
.PP
Числа — это строки, состоящие из цифр, заглавных букв и не более
\f[B]1\f[R] период для системы счисления.
Числа могут содержать до \f[B]BC_NUM_MAX\f[R] цифр.
Прописные буквы равны \f[B]9\f[R] плюс их позиция в
алфавита, начиная с \f[B]1\f[R] (т. е. \f[B]A\f[R] равно
\f[B]10\f[R] или \f[B]9+1\f[R]).
.PP
Если цифра или буква не имеют смысла при текущем значении
\f[B]ibase\f[R] (т.е. они больше или равны текущему
значение \f[B]ibase\f[R]), то поведение зависит от существования
\f[B]-c\f[R]/\f[B]--digit-clamp\f[R] или
Опции \f[B]-C\f[R]/\f[B]--no-digit-clamp\f[R] (см.
раздел \f[B]OPTIONS\f[R]), наличие и настройка
\f[B]BC_DIGIT_CLAMP\f[R] переменная среды (см. \f[B]ENVIRONMENT
раздел VARIABLES\f[R]) или значение по умолчанию, которое можно запросить с помощью
\f[B]-h\f[R]/\f[B]--help\f[R] опция
.PP
Если ограничение отключено, то цифры или буквы, большие или
равные текущему значению \f[B]ibase\f[R] не изменяются.
Вместо этого их заданное значение умножается на соответствующую степень
\f[B]ibase\f[R] и добавляется в число.
Это означает, что при \f[B]ibase\f[R] \f[B]3\f[R] число
\f[B]AB\f[R] равен \f[B]3\[ha]1*A+3\[ha]0*B\f[R], что
\f[B]3\f[R] раз \f[B]10\f[R] плюс \f[B]11\f[R] или \f[B]41\f[R].
.PP
Если ограничение включено, то цифры или буквы, большие или равные
к текущему значению \f[B]ibase\f[R] устанавливаются равными значению
самая высокая допустимая цифра в \f[B]ibase\f[R] перед умножением на
соответствующую степень \f[B]ibase\f[R] и добавляется к числу.
Это означает, что при \f[B]ibase\f[R] \f[B]3\f[R] число
\f[B]AB\f[R] равен \f[B]3\[ha]1*2+3\[ha]0*2\f[R], что
\f[B]3\f[R] раз \f[B]2\f[R] плюс \f[B]2\f[R] или \f[B]8\f[R].
.PP
Есть одно исключение из ограничения: односимвольные числа (т. е.
только \f[B]A\f[R]).
Такие числа никогда не фиксируются и всегда принимают то значение, которое они имели бы.
в максимально возможном \f[B]ibase\f[R].
Это означает, что только \f[B]A\f[R] всегда равно десятичному \f[B]10\f[R] и
\f[B]Z\f[R] сам по себе всегда равен десятичному \f[B]35\f[R].
Такое поведение предусмотрено стандартом (см. раздел «СТАНДАРТЫ»).
и предназначен для обеспечения простого способа установки текущей \f[B]ibase\f[R]
(командой \f[B]i\f[R]) независимо от текущего значения
\f[B]ibase\f[R].
.PP
Если ограничение включено и требуется фиксированное значение символа, используйте
ведущий ноль, т. е. для \f[B]A\f[R] используйте \f[B]0A\f[R].
.PP
Кроме того, bc(1) принимает числа в экспоненциальной записи.
Они имеют вид \f[B]<число>e<целое число>\f[R].
Показатель степени (часть после \f[B]e\f[R]) должен быть целым числом.
Пример: \f[B]1.89237e9\f[R], что равно
\f[B]1892370000\f[R].
Отрицательные показатели также допускаются, поэтому \f[B]4.2890e-3\f[R] равно
\f[B]0.0042890\f[R].
.PP
Использование научной записи является ошибкой или предупреждением, если \f[B]-s\f[R] или
\f[B]-w\f[R] соответственно, параметры командной строки (или их эквиваленты):
данный.
.PP
\f[B]ВНИМАНИЕ\f[R]: И число, и показатель степени в научных
обозначения интерпретируются в соответствии с текущей \f[B]ibase\f[R], но
число по-прежнему умножается на \f[B]10\[ha]экспонента\f[R] независимо
текущей \f[B]ibase\f[R].
Например, если \f[B]ibase\f[R] равен \f[B]16\f[R] и bc(1) задано
числовая строка \f[B]FFeA\f[R], результирующее десятичное число будет
\f[B]2550000000000\f[R], и если bc(1) задана числовая строка
\f[B]10e-4\f[R], результирующее десятичное число будет \f[B]0,0016\f[R].
.PP
Принятие входных данных в экспоненциальной записи является \f[B]непереносимым
расширение\f[R].
.SS Operators
.PP
Можно использовать следующие арифметические и логические операторы.
Они перечислены в порядке убывания приоритета.
Операторы в одной группе имеют одинаковый приоритет.
.TP
\f[B]++\f[R] \f[B]--\f[R]
Тип: префикс и постфикс.
.RS
.PP
Ассоциативность: Нет
.PP
Описание: \f[B]инкремент\f[R], \f[B]декремент\f[R]
.RE
.TP
\f[B]-\f[R] \f[B]!\f[R]
Тип: Префикс
.RS
.PP
Ассоциативность: Нет
.PP
Описание: \f[B]отрицание\f[R], \f[B]логическое не\f[R]
.RE
.TP
\f[B]$\f[R]
Тип: Постфикс
.RS
.PP
Ассоциативность: Нет
.PP
Описание: \f[B]усечение\f[R]
.RE
.TP
\f[B]\[at]\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Правая
.PP
Описание: \f[B]установить точность\f[R]
.RE
.TP
\f[B]\[ha]\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Правая
.PP
Описание: \f[B]мощность\f[R]
.RE
.TP
\f[B]*\f[R] \f[B]/\f[R] \f[B]%\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Левая
.PP
Описание: \f[B]умножить\f[R], \f[B]делить\f[R], \f[B]модуль\f[R]
.RE
.TP
\f[B]+\f[R] \f[B]-\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Левая
.PP
Описание: \f[B]добавить\f[R], \f[B]вычесть\f[R]
.RE
.TP
\f[B]<<\f[R] \f[B]>>\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Левая
.PP
Описание: \f[B]сдвиг влево\f[R], \f[B]сдвиг вправо\f[R]
.RE
.TP
\f[B]=\f[R] \f[B]<<=\f[R] \f[B]>>=\f[R] \f[B]+=\f[R] \f[B]-=\f[R] \f[B]*=\f[R] \f[B]/=\f[R] \f[B]%=\f[R] \f[B]\[ha]=\f[R] \f[B]\[at]=\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Правая
.PP
Описание: \f[B]назначение\f[R]
.RE
.TP
\f[B]==\f[R] \f[B]<=\f[R] \f[B]>=\f[R] \f[B]!=\f[R] \f[B]<\f[R] \f[B]>\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Левая
.PP
Описание: \f[B]реляционный\f[R]
.RE
.TP
\f[B]&&\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Левая
.PP
Описание: \f[B]логическое значение и\f[R]
.RE
.TP
\f[B]||\f[R]
Тип: Двоичный
.RS
.PP
Ассоциативность: Левая
.PP
Описание: \f[B]логическое значение или\f[R]
.RE
.PP
Более подробно операторы будут описаны ниже.
.TP
\f[B]++\f[R] \f[B]--\f[R]
Префикс и постфикс \f[B]increment\f[R] и \f[B]decrement\f[R]
операторы ведут себя точно так же, как в C.
Им требуется именованное выражение (см. \f[I]Именованные выражения\f[R]
подраздел) в качестве операнда.
.RS
.PP
Префиксные версии этих операторов более эффективны; используй их
где возможно.
.RE
.TP
\f[B]-\f[R]
Оператор \f[B]отрицание\f[R] возвращает \f[B]0\f[R], если пользователь пытается
для отрицания любого выражения со значением \f[B]0\f[R].
В противном случае возвращается копия выражения с перевернутым знаком.
.TP
\f[B]!\f[R]
Логический оператор \f[B]not\f[R] возвращает \f[B]1\f[R], если выражение
это \f[B]0\f[R] или \f[B]0\f[R] в противном случае.
.RS
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]$\f[R]
Оператор \f[B]truncation\f[R] возвращает копию заданного выражения.
со всей удаленной \f[I]масштабом\f[R].
.RS
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]\[at]\f[R]
Оператор \f[B]set Precision\f[R] принимает два выражения и возвращает
копию первого с его \f[I]масштабом\f[R] равным значению
второе выражение.
Это может означать, что число возвращается без изменений (если
\f[I]scale\f[R] первого выражения соответствует значению
второе выражение), расширенное (если оно меньше) или усеченное (если оно
более).
.RS
.PP
Второе выражение должно быть целым числом (без \f[I]scale\f[R]) и
неотрицательный.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]\[ha]\f[R]
Оператор \f[B]power\f[R] (а не оператор \f[B]эксклюзивный или \f[R],
как это было бы в C) принимает два выражения и возводит первое в
степень значения второго.
\f[I]масштаб\f[R] результата равен \f[B]масштаб\f[R].
.RS
.PP
Второе выражение должно быть целым числом (без \f[I]scale\f[R]), и если оно
отрицательно, первое значение должно быть отличным от нуля..
.RE
.TP
\f[B]*\f[R]
Оператор \f[B]multiply\f[R] принимает два выражения, умножает их,
и возвращает товар.
Если \f[B]a\f[R] — это \f[I]масштаб\f[R] первого выражения и
\f[B]b\f[R] — это \f[I]масштаб\f[R] второго выражения,
\f[I]масштаб\f[R] результата равен
\f[B]min(a+b,max(scale,a,b))\f[R] где \f[B]min()\f[R] и
\f[B]max()\f[R] возвращает очевидные значения.
.TP
\f[B]/\f[R]
Оператор \f[B]divide\f[R] принимает два выражения, делит их и
возвращает частное.
\f[I]scale\f[R] результата должно быть значением \f[B]scale\f[R].
.RS
.PP
Второе выражение должно быть ненулевым.
.RE
.TP
\f[B]%\f[R]
Оператор \f[B]modulus\f[R] принимает два выражения: \f[B]a\f[R] и
\f[B]b\f[R] и оценивает их путем: 1) вычисления \f[B]a/b\f[R] до текущего значения
\f[B]масштаб\f[R] и 2) Использование результата шага 1 для расчета
\f[B]a-(a/b)*b\f[R] до \f[I]масштаба\f[R]
\f[B]max(масштаб+масштаб(b),масштаб(a))\f[R].
.RS
.PP
Второе выражение должно быть ненулевым.
.RE
.TP
\f[B]+\f[R]
Оператор \f[B]add\f[R] принимает два выражения: \f[B]a\f[R] и
\f[B]b\f[R] и возвращает сумму с масштабом \f[I]\f[R], равным
max шкалы \f[I]\f[R]s для \f[B]a\f[R] и \f[B]b\f[R].
.TP
\f[B]-\f[R]
Оператор \f[B]subtract\f[R] принимает два выражения: \f[B]a\f[R] и
\f[B]b\f[R] и возвращает разницу, при этом масштаб \f[I]\f[R] равен
максимум шкалы \f[I]\f[R]s для \f[B]a\f[R] и \f[B]b\f[R].
.TP
\f[B]<<\f[R]
Оператор \f[B]сдвиг влево\f[R] принимает два выражения: \f[B]a\f[R] и
\f[B]b\f[R] и возвращает копию значения \f[B]a\f[R] с его
десятичная точка перемещена на \f[B]b\f[R] позиций вправо.
.RS
.PP
Второе выражение должно быть целым числом (без \f[I]scale\f[R]) и
неотрицательный.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]>>\f[R]
Оператор \f[B]сдвиг вправо\f[R] принимает два выражения: \f[B]a\f[R]
и \f[B]b\f[R] и возвращает копию значения \f[B]a\f[R] с его
десятичная точка перемещена на \f[B]b\f[R] позиций влево.
.RS
.PP
Второе выражение должно быть целым числом (без \f[I]scale\f[R]) и
неотрицательный.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]=\f[R] \f[B]<<=\f[R] \f[B]>>=\f[R] \f[B]+=\f[R] \f[B]-=\f[R] \f[B]*=\f[R] \f[B]/=\f[R] \f[B]%=\f[R] \f[B]\[ha]=\f[R] \f[B]\[at]=\f[R]
Операторы \f[B]assignment\f[R] принимают два выражения: \f[B]a\f[R] и
\f[B]b\f[R] где \f[B]a\f[R] — именованное выражение (см. \f[I]Named
Выражения\f[R] подраздел).
.RS
.PP
Для \f[B]=\f[R] копируется \f[B]b\f[R] и результат присваивается
\f[B]a\f[R].
Для всех остальных \f[B]a\f[R] и \f[B]b\f[R] применяются в качестве операндов для
соответствующий арифметический оператор, и результат присваивается
\f[B]a\f[R].
.PP
Операторы \f[B]assignment\f[R], соответствующие операторам,
расширения сами по себе являются \f[B]непереносимыми расширениями\f[R].
.RE
.TP
\f[B]==\f[R] \f[B]<=\f[R] \f[B]>=\f[R] \f[B]!=\f[R] \f[B]<\f[R] \f[B]>\f[R]
Операторы \f[B]реляционный\f[R] сравнивают два выражения: \f[B]a\f[R]
и \f[B]b\f[R], и если соотношение выполняется, согласно языку C
семантики, результатом будет \f[B]1\f[R].
В противном случае это \f[B]0\f[R].
.RS
.PP
Обратите внимание, что в отличие от C, эти операторы имеют более низкий приоритет, чем
\f[B]присваивание\f[R] операторов, что означает, что \f[B]a=b>c\f[R]
интерпретируется как \f[B](a=b)>c\f[R].
.PP
Также в отличие от стандарта (см. раздел \f[B]СТАНДАРТЫ\f[R])
требует, эти операторы могут появляться везде, где могут быть любые другие выражения.
использоваться.
Это разрешение является \f[B]непереносимым расширением\f[R].
.RE
.TP
\f[B]&&\f[R]
Оператор \f[B]boolean и\f[R] принимает два выражения и возвращает
\f[B]1\f[R], если оба выражения ненулевые, \f[B]0\f[R] в противном случае.
.RS
.PP
Это \f[I]not\f[R] оператор короткого замыкания.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.TP
\f[B]||\f[R]
Логический оператор \f[B]или\f[R] принимает два выражения и возвращает
\f[B]1\f[R], если одно из выражений не равно нулю, \f[B]0\f[R]
в противном случае.
.RS
.PP
Это \f[I]not\f[R] оператор короткого замыкания.
.PP
Это \f[B]непереносимое расширение\f[R].
.RE
.SS Statements
.PP
Следующие пункты являются утверждениями:
.IP " 1." 4
\f[B]E\f[R]
.IP " 2." 4
\f[B]{\f[R] \f[B]S\f[R] \f[B];\f[R] \&...
\f[B];\f[R] \f[B]S\f[R] \f[B]}\f[R]
.IP " 3." 4
\f[B]if\f[R] \f[B](\f[R] \f[B]E\f[R] \f[B])\f[R] \f[B]S\f[R]
.IP " 4." 4
\f[B]if\f[R] \f[B](\f[R] \f[B]E\f[R] \f[B])\f[R] \f[B]S\f[R]
\f[B]else\f[R] \f[B]S\f[R]
.IP " 5." 4
\f[B]while\f[R] \f[B](\f[R] \f[B]E\f[R] \f[B])\f[R] \f[B]S\f[R]
.IP " 6." 4
\f[B]for\f[R] \f[B](\f[R] \f[B]E\f[R] \f[B];\f[R] \f[B]E\f[R]
\f[B];\f[R] \f[B]E\f[R] \f[B])\f[R] \f[B]S\f[R]
.IP " 7." 4
Пустое заявление
.IP " 8." 4
\f[B]break\f[R]
.IP " 9." 4
\f[B]continue\f[R]
.IP "10." 4
\f[B]quit\f[R]
.IP "11." 4
\f[B]halt\f[R]
.IP "12." 4
\f[B]limits\f[R]
.IP "13." 4
Строка символов, заключенная в двойные кавычки
.IP "14." 4
\f[B]print\f[R] \f[B]E\f[R] \f[B],\f[R] \&...
\f[B],\f[R] \f[B]E\f[R]
.IP "15." 4
\f[B]stream\f[R] \f[B]E\f[R] \f[B],\f[R] \&...
\f[B],\f[R] \f[B]E\f[R]
.IP "16." 4
\f[B]I()\f[R], \f[B]I(E)\f[R], \f[B]I(E, E)\f[R] и так далее, где
\f[B]I\f[R] — идентификатор функции \f[B]void\f[R] (см.
\f[I]Void Functions\f[R] подраздел раздела \f[B]FUNCTIONS\f[R]).
Аргументы \f[B]E\f[R] также могут быть массивами вида
\f[B]I[]\f[R], которые будут автоматически преобразованы в ссылки на массивы.
(см. подраздел \f[I]Ссылки на массивы\f[R] руководства
раздел \f[B]FUNCTIONS\f[R]), если соответствующий параметр в
определение функции является ссылкой на массив.
.PP
Числа 4, 9, 11, 12, 14, 15 и 16 \f[B]непереносимы.
расширения\f[R].
.PP
Кроме того, в качестве \f[B]непереносимого расширения\f[R] любое или все
выражения в заголовке цикла for можно опустить.
Если условие (второе выражение) опущено, предполагается, что оно является
константа \f[B]1\f[R].
.PP
Оператор \f[B]break\f[R] заставляет цикл прекратить итерацию и возобновить ее.
выполнение сразу после цикла.
Это разрешено только в циклах.
.PP
Оператор \f[B]continue\f[R] вызывает досрочную остановку итерации цикла.
и возвращается к началу цикла, включая тестирование цикла
состояние.
Это разрешено только в циклах.
.PP
Оператор \f[B]if\f[R] \f[B]else\f[R] делает то же самое, что и в C.
.PP
Оператор \f[B]quit\f[R] приводит к завершению работы bc(1), даже если он находится на
ветка, которая не будет выполнена (это команда времени компиляции).
.PP
\f[B]Предупреждение\f[R]: поведение этого bc(1) при \f[B]quit\f[R]
немного отличается от других реализаций bc(1).
Другие реализации bc(1) завершат работу, как только завершат анализ
строка, в которой находится команда \f[B]quit\f[R].
Этот bc(1) будет выполнять любые завершенные и исполняемые операторы, которые
происходят перед оператором \f[B]quit\f[R] перед выходом.
.PP
Другими словами, для кода bc(1) ниже:
.IP
.nf
\f[C]
for (i = 0; i < 3; ++i) i; quit
\f[R]
.fi
.PP
Другие реализации bc(1) ничего не выведут, а эта bc(1) будет
напечатайте \f[B]0\f[R], \f[B]1\f[R] и \f[B]2\f[R] в последовательных строках
перед выходом.
.PP
Оператор \f[B]halt\f[R] приводит к завершению работы bc(1), если он выполняется.
(В отличие от \f[B]quit\f[R], если он находится в ветви оператора \f[B]if\f[R]
который не выполняется, bc(1) не завершает работу.)
.PP
Оператор \f[B]limits\f[R] выводит пределы, которыми является этот bc(1).
при условии.
Это похоже на оператор \f[B]quit\f[R] тем, что он выполняется во время компиляции.
команда.
.PP
Выражение само по себе оценивается и печатается, после чего следует перевод строки.
.PP
Доступны как научная, так и инженерная нотация.
печать результатов выражений.
Научная запись активируется присвоением \f[B]0\f[R]
\f[B]obase\f[R], а инженерная нотация активируется присвоением
\f[B]1\f[R] — \f[B]obase\f[R].
Чтобы деактивировать их, просто присвойте другое значение \f[B]obase\f[R].
.PP
Экспоненциальная и инженерная нотация отключены, если bc(1) равен
запустите с параметрами командной строки \f[B]-s\f[R] или \f[B]-w\f[R]
(или эквиваленты).
.PP
Печать чисел в научной и/или инженерной записи является
\f[B]непереносимое расширение\f[R].
.SS Strings
.PP
Если строки появляются как операторы сами по себе, они печатаются без
завершающая новая строка.
.PP
Помимо того, что строки сами по себе выглядят как отдельный оператор, они могут
присваиваться переменным и элементам массива.
Их также можно передавать функциям с переменными параметрами.
.PP
Если какому-либо оператору, ожидающему строку, присвоена переменная, имеющая
присвоенная ему строка, оператор действует так, как если бы он получил
нить.
.PP
Если какая-либо математическая операция предпринята над строкой, переменной или массивом
элементу, которому была присвоена строка, возникает ошибка и bc(1)
сбрасывает (см. раздел \f[B]RESET\f[R]).
.PP
Присвоение строк переменным и элементам массива и передача их в
функции являются \f[B]непереносимыми расширениями\f[R].
.SS Print Statement
.PP
Выражения \[lq]expressions\[rq] в операторе \f[B]print\f[R] также могут быть
струны.
Если да, то существуют escape-последовательности обратной косой черты, которые интерпретируются
специально.
Что это за последовательности и что они вызывают на печати, показано ниже.
ниже:
.PP
\f[B]\[rs]a\f[R]: \f[B]\[rs]a\f[R]
.PP
\f[B]\[rs]b\f[R]: \f[B]\[rs]b\f[R]
.PP
\f[B]\[rs]\[rs]\f[R]: \f[B]\[rs]\f[R]
.PP
\f[B]\[rs]e\f[R]: \f[B]\[rs]\f[R]
.PP
\f[B]\[rs]f\f[R]: \f[B]\[rs]f\f[R]
.PP
\f[B]\[rs]n\f[R]: \f[B]\[rs]n\f[R]
.PP
\f[B]\[rs]q\f[R]: \f[B]\[lq]\f[R]
.PP
\f[B]\[rs]r\f[R]: \f[B]\[rs]r\f[R]
.PP
\f[B]\[rs]t\f[R]: \f[B]\[rs]t\f[R]
.PP
Любой другой символ, следующий за обратной косой чертой, вызывает обратную косую черту и
символ, который будет напечатан как есть.
.PP
Любое нестроковое выражение в операторе печати должно быть присвоено
\f[B]last\f[R], как и любое другое выводимое выражение.
.SS Stream Statement
.PP
Выражения \[lq]в операторе \f[B]stream\f[R] также могут быть
струны.
.PP
Если оператору \f[B]stream\f[R] задана строка, он печатает строку
как будто строка появилась как отдельный оператор.
Другими словами, оператор \f[B]stream\f[R] нормально печатает строки,
без новой строки.
.PP
Если оператору \f[B]stream\f[R] присвоен номер, его копия
усекается и вычисляется его абсолютное значение.
Затем результат печатается так, как будто \f[B]obase\f[R] равен \f[B]256\f[R]
и каждая цифра интерпретируется как 8-битный символ ASCII, что делает его
поток байтов.
.SS Order of Evaluation
.PP
Все выражения в инструкции оцениваются слева направо, за исключением
необходимо для поддержания порядка в работе.
Это означает, например, что \f[B]i\f[R] равен
\f[B]0\f[R], в выражении
.IP
.nf
\f[C]
a[i++] = i++
\f[R]
.fi
.PP
первому (или 0-му) элементу \f[B]a\f[R] присваивается значение \f[B]1\f[R], и
\f[B]i\f[R] равен \f[B]2\f[R] в конце выражения.
.PP
Сюда входят аргументы функции.
Таким образом, если предположить, что \f[B]i\f[R] равно \f[B]0\f[R], это означает, что в
выражение
.IP
.nf
\f[C]
x(i++, i++)
\f[R]
.fi
.PP
первый аргумент, передаваемый в \f[B]x()\f[R] — это \f[B]0\f[R], а
второй аргумент — \f[B]1\f[R], а \f[B]i\f[R] равен
\f[B]2\f[R] перед началом выполнения функции.
.SH FUNCTIONS
.PP
Определения функций следующие:
.IP
.nf
\f[C]
define I(I,...,I){
    auto I,...,I
    S;...;S
    return(E)
}
\f[R]
.fi
.PP
Любой \f[B]I\f[R] в списке параметров или списке \f[B]auto\f[R] может быть
заменяется на \f[B]I[]\f[R] для создания параметра или \f[B]auto\f[R] var an
массив, а любой \f[B]I\f[R] в списке параметров можно заменить на
\f[B]*I[]\f[R] чтобы сделать параметр ссылкой на массив.
Вызывающие функции, которые принимают ссылки на массивы, не должны помещать
звездочка в звонилке; их нужно вызывать с помощью \f[B]I[]\f[R] например
обычные параметры массива и будут автоматически преобразованы в
Рекомендации.
.PP
В качестве непереносимого расширения \f[B]\f[R] открывающая скобка
Оператор \f[B]define\f[R] может появиться на следующей строке.
.PP
В качестве \f[B]непереносимого расширения\f[R] оператор return также может быть
в одной из следующих форм:
.IP "1." 3
\f[B]return\f[R]
.IP "2." 3
\f[B]return\f[R] \f[B](\f[R] \f[B])\f[R]
.IP "3." 3
\f[B]return\f[R] \f[B]E\f[R]
.PP
Первые два или без указания оператора \f[B]return\f[R] — это
эквивалентно \f[B]return (0)\f[R], если только функция не является
Функция \f[B]void\f[R] (см. подраздел \f[I]Void Functions\f[R]
ниже).
.SS Void Functions
.PP
Функции также могут быть функциями \f[B]void\f[R], определяемыми следующим образом:
.IP
.nf
\f[C]
define void I(I,...,I){
    auto I,...,I
    S;...;S
    return
}
\f[R]
.fi
.PP
Их можно использовать только как самостоятельные выражения, где такое
выражение будет напечатано отдельно, за исключением оператора печати.
.PP
Функции Void могут использовать только первые два оператора \f[B]return\f[R]
вышеперечисленное.
Они также могут полностью опустить оператор возврата.
.PP
Слово \[lq]void\[rq] не рассматривается как ключевое слово; это все еще
возможно иметь переменные, массивы и функции с именем \f[B]void\f[R].
Слово \[lq]void\[rq] обрабатывается особым образом только сразу после
Ключевое слово \f[B]define\f[R].
.PP
Это \f[B]непереносимое расширение\f[R].
Ссылки на массивы .SS
.PP
Для любого массива в списке параметров, если массив объявлен в
форма
.IP
.nf
\f[C]
*I[]
\f[R]
.fi
.PP
это ссылка \f[B]\f[R].
Любые изменения массива в функции отражаются, когда
функция возвращает массив, который был передан.
.PP
Кроме этого, все аргументы функции передаются по значению.
.PP
Это \f[B]непереносимое расширение\f[R].
.SH LIBRARY
.PP
Все приведенные ниже функции, включая функции расширенной математики.
(см. подраздел \f[I]Расширенная библиотека\f[R] ниже), являются
доступно, если в командной строке \f[B]-l\f[R] или \f[B]--mathlib\f[R]
флаги указаны, за исключением того, что расширенная математическая библиотека недоступна
когда опция \f[B]-s\f[R], опция \f[B]-w\f[R] или эквиваленты
дано.
.SS Standard Library
.PP
Стандарт (см. раздел \f[B]СТАНДАРТЫ\f[R]) определяет следующее:
функции для математической библиотеки:
.TP
\f[B]s(x)\f[R]
Возвращает синус \f[B]x\f[R], который предположительно выражен в радианах.
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]c(x)\f[R]
Возвращает косинус \f[B]x\f[R], который предположительно выражен в радианах.
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]a(x)\f[R]
Возвращает арктангенс \f[B]x\f[R] в радианах.
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]l(x)\f[R]
Возвращает натуральный логарифм \f[B]x\f[R].
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]e(x)\f[R]
Возвращает математическую константу \f[B]e\f[R], возведенную в степень
\f[B]x\f[R].
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]j(x, n)\f[R]
Возвращает порядок целых чисел Бесселя \f[B]n\f[R] (усеченный) для \f[B]x\f[R].
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.SS Extended Library
.PP
Расширенная библиотека \f[I]не\f[R] загружается, когда
\f[B]-s\f[R]/\f[B]--standard\f[R] или \f[B]-w\f[R]/\f[B]--предупреждать\f [Р]
параметры даны, поскольку они не являются частью библиотеки, определенной
стандарт (см. раздел \f[B]СТАНДАРТЫ\f[R]).
.PP
Расширенная библиотека является \f[B]непереносимым расширением\f[R].
.TP
\f[B]p(x, y)\f[R]
Вычисляет \f[B]x\f[R] в степени \f[B]y\f[R], даже если \f[B]y\f[R]
не является целым числом и возвращает результат в текущий
\f[B]масштаб\f[R].
.RS
.PP
Это ошибка, если \f[B]y\f[R] отрицательно, а \f[B]x\f[R]
\f[B]0\f[R].
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]r(x, p)\f[R]
Возвращает \f[B]x\f[R] с округлением до \f[B]p\f[R] десятичных знаков в соответствии с
режим округления на половину от \f[B]0\f[R]
(https://en.wikipedia.org/wiki/Rounding#Round_half_away_from_zero).
.TP
\f[B]ceil(x, p)\f[R]
Возвращает \f[B]x\f[R] с округлением до \f[B]p\f[R] десятичных знаков в соответствии с
режим округления округляется от \f[B]0\f[R]
(https://en.wikipedia.org/wiki/Rounding#Rounding_away_from_zero).
.TP
\f[B]f(x)\f[R]
Возвращает факториал усеченного абсолютного значения \f[B]x\f[R].
.TP
\f[B]perm(n, k)\f[R]
Возвращает перестановку усеченного абсолютного значения \f[B]n\f[R]
усеченного абсолютного значения \f[B]k\f[R], если \f[B]k <= n\f[R].
Если нет, возвращается \f[B]0\f[R].
.TP
\f[B]comb(n, k)\f[R]
Возвращает комбинацию усеченного абсолютного значения \f[B]n\f[R]
усеченного абсолютного значения \f[B]k\f[R], если \f[B]k <= n\f[R].
Если нет, возвращается \f[B]0\f[R].
.TP
\f[B]l2(x)\f[R]
Возвращает основание логарифма \f[B]2\f[R] для \f[B]x\f[R].
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]l10(x)\f[R]
Возвращает основание логарифма \f[B]10\f[R] для \f[B]x\f[R].
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]log(x, b)\f[R]
Возвращает основание логарифма \f[B]b\f[R] для \f[B]x\f[R].
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]cbrt(x)\f[R]
Возвращает кубический корень из \f[B]x\f[R].
.TP
\f[B]root(x, n)\f[R]
Вычисляет усеченное значение \f[B]n\f[R], \f[B]r\f[R] и возвращает
\f[B]r\f[R]-й корень из \f[B]x\f[R] к текущему масштабу \f[B]\f[R].
.RS
.PP
Если \f[B]r\f[R] равно \f[B]0\f[R] или отрицательное значение, это вызывает ошибку и
вызывает сброс bc(1) (см. раздел \f[B]RESET\f[R]).
Это также вызывает ошибку и приводит к сбросу bc(1), если \f[B]r\f[R] четно.
и \f[B]x\f[R] является отрицательным.
.RE
.TP
\f[B]gcd(a, b)\f[R]
Возвращает наибольший общий делитель (множитель) усеченного абсолютного значения.
значение \f[B]a\f[R] и усеченное абсолютное значение \f[B]b\f[R].
.TP
\f[B]lcm(a, b)\f[R]
Возвращает наименьшее общее кратное усеченного абсолютного значения
\f[B]a\f[R] и усеченное абсолютное значение \f[B]b\f[R].
.TP
\f[B]pi(p)\f[R]
Возвращает \f[B]pi\f[R] до \f[B]p\f[R] десятичных знаков.
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]t(x)\f[R]
Возвращает тангенс \f[B]x\f[R], который предположительно выражен в радианах.
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]a2(y, x)\f[R]
Возвращает арктангенс \f[B]y/x\f[R] в радианах.
Если оба \f[B]y\f[R] и \f[B]x\f[R] равны \f[B]0\f[R], это поднимает
возникает ошибка и вызывает сброс bc(1) (см. раздел \f[B]RESET\f[R]).
В противном случае, если \f[B]x\f[R] больше, чем \f[B]0\f[R], возвращается
\f[B]a(y/x)\f[R].
Если \f[B]x\f[R] меньше, чем \f[B]0\f[R], а \f[B]y\f[R] больше, чем
или равно \f[B]0\f[R], он возвращает \f[B]a(y/x)+pi\f[R].
Если \f[B]x\f[R] меньше, чем \f[B]0\f[R], а \f[B]y\f[R] меньше, чем
\f[B]0\f[R], он возвращает \f[B]a(y/x)-pi\f[R].
Если \f[B]x\f[R] равно \f[B]0\f[R], а \f[B]y\f[R] больше, чем
\f[B]0\f[R], он возвращает \f[B]pi/2\f[R].
Если \f[B]x\f[R] равно \f[B]0\f[R], а \f[B]y\f[R] меньше, чем
\f[B]0\f[R], он возвращает \f[B]-pi/2\f[R].
.RS
.PP
Эта функция аналогична функции \f[B]atan2()\f[R] во многих
языки программирования.
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]sin(x)\f[R]
Возвращает синус \f[B]x\f[R], который предположительно выражен в радианах.
.RS
.PP
Это псевдоним \f[B]s(x)\f[R].
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]cos(x)\f[R]
Возвращает косинус \f[B]x\f[R], который предположительно выражен в радианах.
.RS
.PP
Это псевдоним \f[B]c(x)\f[R].
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]tan(x)\f[R]
Возвращает тангенс \f[B]x\f[R], который предположительно выражен в радианах.
.RS
.PP
Если \f[B]x\f[R] равно \f[B]1\f[R] или \f[B]-1\f[R], это вызывает
ошибка и вызывает сброс bc(1) (см. раздел \f[B]RESET\f[R]).
.PP
Это псевдоним \f[B]t(x)\f[R].
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]atan(x)\f[R]
Возвращает арктангенс \f[B]x\f[R] в радианах.
.RS
.PP
Это псевдоним \f[B]a(x)\f[R].
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]atan2(y, x)\f[R]
Возвращает арктангенс \f[B]y/x\f[R] в радианах.
Если оба \f[B]y\f[R] и \f[B]x\f[R] равны \f[B]0\f[R], это поднимает
возникает ошибка и вызывает сброс bc(1) (см. раздел \f[B]RESET\f[R]).
В противном случае, если \f[B]x\f[R] больше, чем \f[B]0\f[R], возвращается
\f[B]a(y/x)\f[R].
Если \f[B]x\f[R] меньше, чем \f[B]0\f[R], а \f[B]y\f[R] больше, чем
или равно \f[B]0\f[R], он возвращает \f[B]a(y/x)+pi\f[R].
Если \f[B]x\f[R] меньше, чем \f[B]0\f[R], а \f[B]y\f[R] меньше, чем
\f[B]0\f[R], он возвращает \f[B]a(y/x)-pi\f[R].
Если \f[B]x\f[R] равно \f[B]0\f[R], а \f[B]y\f[R] больше, чем
\f[B]0\f[R], он возвращает \f[B]pi/2\f[R].
Если \f[B]x\f[R] равно \f[B]0\f[R], а \f[B]y\f[R] меньше, чем
\f[B]0\f[R], он возвращает \f[B]-pi/2\f[R].
.RS
.PP
Эта функция аналогична функции \f[B]atan2()\f[R] во многих
языки программирования.
.PP
Это псевдоним \f[B]a2(y, x)\f[R].
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]r2d(x)\f[R]
Преобразует \f[B]x\f[R] из радиан в градусы и возвращает результат.
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]d2r(x)\f[R]
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RS
.PP
Это трансцендентная функция (см. \f[I]Трансцендентальная функция
Функции\f[R] ниже).
.RE
.TP
\f[B]франд(p)\f[R]
Генерирует псевдослучайное число между \f[B]0\f[R] (включительно) и
\f[B]1\f[R] (исключительно) с количеством десятичных цифр после
десятичная точка, равная усеченному абсолютному значению \f[B]p\f[R].
Если \f[B]p\f[R] не \f[B]0\f[R], то вызов этой функции приведет к
измените значение \f[B]seed\f[R].
Если \f[B]p\f[R] равно \f[B]0\f[R], то возвращается \f[B]0\f[R] и
\f[B]seed\f[R] \f[I]не\f[R] изменено.
.TP
\f[B]ifrand(i, p)\f[R]
Генерирует псевдослучайное число в диапазоне \f[B]0\f[R] (включительно).
и усеченное абсолютное значение \f[B]i\f[R] (исключительно) с
количество десятичных цифр после запятой, равное усеченному
абсолютное значение \f[B]p\f[R].
Если абсолютное значение \f[B]i\f[R] больше или равно
\f[B]2\f[R], а \f[B]p\f[R] не является \f[B]0\f[R], то вызов этого
функция изменит значение \f[B]seed\f[R]; в противном случае \f[B]0\f[R]
возвращается, а \f[B]seed\f[R] не изменяется.
.TP
\f[B]srand(x)\f[R]
Возвращает \f[B]x\f[R] со знаком, измененным с вероятностью.
\f[B]0.5\f[R].
Другими словами, он рандомизирует знак \f[B]x\f[R].
.TP
\f[B]brand()\f[R]
Возвращает случайное логическое значение (либо \f[B]0\f[R] либо \f[B]1\f[R]).
.TP
\f[B]band(a, b)\f[R]
Принимает усеченное абсолютное значение как \f[B]a\f[R], так и \f[B]b\f[R]
и вычисляет и возвращает результат поразрядных \f[B] и \f[R]
операция между ними.
.RS
.PP
Если вы хотите использовать аргументы дополнения двух знаков, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bor(a, b)\f[R]
Принимает усеченное абсолютное значение как \f[B]a\f[R], так и \f[B]b\f[R]
и вычисляет и возвращает результат побитового \f[B]или\f[R]
операция между ними.
.RS
.PP
Если вы хотите использовать аргументы дополнения двух знаков, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bxor(a, b)\f[R]
Принимает усеченное абсолютное значение как \f[B]a\f[R], так и \f[B]b\f[R]
и вычисляет и возвращает результат побитового \f[B]xor\f[R]
операция между ними.
.RS
.PP
Если вы хотите использовать аргументы дополнения двух знаков, используйте
\f[B]s2u(x)\f[R] to convert.
.RE
.TP
\f[B]bshl(a, b)\f[R]
Принимает усеченное абсолютное значение как \f[B]a\f[R], так и \f[B]b\f[R]
и вычисляет и возвращает результат \f[B]a\f[R] с битовым сдвигом влево на
\f[B]b\f[R] мест.
.RS
.PP
Если вы хотите использовать аргументы дополнения двух знаков, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bshr(a, b)\f[R]
Принимает усеченное абсолютное значение как \f[B]a\f[R], так и \f[B]b\f[R]
и вычисляет и возвращает усеченный результат \f[B]a\f[R]
сдвинуто вправо на \f[B]b\f[R] мест.
.RS
.PP
Если вы хотите использовать аргументы дополнения двух знаков, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bnotn(x, n)\f[R]
Принимает усеченное абсолютное значение \f[B]x\f[R] и побитово не выполняет
как будто он имеет то же количество байтов, что и усеченный абсолютный
value of \f[B]n\f[R].
.RS
.PP

.RE Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.TP
\f[B]bnot8(x)\f[R]
Поразрядно не использует усеченное абсолютное значение \f[B]x\f[R] как
хотя он имеет двоичные цифры \f[B]8\f[R] (1 байт без знака).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bnot16(x)\f[R]
Поразрядно не использует усеченное абсолютное значение \f[B]x\f[R] как
хотя он имеет \f[B]16\f[R] двоичных цифр (2 байта без знака).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bnot32(x)\f[R]
Поразрядно не использует усеченное абсолютное значение \f[B]x\f[R] как
хотя он имеет \f[B]32\f[R] двоичные цифры (4 байта без знака).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bnot64(x)\f[R]
Поразрядно не использует усеченное абсолютное значение \f[B]x\f[R] как
хотя он имеет \f[B]64\f[R] двоичные цифры (8 байтов без знака).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bnot(x)\f[R]
Поразрядно не использует усеченное абсолютное значение \f[B]x\f[R] как
хотя он имеет минимальную мощность в два беззнаковых байта.
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brevn(x, n)\f[R]
Выполняет битовую реверсию усеченного абсолютного значения \f[B]x\f[R] как
хотя он имеет то же количество 8-битных байтов, что и усеченный абсолютный
значение \f[B]n\f[R]. 
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brev8(x)\f[R]
Выполняет битовую реверсию усеченного абсолютного значения \f[B]x\f[R] как
хотя он имеет 8 двоичных цифр (1 байт без знака).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] to convert.
.RE
.TP
\f[B]brev16(x)\f[R]
Выполняет битовую реверсию усеченного абсолютного значения \f[B]x\f[R] как
хотя он имеет 16 двоичных цифр (2 беззнаковых байта).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brev32(x)\f[R]
Выполняет битовую реверсию усеченного абсолютного значения \f[B]x\f[R] как
хотя он имеет 32 двоичных цифры (4 байта без знака).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brev64(x)\f[R]
Выполняет битовую реверсию усеченного абсолютного значения \f[B]x\f[R] как
хотя он имеет 64 двоичных цифры (8 байтов без знака).
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brev(x)\f[R]
Выполняет битовую реверсию усеченного абсолютного значения \f[B]x\f[R] как
хотя он имеет минимальную мощность в два беззнаковых байта.
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]broln(x, p, n)\f[R]
Выполняет побитовое вращение влево усеченного абсолютного значения
\f[B]x\f[R], как если бы он имел такое же количество беззнаковых 8-битных байтов, что и
усеченное абсолютное значение \f[B]n\f[R] на количество мест
равно усеченному абсолютному значению \f[B]p\f[R], модифицированному
\f[B]2\f[R] в степени числа двоичных цифр в \f[B]n\f[R]
8-битные байты.
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brol8(x, p)\f[R]
Выполняет побитовое вращение влево усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал двоичные цифры \f[B]8\f[R] (\f[B]1\f[R]
беззнаковый байт), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]8\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brol16(x, p)\f[R]
Выполняет побитовое вращение влево усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал \f[B]16\f[R] двоичных цифр (\f[B]2\f[R]
беззнаковые байты), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]16\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brol32(x, p)\f[R]
Выполняет побитовое вращение влево усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал \f[B]32\f[R] двоичные цифры (\f[B]2\f[R]
беззнаковые байты), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]32\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brol64(x, p)\f[R]
Выполняет побитовое вращение влево усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал \f[B]64\f[R] двоичные цифры (\f[B]2\f[R]
беззнаковые байты), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]64\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brol(x, p)\f[R]
Выполняет побитовое вращение влево усеченного абсолютного значения
\f[B]x\f[R], как если бы оно имело минимальное число степени двойки
беззнаковые 8-битные байты, на количество разрядов, равное усеченному
абсолютное значение \f[B]p\f[R], модифицированное на 2 в степени числа
двоичные цифры в минимальном количестве 8-битных байтов.
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]brorn(x, p, n)\f[R]
Выполняет побитовое вращение вправо усеченного абсолютного значения
\f[B]x\f[R], как если бы он имел такое же количество беззнаковых 8-битных байтов, что и
усеченное абсолютное значение \f[B]n\f[R] на количество мест
равно усеченному абсолютному значению \f[B]p\f[R], модифицированному
\f[B]2\f[R] в степени числа двоичных цифр в \f[B]n\f[R]
8-битные байты.
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bror8(x, p)\f[R] 
Выполняет побитовое вращение вправо усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал двоичные цифры \f[B]8\f[R] (\f[B]1\f[R]
беззнаковый байт), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]8\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bror16(x, p)\f[R]
Выполняет побитовое вращение вправо усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал \f[B]16\f[R] двоичных цифр (\f[B]2\f[R]
беззнаковые байты), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]16\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bror32(x, p)\f[R]
Выполняет побитовое вращение вправо усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал \f[B]32\f[R] двоичные цифры (\f[B]2\f[R]
беззнаковые байты), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]32\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bror64(x, p)\f[R]
Выполняет побитовое вращение вправо усеченного абсолютного значения
\f[B]x\f[R], как если бы он содержал \f[B]64\f[R] двоичные цифры (\f[B]2\f[R]
беззнаковые байты), на количество мест, равное усеченному абсолютному
значение \f[B]p\f[R], модифицированное \f[B]2\f[R] в степени \f[B]64\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bror(x, p)\f[R]
Выполняет побитовое вращение вправо усеченного абсолютного значения
\f[B]x\f[R], как если бы оно имело минимальное число степени двойки
беззнаковые 8-битные байты, на количество разрядов, равное усеченному
абсолютное значение \f[B]p\f[R], модифицированное на 2 в степени числа
двоичные цифры в минимальном количестве 8-битных байтов.
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bmodn(x, n)\f[R]
Возвращает модуль усеченного абсолютного значения \f[B]x\f[R] на
\f[B]2\f[R] в степени умножения усеченного абсолюта
значение \f[B]n\f[R] и \f[B]8\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bmod8(x, n)\f[R]
Возвращает модуль усеченного абсолютного значения \f[B]x\f[R] на
\f[B]2\f[R] to the power of \f[B]8\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bmod16(x, n)\f[R]
Возвращает модуль усеченного абсолютного значения \f[B]x\f[R] на
\f[B]2\f[R] в степени \f[B]16\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bmod32(x, n)\f[R]
Возвращает модуль усеченного абсолютного значения \f[B]x\f[R] на
\f[B]2\f[R] в степени \f[B]32\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bmod64(x, n)\f[R]
Возвращает модуль усеченного абсолютного значения \f[B]x\f[R] на
\f[B]2\f[R] в степени \f[B]64\f[R].
.RS
.PP
Если вы хотите использовать подписанный аргумент дополнения двух\[cq]s, используйте
\f[B]s2u(x)\f[R] для преобразования.
.RE
.TP
\f[B]bunrev(t)\f[R]
Предполагается, что \f[B]t\f[R] — поразрядное число с дополнительным установленным битом.
на один разряд более значимый, чем реальный самый значимый бит (который был
младший бит исходного числа).
Это число инвертируется и возвращается без дополнительного установленного бита.
.RS
.PP
Эта функция используется для реализации других побитовых функций; это не
предназначено для использования пользователями, но это может быть.
.RE
.TP
\f[B]plz(x)\f[R]
If \f[B]x\f[R] is not equal to \f[B]0\f[R] and greater that \f[B]-1\f[R]
и меньше \f[B]1\f[R], он печатается с ведущим нулем, независимо от
использования опции \f[B]-z\f[R] (см. \f[B]OPTIONS\f[R]
раздел) и без завершающего символа новой строки.
.RS
.PP
В противном случае \f[B]x\f[R] печатается нормально, без завершающего символа новой строки.
.RE
.TP
\f[B]plznl(x)\f[R]
Если \f[B]x\f[R] не равно \f[B]0\f[R] и больше \f[B]-1\f[R]
и меньше \f[B]1\f[R], он печатается с ведущим нулем, независимо от
использования опции \f[B]-z\f[R] (см. \f[B]OPTIONS\f[R]
раздел) и с завершающим символом новой строки.
.RS
.PP
В противном случае \f[B]x\f[R] печатается обычным образом с завершающей новой строкой.
.RE
.TP
\f[B]pnlz(x)\f[R]
Если \f[B]x\f[R] не равно \f[B]0\f[R] и больше \f[B]-1\f[R]
и меньше \f[B]1\f[R], он печатается без ведущего нуля,
независимо от использования опции \f[B]-z\f[R] (см.
раздел \f[B]OPTIONS\f[R]) и без завершающего символа новой строки.
.RS
.PP
В противном случае \f[B]x\f[R] печатается нормально, без завершающего символа новой строки.
.RE
.TP
\f[B]pnlznl(x)\f[R]
Если \f[B]x\f[R] не равно \f[B]0\f[R] и больше \f[B]-1\f[R]
и меньше \f[B]1\f[R], он печатается без ведущего нуля,
независимо от использования опции \f[B]-z\f[R] (см.
раздел \f[B]OPTIONS\f[R]) и с завершающим символом новой строки.
.RS
.PP
В противном случае \f[B]x\f[R] печатается обычным образом с завершающей новой строкой.
.RE
.TP
\f[B]ubytes(x)\f[R]
Возвращает количество беззнаковых целых байтов, необходимых для хранения
усеченное абсолютное значение \f[B]x\f[R].
.TP
\f[B]sbytes(x)\f[R]
Возвращает количество знаковых двух\[cq]s-дополняющих целых байтов.
требуется для хранения усеченного значения \f[B]x\f[R].
.TP
\f[B]s2u(x)\f[R]
Возвращает \f[B]x\f[R], если оно неотрицательное.
Если он \f[I]\f[R] отрицательный, то он вычисляет, что будет \f[B]x\f[R]
быть целым числом со знаком до 2\[cq]s и возвращает неотрицательное значение
целое число, которое будет иметь такое же представление в двоичном виде.
.TP
\f[B]s2un(x,n)\f[R]
Возвращает \f[B]x\f[R], если оно неотрицательное.
Если он \f[I]\f[R] отрицательный, то он вычисляет, что будет \f[B]x\f[R]
быть целым числом со знаком, дополненным 2\[cq]s, с байтами \f[B]n\f[R] и
возвращает неотрицательное целое число, которое будет иметь такое же представление
в двоичном формате.
Если \f[B]x\f[R] не может вписаться в \f[B]n\f[R] 2\[cq]s-дополнение со знаком
байт, он усекается по размеру.
.TP
\f[B]hex(x)\f[R]
Выводит шестнадцатеричное (базовое \f[B]16\f[R]) представление
\f[B]x\f[R].
.RS
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]binary(x)\f[R]
Выводит двоичное (базовое \f[B]2\f[R]) представление \f[B]x\f[R].
.RS
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]output(x, b)\f[R]
Выводит базовое представление \f[B]b\f[R] \f[B]x\f[R].
.RS
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]uint(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число без знака в минимально возможной степени двух байтов.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не является целым числом или отрицательным, появится сообщение об ошибке.
вместо этого печатается, но bc(1) не сбрасывается (см. \f[B]RESET\f[R]
раздел).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]int(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число со знаком, дополненное двумя \[cq]s, в двух байтах в такой малой степени, как
возможный.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не является целым числом, вместо этого выводится сообщение об ошибке:
но bc(1) не сбрасывается (см. раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]uintn(x, n)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число без знака в \f[B]n\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не целое число, отрицательное число или не может вписаться в
\f[B]n\f[R] байт, вместо этого выводится сообщение об ошибке, но bc(1) нет.
сброс (см. раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]intn(x, n)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число со знаком, дополненное двумя \[cq]s, в \f[B]n\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не является целым числом или не помещается в байты \f[B]n\f[R],
вместо этого выводится сообщение об ошибке, но bc(1) не сбрасывается (см.
раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]uint8(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число без знака в байте \f[B]1\f[R].
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не целое число, отрицательное число или не может вписаться в
\f[B]1\f[R] байт, вместо этого выводится сообщение об ошибке, но bc(1) нет.
сброс (см. раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]int8(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число со знаком, дополненное двумя \[cq]s, в байте \f[B]1\f[R].
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не является целым числом или не помещается в байт \f[B]1\f[R], то
Вместо этого выводится сообщение об ошибке, но bc(1) не сбрасывается (см.
раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]uint16(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число без знака в \f[B]2\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не целое число, отрицательное число или не может вписаться в
\f[B]2\f[R] байт, вместо этого выводится сообщение об ошибке, но bc(1) нет.
сброс (см. раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]int16(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число со знаком, дополненное двумя \[cq]s, в \f[B]2\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не является целым числом или не может уместиться в \f[B]2\f[R] байтах,
вместо этого выводится сообщение об ошибке, но bc(1) не сбрасывается (см.
раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]uint32(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число без знака в \f[B]4\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не целое число, отрицательное число или не может вписаться в
\f[B]4\f[R] байт, вместо этого выводится сообщение об ошибке, но bc(1) нет.
сброс (см. раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]int32(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число со знаком, дополненное двумя \[cq]s, в \f[B]4\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не является целым числом или не может уместиться в \f[B]4\f[R] байтах,
вместо этого выводится сообщение об ошибке, но bc(1) не сбрасывается (см.
раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]uint64(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число без знака в \f[B]8\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не целое число, отрицательное число или не может вписаться в
\f[B]8\f[R] байт, вместо этого выводится сообщение об ошибке, но bc(1) нет.
сброс (см. раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]int64(x)\f[R]
Выводит представление \f[B]x\f[R] в двоичном и шестнадцатеричном виде как
целое число со знаком, дополненное двумя \[cq]s, в \f[B]8\f[R] байтах.
Оба вывода разбиты на байты, разделенные пробелами.
.RS
.PP
Если \f[B]x\f[R] не является целым числом или не может уместиться в \f[B]8\f[R] байт,
вместо этого выводится сообщение об ошибке, но bc(1) не сбрасывается (см.
раздел \f[B]RESET\f[R]).
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]hex_uint(x, n)\f[R]
Выводит представление усеченного абсолютного значения
\f[B]x\f[R] как целое число без знака в шестнадцатеричном формате, используя \f[B]n\f[R]
байты.
Не все значение будет выведено, если \f[B]n\f[R] слишком мало.
.RS
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]binary_uint(x, n)\f[R]
Выводит представление усеченного абсолютного значения
\f[B]x\f[R] как целое число без знака в двоичном формате, используя байты \f[B]n\f[R].
Не все значение будет выведено, если \f[B]n\f[R] слишком мало.
.RS
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]output_uint(x, n)\f[R]
Выводит представление усеченного абсолютного значения
\f[B]x\f[R] как целое число без знака в текущей \f[B]obase\f[R] (см.
раздел \f[B]SYNTAX\f[R]), используя байты \f[B]n\f[R].
Не все значение будет выведено, если \f[B]n\f[R] слишком мало.
.RS
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.TP
\f[B]output_byte(x, i)\f[R]
Выводит байт \f[B]i\f[R] усеченного абсолютного значения \f[B]x\f[R],
где \f[B]0\f[R] — младший байт, а \f[B]количество_байтов
- 1\f[R] — самый старший байт.
.RS
.PP
Это функция \f[B]void\f[R] (см. \f[I]Void Functions\f[R]
подраздел раздела \f[B]FUNCTIONS\f[R]).
.RE
.SS Transcendental Functions
.PP
 Все трансцендентные функции могут возвращать слегка неточные результаты.
до 1 УЛП(https://en.wikipedia.org/wiki/Unit_in_the_last_place).
Это неизбежно, и статья на
https://people.eecs.berkeley.edu/\[ti]wkahan/LOG10HAF.TXT объясняет, почему
невозможно и ненужно рассчитывать точные результаты для
трансцендентные функции
.PP
Из-за возможной неточности рекомендую пользователям звонить в тех.
функции с точностью (\f[B]scale\f[R]), установленной как минимум на 1 выше
чем необходимо.
Если точные результаты \f[I]абсолютно\f[R] необходимы, пользователи могут удвоить
точность (\f[B]масштаб\f[R]), а затем усечь.
.PP
The transcendental functions in the standard math library are:
.IP \[bu] 2
\f[B]s(x)\f[R]
.IP \[bu] 2
\f[B]c(x)\f[R]
.IP \[bu] 2
\f[B]a(x)\f[R]
.IP \[bu] 2
\f[B]l(x)\f[R]
.IP \[bu] 2
\f[B]e(x)\f[R]
.IP \[bu] 2
\f[B]j(x, n)\f[R]
.PP
Трансцендентные функции в расширенной математической библиотеке:
.IP \[bu] 2
\f[B]l2(x)\f[R]
.IP \[bu] 2
\f[B]l10(x)\f[R]
.IP \[bu] 2
\f[B]log(x, b)\f[R]
.IP \[bu] 2
\f[B]pi(p)\f[R]
.IP \[bu] 2
\f[B]t(x)\f[R]
.IP \[bu] 2
\f[B]a2(y, x)\f[R]
.IP \[bu] 2
\f[B]sin(x)\f[R]
.IP \[bu] 2
\f[B]cos(x)\f[R]
.IP \[bu] 2
\f[B]tan(x)\f[R]
.IP \[bu] 2
\f[B]atan(x)\f[R]
.IP \[bu] 2
\f[B]atan2(y, x)\f[R]
.IP \[bu] 2
\f[B]r2d(x)\f[R]
.IP \[bu] 2
\f[B]d2r(x)\f[R]
.SH RESET
.PP
Когда bc(1) обнаруживает ошибку или сигнал о том, что он имеет значение, отличное от значения по умолчанию.
обработчик, он сбрасывается.
Это означает, что происходит несколько вещей.
.PP
Во-первых, все выполняемые функции останавливаются и удаляются из памяти.
куча.
Поведение мало чем отличается от исключений в языках программирования.
Затем устанавливается точка выполнения, чтобы любой код, ожидающий выполнения,
(после возвращения всех функций) пропускается.
.PP
Таким образом, когда bc(1) сбрасывается, он пропускает весь оставшийся код, ожидающий выполнения.
казнен.
Тогда, если это интерактивный режим и ошибка не была фатальной
(см. раздел \f[B]EXIT STATUS\f[R]), он запрашивает дополнительные данные;
в противном случае он завершается с соответствующим кодом возврата.
.PP
Обратите внимание, что такое поведение сброса отличается от поведения GNU bc(1), которое
пытается начать выполнение оператора сразу после того, который
вызвало ошибку.
.SH PERFORMANCE
.PP
Большинство реализаций bc(1) используют типы \f[B]char\f[R] для вычисления
значение \f[B]1\f[R] десятичной цифры за раз, но это может быть медленным.
Этот bc(1) делает что-то другое.
.PP
Он использует большие целые числа для вычисления более \f[B]1\f[R] десятичной цифры.
вовремя.
Если он создан в среде, где \f[B]BC_LONG_BIT\f[R] (см.
раздел \f[B]LIMITS\f[R]) равен \f[B]64\f[R], то каждое целое число имеет
\f[B]9\f[R] десятичные цифры.
Если создан в среде, где \f[B]BC_LONG_BIT\f[R] равен \f[B]32\f[R]
тогда каждое целое число имеет \f[B]4\f[R] десятичных цифр.
Эта величина (количество десятичных цифр в большом целом числе) называется
\f[B]BC_BASE_DIGS\f[R].
.PP
Фактические значения \f[B]BC_LONG_BIT\f[R] и \f[B]BC_BASE_DIGS\f[R]
можно запросить с помощью оператора \f[B]limits\f[R].
.PP
Кроме того, этот bc(1) использует еще большее целое число для переполнения.
проверка.
Этот целочисленный тип зависит от значения \f[B]BC_LONG_BIT\f[R], но
всегда как минимум в два раза больше целочисленного типа, используемого для хранения цифр.
.SH ОГРАНИЧЕНИЯ
.PP
Ниже приведены ограничения на bc(1):
.TP
\f[B]BC_LONG_BIT\f[R]
Число битов типа \f[B]long\f[R] в среде, где
bc(1) был построен.
Это определяет, сколько десятичных цифр можно хранить в одном большом
целое число (см. раздел \f[B]PERFORMANCE\f[R]).
.TP
\f[B]BC_BASE_DIGS\f[R]
Количество десятичных цифр в большом целом числе (см.
раздел \f[B]ПРОИЗВОДИТЕЛЬНОСТЬ\f[R]).
Зависит от \f[B]BC_LONG_BIT\f[R].
.TP
\f[B]BC_BASE_POW\f[R]
Максимальное десятичное число, которое может хранить каждое большое целое число (см.
\f[B]BC_BASE_DIGS\f[R]) плюс \f[B]1\f[R].
Зависит от \f[B]BC_BASE_DIGS\f[R].
.TP
\f[B]BC_OVERFLOW_MAX\f[R]
Максимальное число типов переполнения (см. \f[B]PERFORMANCE\f[R]
раздел) может держаться.
Зависит от \f[B]BC_LONG_BIT\f[R].
.TP
\f[B]BC_BASE_MAX\f[R]
Максимальная выходная база.
Устанавливается в \f[B]BC_BASE_POW\f[R].
.TP
\f[B]BC_DIM_MAX\f[R]
Максимальный размер массивов.
Установите значение \f[B]SIZE_MAX-1\f[R].
.TP
\f[B]BC_SCALE_MAX\f[R]
Максимальный масштаб \f[B]\f[R].
Установите значение \f[B]BC_OVERFLOW_MAX-1\f[R].
.TP
\f[B]BC_STRING_MAX\f[R]
Максимальная длина строк.
Установите значение \f[B]BC_OVERFLOW_MAX-1\f[R].
.TP
\f[B]BC_NAME_MAX\f[R]
Максимальная длина идентификаторов.
Установите значение \f[B]BC_OVERFLOW_MAX-1\f[R].
.TP
\f[B]BC_NUM_MAX\f[R]
Максимальная длина числа (в десятичных цифрах), включающая
цифры после запятой.
Устанавливается в \f[B]BC_OVERFLOW_MAX-1\f[R].
.TP
\f[B]BC_RAND_MAX\f[R]
Максимальное целое число (включительно), возвращаемое функцией \f[B]rand()\f[R]
операнд.
Установите значение \f[B]2\[ha]BC_LONG_BIT-1\f[R].
.TP
Экспонента
Максимально допустимый показатель степени (положительный или отрицательный).
Установите значение \f[B]BC_OVERFLOW_MAX\f[R].
.TP
Количество варов
Максимальное количество переменных/массивов.
Установите значение \f[B]SIZE_MAX-1\f[R].
.PP
Фактические значения можно запросить с помощью оператора \f[B]limits\f[R].
.PP
Предполагается, что этих ограничений фактически не существует; пределы такие
большой (по крайней мере, на 64-битных машинах), что не должно быть никакого смысла
при котором они становятся проблемой.
Фактически, память должна быть исчерпана, прежде чем эти пределы будут достигнуты.
.SH ENVIRONMENT VARIABLES
.PP
Поскольку \f[B]непереносимые расширения\f[R], bc(1) распознает следующее
переменные среды:
.TP
\f[B]POSIXLY_CORRECT\f[R]
Если эта переменная существует (независимо от ее содержимого), bc(1) ведет себя так, как будто
была предоставлена опция \f[B]-s\f[R].
.TP
\f[B]BC_ENV_ARGS\f[R]
Это еще один способ передать аргументы командной строки для bc(1).
Они должны быть в том же формате, что и все остальные аргументы командной строки.
Они всегда обрабатываются в первую очередь, поэтому любые файлы, указанные в
\f[B]BC_ENV_ARGS\f[R] будет обработан перед передачей аргументов и файлов.
в командной строке.
Это дает пользователю возможность настраивать параметры \[lq]standard\[rq] и
файлы, которые будут использоваться при каждом вызове.
Самое полезное, что бы такие файлы содержали, было бы полезно
функции, которые могут понадобиться пользователю при каждом запуске bc(1).
.RS
.PP
Код, который анализирует \f[B]BC_ENV_ARGS\f[R], будет правильно обрабатывать кавычки
аргументы, но он не понимает escape-последовательности.
Например, строка \f[B]\[lq]/home/gavin/some bc file.bc\[rq]\f[R]
будет правильно проанализирован, но строка \f[B]\[lq]/home/gavin/some
\[dq]bc\[dq] file.bc\[rq]\f[R] будет содержать обратную косую черту.
.PP
Анализ цитат будет обрабатывать любые типы кавычек: \f[B]\[cq]\f[R] или
\f[B]\[lq]\f[R].
Таким образом, если у вас есть файл с любым количеством одинарных кавычек в имени,
вы можете использовать двойные кавычки в качестве внешних кавычек, как в \f[B]\[lq]some
`bc' file.bc\[rq]\f[R] и наоборот, если у вас есть файл с двойным
кавычки.
Однако обработка файла с обоими типами кавычек в
\f[B]BC_ENV_ARGS\f[R] не поддерживается из-за сложности
синтаксический анализ, хотя такие файлы по-прежнему поддерживаются в командной строке, где
анализ выполняется оболочкой.
.RE
.TP
\f[B]BC_LINE_LENGTH\f[R]
Если эта переменная среды существует и содержит целое число, которое
больше \f[B]1\f[R] и меньше \f[B]UINT16_MAX\f[R]
(\f[B]2\[ha]16-1\f[R]), bc(1) выведет строки такой длины,
включая обратную косую черту (\f[B]\[rs]\f[R]).
Длина строки по умолчанию — \f[B]70\f[R].
.RS
.PP
Специальное значение \f[B]0\f[R] отключит проверку длины строки и
печатать числа без учета длины строки и без обратной косой черты и
новые строки.
.RE
.TP
\f[B]BC_BANNER\f[R]
Если эта переменная среды существует и содержит целое число, то
ненулевое значение активирует баннер авторских прав, когда bc(1) находится в
интерактивный режим, а ноль деактивирует его.
.RS
.PP
Если bc(1) не находится в интерактивном режиме (см. \f[B]ИНТЕРАКТИВНЫЙ РЕЖИМ\f[R]
раздел), то эта переменная среды не имеет никакого эффекта, поскольку bc(1)
не печатает баннер, если он не в интерактивном режиме.
.PP
Эта переменная среды переопределяет значение по умолчанию, которое можно запросить.
с параметрами \f[B]-h\f[R] или \f[B]--help\f[R].
.RE
.TP
\f[B]BC_SIGINT_RESET\f[R]
Если bc(1) не находится в интерактивном режиме (см. \f[B]ИНТЕРАКТИВНЫЙ РЕЖИМ\f[R]
раздел), то эта переменная среды не имеет никакого эффекта, поскольку bc(1)
завершается по \f[B]SIGINT\f[R], если не в интерактивном режиме.
.RS
.PP
Однако когда bc(1) находится в интерактивном режиме, то если эта среда
переменная существует и содержит целое число, ненулевое значение делает bc(1)
сброс по \f[B]SIGINT\f[R], а не выход, а нуль завершает работу bc(1).
Если эта переменная среды существует и является \f[I]не\f[R] целым числом,
тогда bc(1) завершит работу по \f[B]SIGINT\f[R].
.PP
Эта переменная среды переопределяет значение по умолчанию, которое можно запросить.
с параметрами \f[B]-h\f[R] или \f[B]--help\f[R].
.RE
.TP
\f[B]BC_TTY_MODE\f[R]
Если режим TTY \f[I]не\f[R] доступен (см. \f[B]TTY MODE\f[R]
раздел), то эта переменная среды не имеет никакого эффекта.
.RS
.PP
Однако если доступен режим TTY, то если эта переменная среды
существует и содержит целое число, то ненулевое значение заставляет bc(1) использовать
режим TTY, а ноль означает, что bc(1) не использует режим TTY.
.PP
Эта переменная среды переопределяет значение по умолчанию, которое можно запросить.
с параметрами \f[B]-h\f[R] или \f[B]--help\f[R].
.RE
.TP
\f[B]BC_PROMPT\f[R]
Если режим TTY \f[I]не\f[R] доступен (см. \f[B]TTY MODE\f[R]
раздел), то эта переменная среды не имеет никакого эффекта.
.RS
.PP
Однако если доступен режим TTY, то если эта переменная среды
существует и содержит целое число, ненулевое значение заставляет bc(1) использовать
приглашение, а ноль или нецелое число запрещает bc(1) использовать приглашение.
Если эта переменная среды не существует и \f[B]BC_TTY_MODE\f[R]
да, то значение переменной среды \f[B]BC_TTY_MODE\f[R]
используется.
.PP
Эта переменная среды и среда \f[B]BC_TTY_MODE\f[R]
переменная переопределяет значение по умолчанию, которое можно запросить с помощью
Опции \f[B]-h\f[R] или \f[B]--help\f[R].
.RE
.TP
\f[B]BC_EXPR_EXIT\f[R]
Если какие-либо выражения или файлы выражений указаны в командной строке
с \f[B]-e\f[R], \f[B]--expression\f[R], \f[B]-f\f[R] или
\f[B]--file\f[R], то если эта переменная среды существует и содержит
целое число, ненулевое значение приводит к завершению работы bc(1) после выполнения
выражения и файлы выражений, а нулевое значение не позволяет завершить работу bc(1).
.RS
.PP
Эта переменная среды переопределяет значение по умолчанию, которое можно запросить.
с параметрами \f[B]-h\f[R] или \f[B]--help\f[R].
.RE
.TP
\f[B]BC_DIGIT_CLAMP\f[R]
При анализе чисел и если эта переменная среды существует и
содержит целое число, ненулевое значение делает bc(1) фиксирующими цифрами, которые
больше или равно текущему \f[B]ibase\f[R], так что все такие
цифры считаются равными \f[B]ibase\f[R] минус 1, а нулевой
значение отключает такое ограничение, так что эти цифры всегда равны
их значение, которое умножается на мощность \f[B]ibase\f[R].
.RS
.PP
Это никогда не относится к однозначным числам, согласно стандарту (см.
раздел \f[B]СТАНДАРТЫ\f[R]).
.PP
Эта переменная среды переопределяет значение по умолчанию, которое можно запросить.
с параметрами \f[B]-h\f[R] или \f[B]--help\f[R].
.RE
.SH ВЫХОД СТАТУС
.PP 
bc(1) возвращает следующие статусы выхода:
.TP
\f[B]0\f[R]
Нет ошибки.
.TP
\f[B]1\f[R]
Произошла математическая ошибка.
Это соответствует стандартной практике использования \f[B]1\f[R] для ожидаемых ошибок:
поскольку математические ошибки будут происходить в процессе нормального выполнени
.RS
.PP
Математические ошибки включают деление на \f[B]0\f[R], извлечение квадратного корня из числа.
отрицательное число, используя отрицательное число в качестве границы для
генератор псевдослучайных чисел, пытающийся преобразовать отрицательное число
в аппаратное целое число, переполнение при преобразовании числа в аппаратное значение
целое число, переполнение при вычислении размера числа и попытке
использовать нецелое число там, где требуется целое число.
.PP
Преобразование в аппаратное целое число происходит для второго операнда
мощность (\f[B]\[ha]\f[R]), места (\f[B]\[at]\f[R]), сдвиг влево
(\f[B]<<\f[R]) и операторы сдвига вправо (\f[B]>>\f[R]) и их
соответствующие операторы присваивания.
.RE
.TP
\f[B]2\f[R]
Произошла ошибка синтаксического анализа.
.RS
.PP
К ошибкам синтаксического анализа относятся неожиданные \f[B]EOF\f[R] с использованием недопустимого значения.
символ, которому не удалось найти конец строки или комментария, используя токен
где оно неверно, дает недопустимое выражение, дает недопустимое выражение
оператор печати, дающий неверное определение функции, пытающийся
присвоить выражению, которое не является именованным выражением (см.
\f[I]Именованные выражения\f[R] подраздел раздела \f[B]СИНТАКСИС\f[R]),
выдает неверный список \f[B]auto\f[R] с дубликатом
\f[B]auto\f[R]/параметр функции, не удается найти конец кода
блок, пытающийся вернуть значение из функции \f[B]void\f[R],
попытка использовать переменную в качестве ссылки и использовать любые расширения
когда была указана опция \f[B]-s\f[R] или любые ее эквиваленты.
.RE
.TP
\f[B]3\f[R]
Произошла ошибка времени выполнения.
.RS
.PP
К ошибкам времени выполнения относится присвоение недопустимого номера любому глобальному
(\f[B]ibase\f[R], \f[B]obase\f[R] или \f[B]scale\f[R]), что дает плохую оценку
выражение для вызова \f[B]read()\f[R] с вызовом \f[B]read()\f[R] внутри
вызова \f[B]read()\f[R], ошибки типа, передача неправильного количества
аргументы функций, попытка вызвать неопределенную функцию и
попытка использовать вызов функции \f[B]void\f[R] в качестве значения в
выражение.
.RE
.TP
\f[B]4\f[R]
Произошла фатальная ошибка.
.RS
.PP
К фатальным ошибкам относятся ошибки распределения памяти, ошибки ввода-вывода, невозможность
открывать файлы, пытаясь использовать файлы, не имеющие только ASCII
символы (bc(1) принимает только символы ASCII), пытаясь открыть
каталог как файл и выдает неверные параметры командной строки.
.RE
.PP
Статус выхода \f[B]4\f[R] особенный; при возникновении фатальной ошибки bc(1)
всегда завершает работу и возвращает \f[B]4\f[R], независимо от того, в каком режиме находится bc(1).
.PP
Остальные статусы будут возвращены только в том случае, если bc(1) отсутствует.
интерактивный режим (см. раздел \f[B]ИНТЕРАКТИВНЫЙ РЕЖИМ\f[R]), поскольку
bc(1) сбрасывает свое состояние (см. раздел \f[B]RESET\f[R]) и принимает
больше входных данных, когда одна из этих ошибок возникает в интерактивном режиме.
Это также тот случай, когда интерактивный режим принудительно устанавливается
Флаг \f[B]-i\f[R] или опция \f[B]--interactive\f[R].
.PP
Эти статусы завершения позволяют использовать bc(1) в сценариях оболочки с ошибкой.
проверки, и его нормальное поведение можно принудительно настроить с помощью
Флаг \f[B]-i\f[R] или опция \f[B]--interactive\f[R].
.SH ИНТЕРАКТИВНЫЙ РЕЖИМ
.PP
Согласно стандарту (см. раздел \f[B]STANDARDS\f[R]), bc(1) имеет
интерактивный режим и неинтерактивный режим.
Интерактивный режим включается автоматически, когда оба \f[B]stdin\f[R]
и \f[B]stdout\f[R] подключены к терминалу, но флаг \f[B]-i\f[R]
и опция \f[B]--interactive\f[R] может включить ее в других ситуациях.
.PP
В интерактивном режиме bc(1) пытается восстановиться после ошибок (см.
раздел \f[B]RESET\f[R]), а при нормальном выполнении сбрасывает
\f[B]stdout\f[R] как только будет выполнено выполнение текущего ввода.
bc(1) также может сбрасываться по \f[B]SIGINT\f[R] вместо выхода, в зависимости от
содержимое или значение по умолчанию для \f[B]BC_SIGINT_RESET\f[R]
переменная среды (см. раздел \f[B]ENVIRONMENT VARIABLES\f[R]).
.SH РЕЖИМ TTY
.PP
Если все \f[B]stdin\f[R], \f[B]stdout\f[R] и \f[B]stderr\f[R]
подключен к TTY, то режим \[lq]TTY\[rq] считается
доступен, и, таким образом, bc(1) может включить режим TTY, при условии соблюдения некоторых
настройки.
.PP
Если в файле есть переменная среды \f[B]BC_TTY_MODE\f[R]
среде (см. раздел \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]), то если
эта переменная среды содержит ненулевое целое число, bc(1) превратится
в режиме TTY, когда \f[B]stdin\f[R], \f[B]stdout\f[R] и \f[B]stderr\f[R]
все подключены к TTY.
Если переменная среды \f[B]BC_TTY_MODE\f[R] существует, но
\f[I]not\f[R] ненулевое целое число, тогда bc(1) не включит режим TTY.
.PP
Если переменная среды \f[B]BC_TTY_MODE\f[R] не \f[I]не\f[R]
существуют, используется настройка по умолчанию.
Настройки по умолчанию можно запросить с помощью \f[B]-h\f[R] или
\f[B]--help\f[R] опции.
.PP
Режим TTY отличается от интерактивного режима, поскольку интерактивный режим
требуется стандартом bc(1) (см. раздел \f[B]STANDARDS\f[R]),
а интерактивный режим требует только \f[B]stdin\f[R] и \f[B]stdout\f[R]
для подключения к терминалу.
История командной строки .SS
.PP
История командной строки включается только в том случае, если включен режим TTY, т. е.
\f[B]stdin\f[R], \f[B]stdout\f[R] и \f[B]stderr\f[R] подключены к
телетайп и переменную среды \f[B]BC_TTY_MODE\f[R] (см.
раздел \f[B]ENVIRONMENT VARIABLES\f[R]) и по умолчанию не отключать
Режим телетайпа.
Дополнительную информацию смотрите в разделе \f[B]ИСТОРИЯ КОМАНДНОЙ СТРОКИ\f[R].
.SS Prompt
.PP
Если доступен режим телетайпа, можно включить подсказку.
Как и сам режим TTY, его можно включить или выключить с помощью окружения.
переменная: \f[B]BC_PROMPT\f[R] (см. \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]
раздел).
.PP
Если переменная среды \f[B]BC_PROMPT\f[R] существует и не равна нулю
целое число, то подсказка включается, когда \f[B]stdin\f[R],
\f[B]stdout\f[R] и \f[B]stderr\f[R] подключены к TTY и
Опции \f[B]-P\f[R] и \f[B]--no-prompt\f[R] не использовались.
Подсказка о чтении будет включена при тех же условиях, за исключением того, что
параметры \f[B]-R\f[R] и \f[B]--no-read-prompt\f[R] также не должны быть
использовал.
.PP
Однако если \f[B]BC_PROMPT\f[R] не существует, приглашение можно
включено или отключено с помощью переменной среды \f[B]BC_TTY_MODE\f[R],
параметры \f[B]-P\f[R] и \f[B]--no-prompt\f[R] и \f[B]-R\f[R]
и опции \f[B]--no-read-prompt\f[R].
См. разделы \f[B]ENVIRONMENT VARIABLES\f[R] и \f[B]OPTIONS\f[R].
Больше подробностей.
.SH ОБРАБОТКА СИГНАЛА
.PP
Отправка \f[B]SIGINT\f[R] заставит bc(1) выполнить одно из двух действий.
.PP
Если bc(1) не находится в интерактивном режиме (см. \f[B]ИНТЕРАКТИВНЫЙ РЕЖИМ\f[R]
раздел) или переменную среды \f[B]BC_SIGINT_RESET\f[R] (см.
раздел \f[B]ENVIRONMENT VARIABLES\f[R]), или по умолчанию либо нет
целое число или оно равно нулю, bc(1) завершит работу.
.PP
Однако если bc(1) находится в интерактивном режиме и
\f[B]BC_SIGINT_RESET\f[R] или по умолчанию — целое число, отличное от нуля,
тогда bc(1) прекратит выполнение текущего ввода и перезагрузится (см.
раздел \f[B]RESET\f[R]) при получении \f[B]SIGINT\f[R].
.PP
Обратите внимание, что \[lq]текущий вход\[rq] может означать одно из двух.
Если bc(1) обрабатывает ввод из \f[B]stdin\f[R] в интерактивном режиме,
он запросит дополнительные данные.
Если bc(1) обрабатывает ввод из файла в интерактивном режиме, он будет
прекратить обработку файла и начать обработку следующего файла, если таковой имеется
существует, или запросить ввод из \f[B]stdin\f[R], если другого файла не существует.
.PP
Это означает, что если \f[B]SIGINT\f[R] отправляется в bc(1), как есть
при выполнении файла может показаться, что bc(1) не ответил на команду
сигнал, поскольку он немедленно начнет выполнение следующего файла.
Это сделано намеренно; большинство файлов, которые пользователи выполняют при взаимодействии с
bc(1) имеет определения функций, которые быстро анализируются.
Если выполнение файла занимает много времени, возможно, в этом файле есть ошибка.
Остальные файлы по-прежнему могут быть выполнены без проблем, что позволяет
пользователю продолжить.
.PP
\f[B]SIGTERM\f[R] и \f[B]SIGQUIT\f[R] заставляют bc(1) очищать и
выход, и он использует обработчик по умолчанию для всех остальных сигналов.
Единственным исключением является \f[B]SIGHUP\f[R]; в этом случае и только тогда, когда bc(1)
находится в режиме TTY (см. раздел \f[B]TTY MODE\f[R]), \f[B]SIGHUP\f[R]
приведет к тому, что bc(1) очистится и завершится.
.SH ИСТОРИЯ КОМАНДНОЙ СТРОКИ
.PP
bc(1) поддерживает интерактивное редактирование из командной строки.
.PP
Если bc(1) может находиться в режиме TTY (см. раздел \f[B]TTY MODE\f[R]),
историю можно включить.
Это означает, что историю командной строки можно включить только тогда, когда
\f[B]stdin\f[R], \f[B]stdout\f[R] и \f[B]stderr\f[R] — все
подключен к телетайпу.
.PP
Как и сам режим TTY, его можно включить или выключить с помощью окружающей среды.
переменная \f[B]BC_TTY_MODE\f[R] (см. \f[B]ПЕРЕМЕННЫЕ СРЕДЫ\f[R]
раздел).
.PP
Если история включена, предыдущие строки можно вызывать и редактировать с помощью
клавиши со стрелками.
.PP
\f[B]Примечание\f[R]: табуляция преобразуется в 8 пробелов.
.SH МЕСТНЫЙ
.PP
Этот bc(1) поставляется с поддержкой добавления сообщений об ошибках для различных
локали и, таким образом, поддерживает \f[B]LC_MESSAGES\f[R].
.SH СМОТРИТЕ ТАКЖЕ
.PP
dc(1)
.SH СТАНДАРТЫ
.PP
bc(1) соответствует стандарту IEEE Std 1003.1-2017.
(\[lq]POSIX.1-2017\[rq]) спецификация по адресу
https://pubs.opengroup.org/onlinepubs/9699919799/utilities/bc.html.
Флаги \f[B]-efghiqsvVw\f[R], все длинные параметры и расширения
отмеченные выше являются расширениями этой спецификации.
.PP
Кроме того, поведение \f[B]quit\f[R] реализует
интерпретация этой спецификации, отличная от всех известных
реализации.
Дополнительную информацию см. в подразделе \f[B]Statements\f[R] документа
Раздел \f[B]СИНТАКСИС\f[R].
.PP
Обратите внимание, что спецификация явно говорит, что bc(1) принимает только
числа, которые используют точку (\f[B].\f[R]) в качестве точки счисления, независимо от
значение \f[B]LC_NUMERIC\f[R].
.PP
Этот bc(1) поддерживает сообщения об ошибках для разных локалей и, следовательно,
поддерживает \f[B]LC_MESSAGES\f[R].
.SH ОШИБКИ
.PP
До версии \f[B]6.1.0\f[R] этот bc(1) имел неправильное поведение для
оператор \f[B]quit\f[R].
.PP
Других ошибок не известно.
Сообщайте об ошибках на странице https://git.gavinhoward.com/gavin/bc.
.SH АВТОРЫ
.PP
Гэвин Д.
Ховард <gavin@gavinhoward.com> и участники.
