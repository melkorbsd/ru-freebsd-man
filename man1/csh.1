.\"
.\" Copyright (c) 1980, 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\" 
.\" Style notes for the tcsh man page:
.\" 
.\" - Tags in lists are bold, except in the FILES section where they are
.\"   italic.
.\" 
.\" - References are bold for section headings and environment and shell
.\"   variables and italic for commands (externals, builtins, aliases, and
.\"   editor commands) and arguments to commands.
.\" 
.\" - Be careful with the .B and .I macros: they handle only a limited number
.\"   of words. Work around this with \fB and \fI, but only if absolutely
.\"   necessary, because tcsh.man2html uses .B/.I to find name anchors.
.\" 
.\" - Indent in multiples of 4, usually 8.
.\" 
.\" - Use `', not '' or "", except of course in shell syntax examples.
.\"   '' at the beginning of a line will vanish!
.\"
.\" - Use \` for literal back-quote (`).
.\"
.\" - Use \e for literal backslash (\).
.\" 
.\" - Use \-, not -.
.\" 
.\" - Include the tilde when naming dot files. `~/.login', not `.login'.
.\" 
.\" - Refer to external commands in man page format, e.g., `csh(1)'. However,
.\"   tcsh is `tcsh', not `tcsh(1)', because this is the tcsh man page (and
.\"   see the next note anyway).
.\" 
.\" - Say `the shell', not `tcsh', unless distinguishing between tcsh and csh.
.\" 
.\" - Say `shell variable'/`environment variable' instead of `variable'
.\"   and `builtin command'/`editor command' instead of `builtin' or `command'
.\"   unless the distinction is absolutely clear from context.
.\" 
.\" - Use the simple present tense. `The shell uses', not `The shell will use'.
.\" 
.\" - IMPORTANT: Cross-reference as much as possible. Commands, variables,
.\"   etc. in the reference section should be mentioned in the appropriate
.\"   descriptive section, or at least in the reference-section description
.\"   of another command (or whatever) which is mentioned in a description
.\"   section. Remember to note OS-specific things in "OS variant support",
.\"   new features in NEW FEATURES and referenced external commands in SEE
.\"   ALSO.
.\" 
.\" - tcsh.man2html depends heavily on the specific nroff commands used in the
.\"   man page when the script was written. Please stick closely to the style
.\"   used here if you can. In particular, please don't use nroff commands
.\"   which aren't already used herein.
.\" 
.TH TCSH 1 "26 апр 2021" "Astron 6.22.04"
.SH НАЗВАНИЕ
tcsh \- C оболочка с автодополнением имен файлов и
редактированием командной строки
.SH СИНТАКСИС
.B tcsh \fR[\fB\-bcdefFimnqstvVxX\fR] [\fB\-Dname\fR[\fB=value\fR]] [arg ...]
.br
.B tcsh \-l
.SH ОПИСАНИЕ
\fItcsh\fR — это усовершенствованная, но полностью
совместимая версия оболочки
Berkeley UNIX C, \fIcsh\fR(1).
Она является интерпретатором языка команд,
который может использоваться как интерактивная
оболочка при входе в систему, так и процессор
команд для сценариев оболочки.
Она включает редактор командной строки
(см. \fBThe command-line editor\fR),
программируемое автодополнение слов
(см. \fBCompletion and listing\fR),
исправление орфографии
(см. \fBSpelling correction\fR),
механизм истории
(см. \fBHistory substitution\fR),
управление задачами
(см. \fBJobs\fR)и синтаксис, похожий на язык Си.
В разделе \fBNEW FEATURES\fR описаны основные улучшения
\fItcsh\fR по сравнению с \fIcsh\fR(1).
В этом руководстве функции, которые есть в \fItcsh\fR,
но отсутствуют в большинстве реализаций \fIcsh\fR(1)
(в частности, 4.4BSD \fIcsh\fR),помечены как (+)',
а функции, которые есть в \fIcsh\fR(1),
но обычно не документируются, помечены как (u)'.
.SS "Обработка списка аргументов"
Если первый аргумент (аргумент 0) для оболочки — это
\-', то это оболочка для входа в систему.
Оболочка для входа в систему может быть также указана
вызовом оболочки с флагом \fB\-l\fR как единственным
аргументом.
.PP
Остальные аргументы-флаги интерпретируются
следующим образом:
.TP 4
.B \-b
Принудительно вызывает «break» из обработки параметров,
заставляя дальнейшие аргументы оболочки рассматриваться
как аргументы, не являющиеся параметрами.
Оставшиеся аргументы не будут интерпретироваться как
параметры оболочки. Это может использоваться для передачи
параметров в сценарий оболочки без путаницы или возможного
злоупотребления.  Оболочка не будет запускать скрипт
с установленным идентификатором пользователя без этого параметра.
.TP 4
.B \-c
Команды читаются из следующего аргумента
(который должен присутствовать и должен быть единым
аргументом), сохраняются в переменной оболочки
\fBcommand\fR для справки и выполняются.
Любые оставшиеся аргументы помещаются в переменную
оболочки \fBargv\fR.
.TP 4
.B \-d
Оболочка загружает стек каталогов из \fI~/.cshdirs\fR,
как описано в разделе \fBStartup and shutdown\fR,
независимо от того, является ли она оболочкой входа в систему. (+)
.TP 4
.B \-D\fIname\fR[=\fIvalue\fR]
Устанавливает переменную среды \fIname\fR в значение
\fIvalue\fR. (только для Domain/OS) (+)
.TP 4
.B \-e
Оболочка завершает работу, если любая вызванная команда
завершится аномально или возвращает ненулевой статус выхода.
.TP 4
.B \-f
Оболочка не загружает никаких файлов ресурсов или файлов
запуска, и не выполняет хеширование команд, тем самым
начинается быстрее.
.TP 4
.B \-F
Оболочка использует \fIfork\fR(2) вместо \fIvfork\fR(2)
для запуска процессов. (+)
.TP 4
.B \-i
Оболочка интерактивная и запрашивает верхний уровень
ввода, даже если вывод не является терминалом.
Оболочки интерактивные без этого параметра, если
их вводы и выводы являются терминалами.
.TP 4
.B \-l
Оболочка является оболочкой входа в систему.
Применимо только если \fB\-l\fR является
единственным указанным флагом.
.TP 4
.B \-m
Оболочка загружает \fI~/.tcshrc\fR, даже если
она не принадлежит текущему пользователю.
Более новые версии \fIsu\fR(1) могут передавать
\fB\-m\fR в оболочку. (+)
.TP 4
.B \-n
Оболочка анализирует команды, но не выполняет их.
Это помогает при отладке сценариев оболочки.
.TP 4
.B \-q
Оболочка принимает сигнал SIGQUIT
(см. \fBSignal handling\fR) и корректно реагирует,
когда используется с отладчиком. Управление задачами
отключено. (u)
.TP 4
.B \-s
Командный ввод осуществляется со стандартного ввода.
.TP 4
.B \-t
Оболочка читает и выполняет одну строку ввода.
Символ \e' может быть использован для экранирования
символа новой строки в конце этой строки и продолжения
на другой строке.
.TP 4
.B \-v
Устанавливает переменную оболочки \fBverbose\fR,
так что ввод команд отображается после
подстановки истории.
.TP 4
.B \-x
Устанавливает переменную оболочки \fBecho\fR,
так что команды отображаются непосредственно
перед выполнением.
.TP 4
.B \-V
Устанавливает переменную оболочки \fBverbose\fR
еще до выполнения \fI~/.tcshrc\fR.
.TP 4
.B \-X
То же, что \fB\-x\fR, но как \fB\-V\fR для \fB\-v\fR.
.TP 4
.B \-\-help
Выводит справочное сообщение на стандартный вывод
и завершает работу. (+)
.TP 4
.B \-\-version
Выводит версию/платформу/параметры компиляции на
стандартный вывод и завершает работу.
Эта информация также содержится в переменной
оболочки \fBversion\fR. (+)
.PP
После обработки аргументов-флагов, если остаются
аргументы, но не были заданы параметры \fB\-c\fR,
\fB\-i\fR, \fB\-s\fR или \fB\-t\fR, то первый
аргумент принимается как имя файла команд или скрипта',
который будет выполнен. Оболочка открывает этот файл
и сохраняет его имя для возможной подстановки $0'.
Поскольку многие системы используют либо стандартную
шестую, либо седьмую версии оболочек, сценарии которых
не совместимы с этой оболочкой, оболочка использует такую
стандартную' оболочку для выполнения скрипта, первый символ
которого не является #', то есть, который не начинается
с комментария.
.PP
Оставшиеся аргументы помещаются в переменную
оболочки \fBargv\fR.
.SS "Запуск и завершение работы"
Оболочка входа в систему начинает выполнение
команд из системных файлов
\fI/etc/csh.cshrc\fR и \fI/etc/csh.login\fR.
Затем она выполняет команды из файлов в
домашнем каталоге пользователя: сначала \fI~/.tcshrc\fR (+)
или, если \fI~/.tcshrc\fR не найден, \fI~/.cshrc\fR,
затем содержимое файла \fI~/.history\fR 
(или значение переменной оболочки \fBhistfile\fR)
загружается в память, после этого выполняется
\fI~/.login\fR, и наконец, \fI~/.cshdirs\fR
(или значение переменной оболочки \fBdirsfile\fR) (+).
Оболочка может читать \fI/etc/csh.login\fR до,
а не после \fI/etc/csh.cshrc\fR, и \fI~/.login\fR до,
а не после \fI~/.tcshrc\fR или \fI~/.cshrc\fR
и \fI~/.history\fR, если это предусмотрено при компиляции;
см. переменную оболочки \fBversion\fR. (+)
.PP
Оболочки, не являющиеся оболочками входа в систему,
читают только \fI/etc/csh.cshrc\fR \
и \fI~/.tcshrc\fR или \fI~/.cshrc\fR при запуске.
.PP
Примеры файлов запуска можно найти по адресу
\fIhttp://tcshrc.sourceforge.net\fR.
.PP
Команды вроде \fIstty\fR(1) и \fItset\fR(1),
которые необходимо выполнять только один раз при входе
в систему, обычно располагаются в файле \fI~/.login\fR.
Пользователи, которым нужно использовать одинаковые
наборы файлов как с \fIcsh\fR(1), так и с \fItcsh\fR,
могут использовать только \fI~/.cshrc\fR, который
проверяет наличие переменной оболочки \fBtcsh\fR
перед использованием команд, специфичных для \fItcsh\fR,
или могут иметь как \fI~/.cshrc\fR, так и \fI~/.tcshrc\fR,
которые вызывают с помощью команды \fIsource\fR
(см. встроенную команду) файл \fI~/.cshrc\fR.
В остальной части этого руководства используется
обозначение \fI~/.tcshrc\fR' для обозначения файла
\fI~/.tcshrc\fR или, если файл \fI~/.tcshrc\fR не найден,
файла \fI~/.cshrc\fR'.
.PP
В обычном случае оболочка начинает считывать команды
с терминала, выводя приглашение > '.
(Обработка аргументов и использование оболочки для
обработки файлов, содержащих сценарии команд, описаны ниже.)
Оболочка многократно считывает строку командного ввода,
разбивает её на слова, добавляет её в список истории команд,
анализирует её и выполняет каждую команду в строке.
.PP
Человек может выйти из системы, набрав ^D' на пустой строке,
logout' или login' или через механизм автовыхода оболочки
(см. переменную оболочки \fBautologout\fR).
Когда оболочка входа завершает работу, она устанавливает
переменную оболочки \fBlogout\fR в normal' или automatic'
в зависимости от ситуации, затем выполняет команды из файлов
\fI/etc/csh.logout\fR и \fI~/.logout\fR. Оболочка может
сбросить DTR при выходе, если это предусмотрено при компиляции;
см. переменную оболочки \fBversion\fR.
.PP
Имена системных файлов входа и выхода из системы различаются
в зависимости от системы для совместимости с разными вариантами
\fIcsh\fR(1); см. \fBFILES\fR.
.SS Редактирование
Сначала мы опишем \fBThe command-line editor\fR.
Разделы \fBCompletion and listing\fR и \fBSpelling correction\fR описывают два набора функций,
реализованных как команды редактора, но которые
заслуживают отдельного описания. Наконец, раздел
\fBEditor commands\fR перечисляет и описывает
команды редактора, специфичные для оболочки, и их
стандартные привязки.
.SS "Редактор командной строки (+)"
Ввод командной строки можно редактировать,
используя последовательности клавиш, аналогичные тем,
что используются в \fIemacs\fR(1) или \fIvi\fR(1).
Редактор активен только тогда, когда установлена
переменная оболочки \fBedit\fR, что по умолчанию
происходит в интерактивных оболочках.
Встроенная команда \fIbindkey\fR может отображать
и изменять привязки клавиш.
Клавиши, привязанные в стиле \fIemacs\fR(1),
используются по умолчанию (если оболочка не была
скомпилирована иначе; см. переменную оболочки
\fBversion\fR), но \fIbindkey\fR может изменить
привязки клавиш на привязки в стиле \fIvi\fR(1)
целиком.
.PP
Оболочка всегда привязывает клавиши со стрелками
(как определено в переменной окружения \fBTERMCAP\fR)
к следующим командам:
.PP
.PD 0
.RS +4
.TP 8
вниз
\fIdown-history\fR
.TP 8
вверх
\fIup-history\fR
.TP 8
влево
\fIbackward-char\fR
.TP 8
вправо
\fIforward-char\fR
.PD
.RE
.PP
если только это не изменяет другую однобуквенную привязку.
Можно установить пустую строку в последовательности клавиш
со стрелками с помощью команды \fIsettc\fR для предотвращения
этих привязок. ANSI/VT100 последовательности для клавиш
со стрелками всегда привязаны.
.PP
Другие привязки клавиш в основном соответствуют ожиданиям
пользователей \fIemacs\fR(1) и \fIvi\fR(1) и могут быть
легко отображены с помощью \fIbindkey\fR, поэтому нет
необходимости перечислять их здесь. Также \fIbindkey\fR
может вывести список команд редактора с кратким описанием
каждой.
Некоторые привязки клавиш ведут себя по-разному
в зависимости от того, используются ли привязки в стиле
\fIemacs\fR(1) или \fIvi\fR(1);
для получения дополнительной информации см. \fBvimode\fR.
.PP
Заметьте, что команды редактора не используют то же
понятие слова', что и оболочка.
Редактор разделяет слова с помощью любых символов,
не являющихся буквенно-цифровыми и не находящихся
в переменной оболочки \fBwordchars\fR, в то время
как оболочка распознает только пробелы и некоторые
символы, имеющие для неё специальное значение,
перечисленные в разделе \fBLexical structure\fR.
.SS "Автодополнение и список (+)"
Оболочка часто может завершить слово при вводе
уникальной аббревиатуры. Наберите часть слова
(например, ls /usr/lost') и нажмите клавишу Tab,
чтобы выполнить команду редактора \fIcomplete-word\fR.
Оболочка завершит имя файла /usr/lost'
до /usr/lost+found/', заменив неполное слово на полное
в буфере ввода.
(Обратите внимание на завершающий символ /';
автодополнение добавляет /' к концу завершенных
каталогов и пробел к концу других завершенных слов,
чтобы ускорить набор и предоставить визуальный индикатор
успешного завершения.
Переменную оболочки \fBaddsuffix\fR можно сбросить,
чтобы предотвратить это.)
Если совпадений не найдено (возможно, /usr/lost+found'
не существует),
терминальный звонок прозвучит. Если слово уже завершено
(например, на вашей системе может быть /usr/lost',
или вы могли забежать вперед и ввести его полностью),
символ /' или пробел добавляется в конец, если его
там ещё нет.
.PP
Автодополнение работает в любом месте строки,
а не только в конце; завершенный текст сдвигает
остальную часть строки вправо. Автодополнение в середине
слова часто приводит к появлению лишних символов справа
от курсора, которые необходимо удалить.
.PP
Команды и переменные могут быть завершены аналогичным
образом. Например, набор em[tab]' завершит em' до emacs',
если \fIemacs\fR — это единственная команда на вашей системе,
начинающаяся с em'. Автодополнение может найти команду
в любом каталоге в \fBpath\fR или при вводе полного пути.
Набор echo $ar[tab]' завершит $ar' до $argv',
если ни одна другая переменная не начинается с ar'.
.PP
Оболочка анализирует буфер ввода, чтобы определить,
должно ли слово, которое вы хотите завершить, быть
завершено как имя файла, команда или переменная.
Первое слово в буфере и первое слово после
;', |', |&', &&' или ||' считается командой.
Слово, начинающееся с $', считается переменной.
Всё остальное — это имя файла.
Пустая строка завершается' как имя файла.
.PP
Вы можете вывести список возможных завершений слова
в любое время, набрав ^D', чтобы выполнить команду
редактора \fIdelete-char-or-list-or-eof\fR.
Оболочка выводит список возможных завершений
с помощью встроенной команды
\fIls\-F\fR (см. там) 
и повторно выводит приглашение и незавершённую
командную строку, например:
.IP "" 4
> ls /usr/l[^D]
.br
lbin/       lib/        local/      lost+found/
.br
> ls /usr/l
.PP
Если установлена переменная оболочки \fBautolist\fR,
оболочка выводит оставшиеся варианты
(если таковые имеются) при неудаче завершения:
.IP "" 4
> set autolist
.br
> nm /usr/lib/libt[tab]
.br
libtermcap.a@ libtermlib.a@
.br
> nm /usr/lib/libterm
.PP
Если \fBautolist\fR установлена в ambiguous',
варианты выводятся только при неудаче завершения
и не добавляют новых символов к завершённому слову.
.PP
Имя файла, которое нужно завершить, может содержать
переменные, домашние каталоги пользователей,
сокращённые с помощью ~'
(см. \fBFilename substitution\fR) и
элементы стека каталогов, сокращённые с помощью ='
(см. \fBDirectory stack substitution\fR). Например:
.IP "" 4
> ls ~k[^D]
.br
kahn    kas     kellogg
.br
> ls ~ke[tab]
.br
> ls ~kellogg/
.PP
или
.IP "" 4
> set local = /usr/local
.br
> ls $lo[tab]
.br
> ls $local/[^D]
.br
bin/ etc/ lib/ man/ src/
.br
> ls $local/
.PP
Заметьте, что переменные могут быть также явно
развернуты с помощью команды \fIexpand-variables\fR
редактора.
.PP
Команда \fIdelete-char-or-list-or-eof\fR выводит
список только в конце строки; в середине строки
она удаляет символ под курсором, а на пустой
строке завершает сессию или, если установлена
переменная \fBignoreeof\fR, не делает ничего.
M-^D', привязанная к команде редактора
\fIlist-choices\fR, выводит возможные варианты
завершения в любом месте строки, и \fIlist-choices\fR
(или любая другая связанная команда редактора,
которая удаляет или выводит список, а также завершает
сеанс или нет, перечисленные в разделе
\fIdelete-char-or-list-or-eof\fR) может быть
привязана к ^D' с помощью встроенной команды
\fIbindkey\fR, если это необходимо.
.PP
Команды редактора \fIcomplete-word-fwd\fR
и \fIcomplete-word-back\fR
(по умолчанию не привязаны к клавишам)
могут быть использованы для циклического просмотра
списка возможных завершений, заменяя текущее
слово следующим или предыдущим словом в списке.
.PP
Переменную оболочки \fBfignore\fR можно установить
в список суффиксов, которые должны игнорироваться
при автодополнении. Рассмотрим следующий пример:
.IP "" 4
> ls
.br
Makefile        condiments.h~   main.o          side.c
.br
README          main.c          meal            side.o
.br
condiments.h    main.c~
.br
> set fignore = (.o \e~)
.br
> emacs ma[^D]
.br
main.c   main.c~  main.o
.br
> emacs ma[tab]
.br
> emacs main.c
.PP
main.c~' и main.o' игнорируются при автодополнении
(но не при выводе списка), поскольку они оканчиваются
суффиксами, указанными в переменной \fBfignore\fR.
Обратите внимание, что перед ~' требуется \e',
чтобы предотвратить её разворачивание в \fBhome\fR,
как описано в разделе \fBFilename substitution\fR.
\fBfignore\fR игнорируется, если возможен только один
вариант завершения.
.PP
Если переменная оболочки \fBcomplete\fR установлена
в enhance', то автодополнение
1) игнорирует регистр и 2) считает точки,
дефисы и подчёркивания (.', \-' и _') разделителями слов,
при этом дефисы и подчёркивания считаются эквивалентными.
Если в вашем каталоге находятся следующие файлы
.IP "" 4
comp.lang.c      comp.lang.perl   comp.std.c++
.br
comp.lang.c++    comp.std.c
.PP
и вы наберёте mail \-f c.l.c[tab]', то это завершится
как mail \-f comp.lang.c', а ^D выведет comp.lang.c'
и comp.lang.c++'. mail \-f c..c++[^D]' выведет
comp.lang.c++' и comp.std.c++'.
Набор rm a\-\-file[^D]' в следующем каталоге
.IP "" 4
A_silly_file    a-hyphenated-file    another_silly_file
.PP
выведет все три файла, потому что регистр игнорируется,
а дефисы и подчёркивания считаются эквивалентными.
Точки, однако, не эквивалентны дефисам или подчёркиваниям.
.PP
Если переменная оболочки \fBcomplete\fR установлена на
`Enhance', автозавершение игнорирует регистр и различия
между дефисом и подчёркиванием в качестве разделителей
слов только тогда, когда пользователь вводит символы
в нижнем регистре или дефис.
Ввод символов в верхнем регистре или подчёркивания
не будет соответствовать соответствующему символу
в нижнем регистре или дефису.
Ввод команды `rm a\-\-file[^D]' в каталоге из предыдущего
примера всё равно выведет все три файла, но ввод команды
`rm A\-\-file' найдёт только `A_silly_file', а команда
`rm a__file[^D]' найдёт только `A_silly_file'
и `another_silly_file', потому что пользователь явно
использовал символ в верхнем регистре или подчёркивание.
.PP
Автозавершение и вывод списка зависят от нескольких
других переменных оболочки: \fBrecexact\fR можно
установить для завершения на кратчайшее возможное
уникальное совпадение, даже если большее количество
набранных символов может привести к более длинному
совпадению:
.IP "" 4
> ls
.br
fodder   foo      food     foonly
.br
> set recexact
.br
> rm fo[tab]
.PP
просто издаёт звуковой сигнал, так как `fo'
может быть завершено как `fod' или `foo',
но если мы наберём ещё одну `o',
.IP "" 4
> rm foo[tab]
.br
> rm foo
.PP
автозавершение завершает на `foo', хотя `food'
и `foonly' также подходят. \fBautoexpand\fR
можно установить для выполнения команды редактора
\fIexpand-history\fR перед каждой поыткой
автозавершения, \fBautocorrect\fR можно
установить для исправления орфографии слова,
которое должно быть завершено
(см. \fBSpelling correction\fR),
перед каждой попыткой автозавершения, а
\fBcorrect\fR можно установить для
автоматического завершения команд после
нажатия `return'. \fBmatchbeep\fR можно
установить для создания звукового сигнала при
автозавершении в различных ситуациях, а
\fBnobeep\fR можно установить, чтобы никогда
не издавать звуковой сигнал. \fBnostat\fR можно
установить как список каталогов и/или шаблонов,
которые соответствуют каталогам, чтобы
предотвратить выполнение команды \fIstat\fR(2)
в этих каталогах при автозавершении.
\fBlistmax\fR и \fBlistmaxrows\fR можно установить
для ограничения количества элементов и строк
(соответственно), которые выводятся без запроса.
\fBrecognize_only_executables\fR можно установить
для того, чтобы оболочка выводила только
исполняемые файлы при выводе списка команд,
но это заметно замедляет процесс.
.PP
Наконец, встроенную команду \fIcomplete\fR
можно использовать для указания оболочке, как
завершать слова, отличные от имён файлов,
команд и переменных. Автозавершение и вывод
списка не работают с шаблонами
(см. \fBFilename substitution\fR),
но команды редактора \fIlist-glob\fR
и \fIexpand-glob\fR выполняют аналогичные
функции для шаблонов.
.SS "Исправление орфографии (+)"
Оболочка может исправлять орфографию имён файлов,
команд и переменных, а также завершать и выводить их.
.PP
Отдельные слова можно исправить с помощью команды
редактора \fIspell-word\fR (обычно привязанной
к M-s и M-S), а весь буфер ввода с помощью
\fIspell-line\fR (обычно привязана к M-$).
Переменную оболочки \fBcorrect\fR можно установить
в `cmd', чтобы исправлять только имя команды,
или в `all', чтобы исправлять всю строку при
каждом нажатии return, а переменную \fBautocorrect\fR
можно установить для исправления слова
перед каждой попыткой автозавершения.
.PP
Когда исправление орфографии вызывается любым
из этих способов, и оболочка считает, что
какая-либо часть командной строки написана с ошибкой,
она выводит исправленную строку:
.IP "" 4
> set correct = cmd
.br
> lz /usr/bin
.br
CORRECT>ls /usr/bin (y|n|e|a)?
.PP
Можно ответить `y' или пробел для выполнения
исправленной строки, `e' для того, чтобы оставить
некорректную команду в буфере ввода, `a' для отмены
команды так, как если бы была нажата комбинация `^C',
и любой другой символ для выполнения исходной строки
без изменений.
.PP
Исправление орфографии распознаёт пользовательские
завершения (см. встроенную команду \fIcomplete\fR).
Если введённое слово в позиции, для которой
определено завершение, напоминает слово из списка
завершений, исправление орфографии считает это
ошибкой и предлагает последнее слово в качестве
исправления. Однако, если введённое слово не
совпадает ни с одним из возможных завершений
для этой позиции, исправление орфографии
не регистрирует ошибку.
.PP
Как и автозавершение, исправление орфографии
работает в любой части строки, сдвигая остальную
часть строки вправо и, возможно, оставляя лишние
символы справа от курсора.
.SS "Команды редактора (+)"
\fIbindkey\fR выводит список привязок клавиш,
а \fIbindkey \-l\fR выводит и кратко описывает
команды редактора. Здесь описаны только новые
или особенно интересные команды редактора.
См. \fIemacs\fR(1) и \fIvi\fR(1) для описания
привязок клавиш для каждого редактора.
.PP
Символ или символы, к которым по умолчанию
привязана каждая команда, указаны в скобках.
`^\fIсимвол\fR' означает управляющий символ,
а `M-\fIсимвол\fR' — это метасимвол, вводимый
как escape-\fIсимвол\fR на терминалах без
метаклавиши. Регистр имеет значение, но команды,
привязанные к буквам по умолчанию, привязаны как
к строчным, так и к заглавным буквам для удобства.
.TP 8
.B backward-char \fR(^B, влево)
Перемещает курсор на один символ назад.
Поведение курсора изменяется с помощью
\fBvimode\fR.
.TP 8
.B backward-delete-word \fR(M-^H, M-^?)
Вырезает символы от начала текущего слова
до курсора \- сохраняется в буфере вырезок.
Граница слов изменяется с помощью \fBvimode\fR.
.TP 8
.B backward-word \fR(M-b, M-B)
Перемещает курсор к началу текущего слова.
Граница слов и поведение курсора изменяются
с помощью \fBvimode\fR.
.TP 8
.B beginning-of-line \fR(^A, home)
Перемещает курсор в начало строки.
Поведение курсора изменяется
с помощью \fBvimode\fR.
.TP 8
.B capitalize-word \fR(M-c, M-C)
Преобразует в верхний регистр символы от
курсора до конца текущего слова.
Граница слов изменяется с помощью \fBvimode\fR.
.TP 8
.B complete-word \fR(tab)
Завершает слово, как описано в разделе
\fBCompletion and listing\fR.
.TP 8
.B complete-word-back \fR(не привязана)
Как \fIcomplete-word-fwd\fR, но перемещается
вверх с конца списка.
.TP 8
.B complete-word-fwd \fR(не привязана)
Заменяет текущее слово первым словом в
списке возможных завершений. Можно
повторить для перемещения вниз по списку.
В конце списка издаётся звуковой сигнал,
и возвращается неполное слово.
.TP 8
.B complete-word-raw \fR(^X-tab)
Как \fIcomplete-word\fR, но игнорирует
пользовательские завершения.
.TP 8
.B copy-prev-word \fR(M-^_)
Копирует предыдущее слово в текущей строке
в буфер ввода. См. также \fIinsert-last-word\fR.
Граница слов изменяется с помощью \fBvimode\fR.
.TP 8
.B dabbrev-expand \fR(M-/)
Расширяет текущее слово до ближайшего предыдущего
слова, для которого текущее слово является префиксом,
если необходимо, с возможностью вернуться к началу
списка истории (один раз). Повторное использование
команды \fIdabbrev-expand\fR без набора символов
меняет слово на предыдущее найденное и т.д.,
пропуская идентичные совпадения, аналогично тому,
как это делает команда \fIhistory-search-backward\fR.
.TP 8
.B delete-char \fR(не привязана)
Удаляет символ под курсором.
См. также \fIdelete-char-or-list-or-eof\fR.
Поведение курсора изменяется с помощью \fBvimode\fR.
.TP 8
.B delete-char-or-eof \fR(не привязана)
Выполняет \fIdelete-char\fR,
если под курсором есть символ,
или \fIend-of-file\fR на пустой строке.
См. также \fIdelete-char-or-list-or-eof\fR.
Поведение курсора изменяется
с помощью \fBvimode\fR.
.TP 8
.B delete-char-or-list \fR(не привязана)
Выполняет \fIdelete-char\fR, если под
курсором есть символ, или \fIlist-choices\fR
в конце строки.
См. также \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B delete-char-or-list-or-eof \fR(^D)
Выполняет \fIdelete-char\fR, если под
курсором есть символ, \fIlist-choices\fR
в конце строки или \fIend-of-file\fR на
пустой строке. См. также три указанные
команды, каждая из которых выполняет только
одно действие, и \fIdelete-char-or-eof\fR,
\fIdelete-char-or-list\fR и \fIlist-or-eof\fR,
каждая из которых выполняет разные два
из трёх действий.
.TP 8
.B delete-word \fR(M-d, M-D)
Вырезает символы от курсора до конца
текущего слова \- сохраняется
в буфере вырезок. Граница слов изменяется
с помощью \fBvimode\fR.
.TP 8
.B down-history \fR(стрелка вниз, ^N)
Как \fIup-history\fR, но перемещается вниз,
останавливаясь на исходной строке ввода.
.TP 8
.B downcase-word \fR(M-l, M-L)
Преобразует в нижний регистр символы
от курсора до конца текущего слова.
Граница слов изменяется с помощью \fBvimode\fR.
.TP 8
.B end-of-file \fR(не привязана)
Сообщает об окончании файла, заставляя
оболочку завершить работу,
если переменная оболочки \fBignoreeof\fR
(см. там) не установлена, чтобы предотвратить это.
См. также \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B end-of-line \fR(^E, end)
Перемещает курсор в конец строки.
Поведение курсора изменяется
с помощью \fBvimode\fR.
.TP 8
.B expand-history \fR(M-пробел)
Расширяет подстановки из истории в
текущем слове.
См. \fBHistory substitution\fR.
См. также \fImagic-space\fR,
\fItoggle-literal-history\fR и
переменную оболочки \fBautoexpand\fR.
.TP 8
.B expand-glob \fR(^X-*)
Расширяет шаблон к глобальному поиску слева
от курсора. См. \fBFilename substitution\fR.
.TP 8
.B expand-line \fR(не привязана)
Как \fIexpand-history\fR, но
расширяет подстановки из истории в каждом
слове в буфере ввода.
.TP 8
.B expand-variables \fR(^X-$)
Расширяет переменные слева от курсора.
См. \fBVariable substitution\fR.
.TP 8
.B forward-char \fR(^F, вправо)
Перемещает курсор на один символ вперёд.
Поведение курсора изменяется с помощью
\fBvimode\fR.
.TP 8
.B forward-word \fR(M-f, M-F)
Перемещает курсор к концу текущего слова.
Граница слов и поведение курсора изменяются
с помощью \fBvimode\fR.
.TP 8
.B history-search-backward \fR(M-p, M-P)
Осуществляет поиск назад по списку истории
команды, начинающейся с текущего содержимого
буфера ввода до курсора, и копирует её в буфер
ввода. Строка поиска может быть шаблоном с
глобальными символами
(см. \fBFilename substitution\fR),
включающим `*', `?', `[]' или `{}'.
Команды \fIup-history\fR и \fIdown-history\fR
будут работать с соответствующей точкой в
списке истории. Только для режима Emacs.
См. также \fIhistory-search-forward\fR
и \fIi-search-back\fR.
.TP 8
.B history-search-forward \fR(M-n, M-N)
Как \fIhistory-search-backward\fR,
но выполняет поиск вперёд.
.TP 8
.B i-search-back \fR(не привязана)
Осуществляет поиск назад, как
\fIhistory-search-backward\fR,
копирует первое совпадение в буфер ввода с
курсором, расположенным в конце шаблона,
и выводит `bck: ' и первое совпадение.
Можно продолжить вводить символы для
расширения поиска, выполнить команду
\fIi-search-back\fR для продолжения поиска с
тем же шаблоном, возвращаясь к началу списка
истории, если это необходимо
(команда \fIi-search-back\fR должна быть
привязана к одному символу, чтобы это
работало), или можно ввести один из
следующих специальных символов:

.PP
.RS +8
.RS +4
.PD 0
.TP 8
^W
Добавляет остаток слова под курсором к шаблону поиска.
.TP 8
delete (или любой символ, привязанный к \fIbackward-delete-char\fR)
Отменяет эффект последнего введенного символа и удаляет символ
из шаблона поиска, если это возможно.
.TP 8
^G
Если предыдущий поиск был успешным, прерывает весь поиск.
Если нет, возвращается к последнему успешному поиску.
.TP 8
escape
Завершает поиск, оставляя текущую строку во входном буфере.
.RE
.PD
.PP
Любой другой символ, не привязанный к \fIself-insert-command\fR, завершает
поиск, оставляя текущую строку во входном буфере, и
затем интерпретируется как обычный ввод. В частности, возврат каретки
вызывает выполнение текущей строки.
Смотрите также \fIi-search-fwd\fR и \fIhistory-search-backward\fR.
Поведение границ слов изменяется параметром \fBvimode\fR.
.RE
.TP 8
.B i-search-fwd \fR(не привязан)
Как \fIi-search-back\fR, но ищет вперед.
Поведение границ слов изменяется параметром \fBvimode\fR.
.TP 8
.B insert-last-word \fR(M-_)
Вставляет последнее слово предыдущей входной строки (`!$') во входной буфер.
Смотрите также \fIcopy-prev-word\fR.
.TP 8
.B list-choices \fR(M-^D)
Выводит список возможных завершений, как описано в разделе \fBCompletion and listing\fR.
Смотрите также \fIdelete-char-or-list-or-eof\fR и \fIlist-choices-raw\fR.
.TP 8
.B list-choices-raw \fR(^X-^D)
Как \fIlist-choices\fR, но игнорирует пользовательские завершения.
.TP 8
.B list-glob \fR(^X-g, ^X-G)
Выводит список (через встроенную команду \fIls\-F\fR) совпадений с шаблоном glob
(см. \fBFilename substitution\fR) слева от курсора.
.TP 8
.B list-or-eof \fR(не привязан)
Выполняет \fIlist-choices\fR
или \fIend-of-file\fR на пустой строке.
Смотрите также \fIdelete-char-or-list-or-eof\fR.
.TP 8
.B magic-space \fR(не привязан)
Разворачивает подстановки истории в текущей строке,
как \fIexpand-history\fR, и вставляет пробел.
\fImagic-space\fR разработан для привязки к клавише пробела,
но по умолчанию не привязан.
.TP 8
.B normalize-command \fR(^X-?)
Ищет текущее слово в PATH и, если оно найдено, заменяет его полным
путем к исполняемому файлу. Специальные символы экранируются. Псевдонимы
разворачиваются и экранируются, но команды внутри псевдонимов - нет. Эта команда
полезна с командами, которые принимают команды как аргументы, например, `dbx' и `sh \-x'.
.TP 8
.B normalize-path \fR(^X-n, ^X-N)
Разворачивает текущее слово, как описано в настройке `expand'
переменной оболочки \fBsymlinks\fR.
.TP 8
.B overwrite-mode \fR(не привязан)
Переключается между режимами ввода и перезаписи.
.TP 8
.B run-fg-editor \fR(M-^Z)
Сохраняет текущую входную строку и
ищет остановленную задачу, где часть имени файла первого слова
находится в переменной оболочки \fBeditors\fR.
Если \fBeditors\fR не установлена, то будет использована часть имени файла
переменной окружения \fBEDITOR\fR (если не установлена, то `ed')
и переменной окружения
\fBVISUAL\fR (если не установлена, то `vi').
Если такая задача найдена, она перезапускается, как если бы была
введена команда `fg %\fIjob\fR'.
Это используется для удобного переключения между редактором и
оболочкой. Некоторые привязывают эту команду к `^Z', чтобы
делать это еще проще.
.TP
.B run-help \fR(M-h, M-H)
Ищет документацию по текущей команде, используя то же понятие
'текущей команды', что и процедуры завершения, и выводит ее. Нет возможности
использовать пейджер; \fIrun-help\fR разработан для коротких справочных файлов.
Если определен специальный псевдоним \fBhelpcommand\fR, он запускается с
именем команды как единственным аргументом. В противном случае,
документация должна быть в файле с именем \fIcommand\fR.help, \fIcommand\fR.1,
\fIcommand\fR.6, \fIcommand\fR.8 или \fIcommand\fR, который должен находиться в одном
из каталогов, перечисленных в переменной окружения \fBHPATH\fR.
Если существует более одного справочного файла, выводится только первый.
.TP 8
.B self-insert-command \fR(текстовые символы)
В режиме вставки (по умолчанию) вставляет набранный символ во входную строку после символа под курсором.
В режиме перезаписи заменяет символ под курсором набранным символом.
Режим ввода обычно сохраняется между строками, но
переменная оболочки \fBinputmode\fR может быть установлена в `insert' или `overwrite', чтобы
редактор находился в этом режиме в начале каждой строки.
Смотрите также \fIoverwrite-mode\fR.
.TP 8
.B sequence-lead-in \fR(префикс стрелок, мета-префикс, ^X)
Указывает, что следующие символы являются частью
многоклавишной последовательности. Привязка команды к многоклавишной последовательности создает
две привязки: первый символ к \fIsequence-lead-in\fR и
вся последовательность к команде. Все последовательности, начинающиеся с символа,
привязанного к \fIsequence-lead-in\fR, эффективно привязаны к \fIundefined-key\fR,
если не привязаны к другой команде.
.TP 8
.B spell-line \fR(M-$)
Пытается исправить правописание каждого слова во входном буфере, как
\fIspell-word\fR, но игнорирует слова, первый символ которых один из
`\-', `!', `^' или `%', или которые содержат `\e', `*' или `?', чтобы избежать проблем
с переключателями, подстановками и тому подобным.
Смотрите \fBSpelling correction\fR.
.TP 8
.B spell-word \fR(M-s, M-S)
Пытается исправить правописание текущего слова, как описано
в разделе \fBSpelling correction\fR.
Проверяет каждый компонент слова, который выглядит как путь.
.TP 8
.B toggle-literal-history \fR(M-r, M-R)
Разворачивает или 'сворачивает' подстановки истории во входном буфере.
Смотрите также \fIexpand-history\fR и переменную оболочки \fBautoexpand\fR.
.TP 8
.B undefined-key \fR(любая непривязанная клавиша)
Издает звуковой сигнал.
.TP 8
.B up-history \fR(стрелка вверх, ^P)
Копирует предыдущую запись из списка истории во входной буфер.
Если установлен \fBhistlit\fR, использует буквальную форму записи.
Может повторяться для перемещения вверх по списку истории, останавливаясь вверху.
.TP 8
.B upcase-word \fR(M-u, M-U)
Преобразует в верхний регистр символы от курсора до конца текущего слова.
Поведение границ слов изменяется параметром \fBvimode\fR.
.TP 8
.B vi-beginning-of-next-word \fR(не привязан)
Vi переход к началу следующего слова.
Поведение границ слов и курсора изменяется параметром \fBvimode\fR.
.TP 8
.B vi-eword \fR(не привязан)
Vi перемещение к концу текущего слова.
Поведение границ слов изменяется параметром \fBvimode\fR.
.TP 8
.B vi-search-back \fR(?)
Запрашивает с `?' строку поиска (которая может быть шаблоном glob, как в
\fIhistory-search-backward\fR), ищет ее и копирует в
входной буфер. Звуковой сигнал звучит, если совпадение не найдено.
Нажатие return завершает поиск и оставляет последнее совпадение во входном
буфере.
Нажатие escape завершает поиск и выполняет совпадение.
Только режим \fIvi\fR.
.TP 8
.B vi-search-fwd \fR(/)
Как \fIvi-search-back\fR, но ищет вперед.
.TP 8
.B which-command \fR(M-?)
Выполняет \fIwhich\fR (см. описание встроенной команды) для
первого слова входного буфера.
.TP 8
.B yank-pop \fR(M-y)
При выполнении сразу после \fIyank\fR или другого \fIyank-pop\fR,
заменяет вставленную строку следующей предыдущей строкой из
killring. Это также имеет эффект вращения killring, так что
эта строка будет считаться последней убитой для последующей
команды \fIyank\fR. Повторение \fIyank-pop\fR будет циклически проходить через
killring любое количество раз.
ссс
Оболочка поддерживает список переменных,
каждая из которых имеет в качестве значения
список из нуля или более слов. Значения
переменных оболочки можно вывести и изменить
с помощью команд
\fIset\fR и \fIunset\fR.
Система поддерживает свой собственный список «переменных окружения».
Эти переменные можно вывести и изменить с помощью команд
\fIprintenv\fR, \fIsetenv\fR и \fIunsetenv\fR.
.PP
(+) Переменные могут быть сделаны только для
чтения с помощью команды `set \-r` (см. там).
Переменные только для чтения нельзя изменить
или удалить; попытка сделать это вызовет ошибку.
После того как переменная становится только
для чтения, её нельзя сделать доступной для
записи, поэтому `set \-r` следует использовать
с осторожностью. Переменные окружения нельзя
сделать доступными только для чтения.
.PP
Некоторые переменные задаются или используются
самой оболочкой. Например, переменная \fBargv\fR
является образом списка аргументов оболочки,
и слова значения этой переменной используются
особым образом. Некоторые переменные, используемые
оболочкой, являются флажками; оболочка не учитывает
их значения, а только проверяет, установлены они
или нет. Например, переменная \fBverbose\fR
является флажком, который вызывает эхо вводимых
команд. Командная строка с параметромей \fB\-v\fR
устанавливает эту переменную.
\fBSpecial shell variables\fR перечисляют
все переменные, которые используются оболочкой.
.PP
Некоторые операции обрабатывают переменные
как числовые. Команда `@` позволяет выполнять
числовые вычисления и присваивать результат
переменной. Однако значения переменных всегда
представлены как (ноль или более) строк.
Для целей числовых операций пустая строка
считается нулём, а вторые и последующие слова
значений, состоящих из нескольких слов, игнорируются.
.PP
После того как строка ввода обработана алиасами
и разобрана, но до выполнения каждой команды,
происходит подстановка переменных, обозначаемая
символами `$`.  Это расширение можно предотвратить,
поставив перед `$` символ `\e`, за исключением
случаев внутри `"`, где оно \fIвсегда\fR происходит,
и внутри `''`, где оно \fIникогда\fR не происходит.
Строки, заключённые в `\``, интерпретируются позже
(см. \fBCommand substitution\fR ниже), поэтому
подстановка `$` не происходит там до более позднего
этапа, если вообще происходит. Символ `$` передаётся
без изменений, если за ним следует пробел, табуляция
или конец строки.
.PP
Перенаправления ввода/вывода распознаются до
подстановки переменных и обрабатываются отдельно.
В остальном имя команды и весь список аргументов
расширяются вместе. Таким образом, первое слово
(команда) может быть преобразовано в несколько слов,
первое из которых становится именем команды,
а остальные — аргументами.
.PP
Если подстановка переменной не заключена
в `"` или не используется модификатор `:q`,
результаты подстановки переменной могут в конечном
итоге быть подставлены в команду или имя файла.
Внутри `"` переменная, значение которой состоит из
нескольких слов, расширяется до (части) одного слова,
с разделением слов значениями переменной с помощью
пробелов. Когда к подстановке применяется
модификатор `:q`, переменная расширяется до нескольких
слов, при этом каждое слово разделяется пробелом и
экранируется, чтобы предотвратить последующие
подстановки команд или имён файлов.
.PP
Следующие метапоследовательности предоставляются
для ввода значений переменных в оболочку.
За исключением указанных случаев, обращение к
неустановленной переменной вызывает ошибку.
.PP
.PD 0
$\fIname\fR
.TP 8
${\fIname\fR}
Заменяет слова значения переменной \fIname\fR,
разделённые пробелом. Фигурные скобки защищают
\fIname\fR от последующих символов, которые в
противном случае могли бы стать его частью.
Имена переменных оболочки состоят из букв и
цифр и начинаются с буквы. Символ подчёркивания
считается буквой. Если \fIname\fR не является
переменной оболочки, но установлена в окружении,
то возвращается это значение (однако некоторые
из форм, указанных ниже, в этом случае недоступны).
.PP
$\fIname\fR[\fIselector\fR]
.TP 8
${\fIname\fR[\fIselector\fR]} Подставляет только
выбранные слова из значения переменной \fIname\fR.
\fIselector\fR подвергается подстановке `$` и может
состоять из одного числа или двух чисел, разделённых
символом `\-`. Первое слово значения переменной
имеет номер `1`. Если первое число диапазона опущено,
по умолчанию используется `1`. Если последний элемент
диапазона опущен, по умолчанию используется
`$#\fIname\fR`. \fIselector\fR `*` выбирает все слова.
Не является ошибкой, если диапазон пуст, если второй
аргумент опущен или находится в пределах диапазона.
.TP 8
$0
Подставляет имя файла, из которого считывается
ввод команды. Возникает ошибка, если имя неизвестно.
.PP
$\fInumber\fR
.TP 8
${\fInumber\fR}
Эквивалентно `$argv[\fInumber\fR]`.
.TP 8
$*
Эквивалентно `$argv`, что эквивалентно `$argv[*]`.
.PD
.PP
Модификаторы `:`, описанные в разделе
\fBHistory substitution\fR, за исключением `:p`,
могут быть применены к приведённым выше подстановкам.
Можно использовать более одного модификатора. (+)
Фигурные скобки могут понадобиться для защиты подстановки
переменной от буквального двоеточия, так же как и в
\fBHistory substitution\fR (см. там);
любые модификаторы должны быть внутри фигурных скобок.
.PP
Следующие подстановки не могут быть модифицированы
с помощью модификаторов `:`.
.PP
.PD 0
$?\fIname\fR
.TP 8
${?\fIname\fR}
Заменяет строку `1`, если \fIname\fR установлена,
`0`, если нет.
.TP 8
$?0
Заменяет `1`, если текущее имя входного файла известно,
`0`, если нет. Всегда `0` в интерактивных оболочках.
.PP
$#\fIname\fR
.TP 8
${#\fIname\fR}
Заменяет количество слов в переменной \fIname\fR.
.TP 8
$#
Эквивалентно `$#argv`. (+)
.PP
$%\fIname\fR
.TP 8
${%\fIname\fR}
Заменяет количество символов в переменной \fIname\fR. (+)
.PP
$%\fInumber\fR
.TP 8
${%\fInumber\fR}
Заменяет количество символов в $argv[\fInumber\fR]. (+)
.TP 8
$?
Эквивалентно `$status`. (+)
.TP 8
$$
Заменяет (десятичный) номер процесса оболочки
(родительского процесса).
.TP 8
$!
Заменяет (десятичный) номер процесса последнего
запущенного в фоновом режиме процесса в этой оболочке. (+)
.TP 8
$_
Заменяет командную строку последней выполненной команды. (+)
.TP 8
$<
Заменяет строку стандартного ввода, без дальнейшей
интерпретации после этого. Может использоваться для
чтения с клавиатуры в скрипте оболочки.
(+) В то время как \fIcsh\fR всегда экранирует $<, 
как если бы это было эквивалентно `$<:q`,
\fItcsh\fR этого не делает. Кроме того, когда
\fItcsh\fR ждёт, пока пользователь введёт строку,
пользователь может прервать последовательность,
в которую должна быть подставлена строка,
но \fIcsh\fR этого не позволяет.
.PD
.PP
Команда редактора \fIexpand-variables\fR,
обычно привязанная к `^X-$`, может использоваться
для интерактивного расширения отдельных переменных.
.SS "Подстановка команд, файлов и стека каталогов"
Оставшиеся подстановки применяются выборочно к
аргументам встроенных команд. Это означает, что
части выражений, которые не оцениваются, не
подвергаются этим расширениям. Для команд,
которые не встроены в оболочку, имя команды
подставляется отдельно от списка аргументов.
Это происходит очень поздно, после выполнения
перенаправления ввода-вывода, и в дочернем
процессе основной оболочки.
.SS "Подстановка команд"
Подстановка команд обозначается командой, заключённой
в ``\`''. Вывод такой команды разбивается на отдельные
слова по пробелам, табуляциям и новым строкам, и
пустые слова отбрасываются. Вывод подвергается
подстановке переменных и команд и заменяет исходную строку.
.PP
Подстановки команд внутри двойных кавычек (`"`)
сохраняют пробелы и табуляции; только новые строки
создают новые слова. Последняя одиночная новая
строка не создаёт новое слово в любом случае.
Таким образом, возможно, чтобы подстановка команды
дала только часть слова, даже если команда выводит
целую строку.
.PP
По умолчанию оболочка, начиная с версии 6.12,
заменяет все символы новой строки и возврата каретки
в команде на пробелы. Если это отключено через
переменную \fBcsubstnonl\fR, новые строки будут
разделять команды как обычно.
.SS "Подстановка имён файлов"
Если слово содержит любой из символов
`*`, `?`, `[' или `{` или начинается с символа `~`,
оно является кандидатом для подстановки имени файла,
также известной как «глоббинг». Это слово затем
рассматривается как шаблон («glob-шаблон»), и
заменяется отсортированным в алфавитном порядке
списком имён файлов, которые соответствуют шаблону.
.PP
При сопоставлении имён файлов символ `.' в начале
имени файла или сразу после `/', а также символ `/`
должны быть сопоставлены явно
(если только не установлены
.B globdot
или
.B globstar
или оба(+)). Символ `*` соответствует любой строке
символов, включая пустую строку. Символ `?`
соответствует любому одиночному символу.
Последовательность `[...]` соответствует любому
из символов, заключённых в скобки.
Внутри `[...]` пара символов, разделённых `\-`,
соответствует любому символу,
находящемуся в лексическом промежутке между ними.
.PP
(+) Некоторые glob-шаблоны могут быть отрицательными:
Последовательность `[^...]` соответствует любому
одиночному символу, \fIне\fR указанному среди
---символов и/или диапазонов символов в скобках.
.PP
Весь glob-шаблон также может быть отрицательным
с помощью `^`:
.IP "" 4
> echo *
.br
bang crash crunch ouch
.br
> echo ^cr*
.br
bang ouch
.PP
Glob-шаблоны, которые не используют `?`, `*`,
или `[]`, или используют `{}`, или `~` (см. ниже),
не могут быть корректно инвертированы.
.PP
Метаобозначение `a{b,c,d}e` является сокращением
для `abe ace ade`. Порядок слева направо сохраняется:
`/usr/source/s1/{oldls,ls}.c` разворачивается в
`/usr/source/s1/oldls.c /usr/source/s1/ls.c`.
Результаты совпадений сортируются отдельно на
низком уровне, чтобы сохранить этот порядок:
`../{memo,*box}` может развернуться в
`../memo ../box ../mbox`. (Обратите внимание,
что `memo` не был отсортирован с результатами
совпадающими с `*box`.) Это не является ошибкой,
если этот шаблон разворачивается в файлы,
которых не существует, но возможна ошибка от
команды, которой передаётся развёрнутый список.
Эта конструкция может быть вложенной.
В особых случаях слова `{`, `}` и `{}` передаются
без изменений.
.PP
Символ `~` в начале имени файла относится к домашним
каталогам. Сам по себе, т.е. `~`, он разворачивается
в домашний каталог вызывающего пользователя, как указано
в значении переменной оболочки \fBhome\fR.
Когда за ним следует имя, состоящее из букв,
цифр и символов `\-`, оболочка ищет пользователя
с таким именем и подставляет его домашний каталог;
таким образом, `~ken` может развернуться в `/usr/ken`,
а `~ken/chmach` — в `/usr/ken/chmach`. Если за символом
`~` следует символ, отличный от буквы или `/`,
или он появляется не в начале слова, он остаётся
без изменений. Таким образом, команда
`setenv MANPATH /usr/man:/usr/local/man:~/lib/man`
не выполняет подстановку домашнего каталога,
как можно было бы ожидать.
.PP
Это является ошибкой, если glob-шаблон, содержащий
`*`, `?`, `[` или `~`, с или без `^`, не соответствует
ни одному файлу. Однако только один шаблон из списка
glob-шаблонов должен соответствовать файлу (например,
команда `rm *.a *.c *.o` завершится ошибкой только
если в текущем каталоге нет файлов, оканчивающихся
на `.a`, `.c` или `.o`), а если установлена переменная
оболочки \fBnonomatch\fR, шаблон (или список шаблонов),
который не находит соответствий, остаётся без изменений
вместо того, чтобы вызвать ошибку.
.PP
Переменную оболочки \fBglobstar\fR можно установить,
чтобы разрешить использование `**` или `***` в качестве
glob-шаблона, который соответствует любой строке символов,
включая `/`, рекурсивно обходя все существующие подкаталоги.
Например,
`ls **.c` выведет все файлы с расширением .c в текущем
дереве каталогов. Если использовать его отдельно,
он будет соответствовать нулю или более подкаталогам
(например, команда `ls /usr/include/**/time.h` выведет
все файлы с именем `time.h` в дереве каталогов /usr/include;
команда `ls /usr/include/**time.h` выведет все файлы
в дереве каталогов /usr/include, оканчивающиеся на `time.h`;
а команда `ls /usr/include/**time**.h` выведет все файлы
с расширением .h, содержащие `time` либо в имени подкаталога,
либо в имени файла).
Чтобы избежать проблем с рекурсией, glob-шаблон `**`
не будет переходить в символическую ссылку, содержащую
каталог. Чтобы это изменить, используйте `***`. (+)
.PP
Переменную оболочки \fBnoglob\fR можно установить
для предотвращения подстановки имён файлов,
а команда редактора \fIexpand-glob\fR,
обычно привязанная к `^X-*`, может использоваться
для интерактивного расширения отдельных подстановок
имён файлов.
.SS "Подстановка стека каталогов (+)"
Стек каталогов — это список каталогов,
пронумерованный с нуля, который используется
встроенными командами \fIpushd\fR, \fIpopd\fR
и \fIdirs\fR (см. там).
Команда \fIdirs\fR может выводить, сохранять в файл,
восстанавливать и очищать стек каталогов в любое время,
а переменные оболочки \fBsavedirs\fR и
\fBdirsfile\fR можно установить для автоматического
сохранения стека каталогов при выходе и его
восстановления при входе.
Переменную оболочки \fBdirstack\fR можно просмотреть,
чтобы увидеть стек каталогов, и установить,
чтобы поместить произвольные каталоги в стек каталогов.
.PP
Символ `=` с последующими одной или более цифрами
разворачивается в запись из стека каталогов.
Особый случай `=\-` разворачивается в последний
каталог в стеке. Например:
.IP "" 4
> dirs \-v
.br
0       /usr/bin
.br
1       /usr/spool/uucp
.br
2       /usr/accts/sys
.br
> echo =1
.br
/usr/spool/uucp
.br
> echo =0/calendar
.br
/usr/bin/calendar
.br
> echo =\-
.br
/usr/accts/sys
.PP
Переменные оболочки \fBnoglob\fR и \fBnonomatch\fR,
а также команда редактора \fIexpand-glob\fR
применяются как к стеку каталогов,
так и к подстановкам имён файлов.
.SS "Другие подстановки (+)"
Существует несколько дополнительных преобразований,
связанных с именами файлов, не связанных напрямую
с вышеперечисленными, но упомянутых здесь для полноты.
\fIЛюбое\fR имя файла может быть расширено до полного
пути, если переменная \fBsymlinks\fR (см. там)
установлена на `expand`.
Кавычки предотвращают это расширение, и команда
редактора \fInormalize-path\fR выполняет его по запросу.
Команда редактора \fInormalize-command\fR расширяет
команды в PATH до полных путей по запросу.
Наконец, команды \fIcd\fR и \fIpushd\fR интерпретируют
символ `\-' как старый рабочий каталог
(эквивалент переменной оболочки\fBowd\fR).
Это не является подстановкой как таковой, а сокращением,
распознаваемым только этими командами.
Тем не менее, его также можно предотвратить
с помощью кавычек.
.SS Команды
Следующие три раздела описывают, как оболочка
выполняет команды и обрабатывает их ввод и вывод.
.SS Простые команды, конвейеры и последовательности
Простая команда — это последовательность слов,
первое из которых указывает команду для выполнения.
Последовательность простых команд, соединённых символами `|',
образует конвейер. Вывод каждой команды в конвейере
подключается ко вводу следующей.
.PP
Простые команды и конвейеры могут быть объединены
в последовательности с помощью `;', и они будут
выполняться последовательно.
Команды и конвейеры также могут быть объединены в
последовательности с помощью `||' или `&&', что указывает,
как и в языке C, что вторая команда должна быть выполнена
только в случае, если первая команда завершилась ошибкой
или успехом соответственно.
.PP
Простая команда, конвейер или последовательность могут быть
заключены в скобки `()`,
чтобы образовать простую команду, которая, в свою очередь,
может быть компонентом конвейера или последовательности.
Команда, конвейер или последовательность могут быть выполнены
без ожидания завершения, если за ними следует символ `&`.
.SS "Встроенное и невстроенное выполнение команд"
Встроенные команды выполняются в пределах оболочки.
Если любой компонент конвейера, кроме последнего,
является встроенной командой, конвейер выполняется
в дочерней оболочке.
.PP
Команды в скобках всегда выполняются в дочерней оболочке.
.IP "" 4
(cd; pwd); pwd
.PP
таким образом выводит \fBhome\fR каталог, оставляя вас
в текущем месте (вывод этого после домашнего каталога),
тогда как
.IP "" 4
cd; pwd
.PP
оставляет вас в \fBhome\fR каталоге. Команды в скобках
чаще всего используются для предотвращения влияния команды
\fIcd\fR на текущую оболочку.
.PP
Когда команда, которую необходимо выполнить, не является
встроенной командой, оболочка пытается выполнить её с помощью
\fIexecve\fR(2).
Каждое слово в переменной \fBpath\fR указывает каталог,
в котором оболочка будет искать команду.
Если оболочка не была запущена с параметромей \fB\-f\fR,
оболочка хэширует имена в этих каталогах во внутреннюю таблицу,
чтобы пытаться выполнить \fIexecve\fR(2) только в том каталоге,
где существует возможность того, что команда находится там.
Это значительно ускоряет нахождение команды, когда в поисковом пути
присутствует большое количество каталогов.
Этот механизм хэширования не используется:
.TP 4
.B 1.
Если хэширование явно отключено с помощью команды \fIunhash\fR.
.TP 4
.B 2.
Если оболочка была запущена с параметромей \fB\-f\fR.
.TP 4
.B 3.
Для каждого компонента пути, который не начинается с `/'.
.TP 4
.B 4.
Если команда содержит символ `/'.
.PP
В этих четырёх случаях оболочка объединяет каждый
компонент пути с именем команды, чтобы сформировать
имя файла, которое затем пытается выполнить.
Если выполнение успешно, поиск останавливается.
.PP
Если файл имеет права на выполнение, но не является исполняемым
для системы (т.е. не является ни исполняемым бинарным файлом,
ни сценарием, который указывает интерпретатор),
тогда предполагается, что это файл, содержащий команды оболочки,
и запускается новая оболочка для его чтения.
Специальный алиас \fIshell\fR может быть установлен
для указания интерпретатора, отличного от самой оболочки.
.PP
На системах, которые не поддерживают соглашение об
интерпретаторе сценариев `#!`, оболочка может быть
скомпилирована для его эмуляции;
см. переменную оболочки \fBversion\fR.
Если так, оболочка проверяет первую строку файла, чтобы
проверить, имеет ли она форму
`#!\fIинтерпретатор\fR \fIаргумент\fR ...'.
Если да, оболочка запускает \fIинтерпретатор\fR с указанными
\fIаргументами\fR и передаёт ему файл через стандартный ввод.
.SS Ввод/вывод
Стандартный ввод и стандартный вывод команды могут быть
перенаправлены с помощью следующего синтаксиса:
.PP
.PD 0
.TP 8
< \fIname
Открыть файл \fIname\fR (который сначала подвергается подстановке
переменных, команд и имён файлов) в качестве стандартного ввода.
.TP 8
<< \fIword
Считать ввод оболочки до строки, которая идентична\fIword\fR.
\fIword\fR не подвергается подстановке переменных, имён файлов
или команд, и каждая строка ввода сравнивается с \fIword\fR
до выполнения каких-либо подстановок в этой строке ввода.
Если в \fIword\fR нет кавычек (`\e', `"', `' или `\`'),
подстановка переменных и команд выполняется для промежуточных
строк, позволяя `\e` экранировать `$`, `\e` и `\`'.
Команды, которые подставляются, сохраняют все пробелы,
табуляции и символы новой строки, за исключением последней
новой строки, которая отбрасывается.
Полученный текст помещается в анонимный временный файл,
который передаётся команде в качестве стандартного ввода.
.PP
> \fIname
.br
>! \fIname
.br
>& \fIname
.TP 8
>&! \fIname
Файл \fIname\fR используется в качестве стандартного вывода.
Если файл не существует, он создаётся; если файл существует,
он обнуляется, и его предыдущие содержимое теряется.
.RS +8
.PD
.PP
Если переменная оболочки \fBnoclobber\fR установлена,
то файл не должен существовать или должен быть символьным
специальным файлом (например, терминал или `/dev/null`),
иначе произойдёт ошибка.
Это помогает предотвратить случайное уничтожение файлов.
В этом случае формы с `!` могут использоваться для
подавления этой проверки.
Если \fBnotempty\fR указана в \fBnoclobber\fR, то `>`
разрешено использовать для пустых файлов;
если установлено \fBask\fR,
перед ошибкой будет предложено подтверждение.
.PP
Формы с `&` направляют диагностический вывод в указанный файл
так же, как стандартный вывод. \fIname\fR
расширяется так же, как и имена файлов ввода с `<`.
.PD 0
.RE
.PP
>> \fIname
.br
>>& \fIname
.br
>>! \fIname
.TP 8
>>&! \fIname
Подобно `>`, но вывод добавляется в конец файла \fIname\fR.
Если переменная оболочки \fBnoclobber\fR установлена, то
ошибка возникает, если файл \fInot\fR не существует,
если не указана одна из форм с `!`.
.PD
.PP
Команда получает окружение, в котором была запущена оболочка,
с учётом изменений, внесённых параметрами ввода-вывода и
наличием команды в конвейере.
Таким образом, в отличие от некоторых предыдущих оболочек,
команды, выполняемые из файла команд оболочки,
по умолчанию не имеют доступа к тексту команд;
они получают исходный стандартный ввод оболочки.
Механизм `<<` должен использоваться для предоставления
данных inline. Это позволяет скриптам оболочки
функционировать как компоненты конвейеров и позволяет
оболочке блокировать чтение своего ввода.
Обратите внимание, что стандартный ввод по умолчанию
для команды, запущенной в фоновом режиме,
\fInot\fR является пустым файлом \fI/dev/null\fR,
а исходным стандартным вводом оболочки.
Если это терминал и если процесс пытается читать
с терминала, процесс будет заблокирован,
и пользователь будет уведомлён (см. \fBJobs\fR).
.PP
Диагностический вывод можно направить через канал
вместе со стандартным выводом.
Просто используйте форму `|&`, а не просто `|`.
.PP
В настоящее время оболочка не может перенаправить
диагностический вывод без перенаправления
стандартного вывода, но часто приемлемым обходным путём
является использование
`(\fIcommand\fR > \fIoutput-file\fR) >& \fIerror-file\fR`.
\fIoutput-file\fR или \fIerror-file\fR могут быть `/dev/tty`,
чтобы отправить вывод на терминал.
.SS Особенности
После описания того, как оболочка принимает,
анализирует и выполняет командные строки,
мы теперь обратимся к ряду её полезных возможностей.
.SS "Управление потоком"
В оболочке содержится несколько команд, которые можно
использовать для регулирования потока управления в
командных файлах (скриптах оболочки) и (в ограниченных,
но полезных ситуациях) для ввода с терминала.
Эти команды работают, заставляя оболочку повторно читать
или пропускать свой ввод, и из-за реализации
некоторые команды имеют ограничения по расположению.
.PP
Операторы \fIforeach\fR, \fIswitch\fR и \fIwhile\fR,
а также форма \fIif-then-else\fR оператора \fIif\fR требуют,
чтобы основные ключевые слова находились в одной простой
команде в строке ввода, как показано ниже.
.PP
Если ввод оболочки не позволяет выполнять операции перемотки,
оболочка буферизует ввод, когда читается цикл, и использует
перемотку в этом внутреннем буфере для выполнения повторного
чтения, подразумеваемого циклом. (Настолько, насколько это
позволяет, обратные операторы \fIgoto\fR будут успешны при
работе с вводом без перемотки.)
.SS Выражения
Операторы \fIif\fR, \fIwhile\fR и \fIexit\fR
используют выражения с общей синтаксической структурой.
Выражения могут включать любые операторы, описанные в
следующих трёх разделах. Обратите внимание, что команда
\fI@\fR (см. там) имеет собственный отдельный синтаксис.
.SS "Логические, арифметические и операторы сравнения"
Эти операторы аналогичны операторам языка C и имеют
такую же приоритетность.
Они включают
.IP "" 4
||  &&  |  ^  &  ==  !=  =~  !~  <=  >=
.br
<  > <<  >>  +  \-  *  /  %  !  ~  (  )
.PP
Здесь приоритетность возрастает справа налево,
причём `==' `!=' `=~' и `!~', `<=`
`>=` `<` и `>`, `<<` и `>>`, `+` и `\−`, `*` `/` и `%`
находятся, по группам, на одном уровне.
Операторы `==` `!=` `=~` и `!~` сравнивают
свои аргументы как строки; все остальные работают
с числами.
Операторы `=~` и `!~` аналогичны `!=` и `==`,
за исключением того, что правая часть является
glob-шаблоном (см. \fBFilename substitution\fR),
с которым сопоставляется левый операнд.
Это снижает необходимость использования оператора
\fIswitch\fR в скриптах оболочки, когда требуется
только сопоставление по шаблону.
.PP
Нулевые или отсутствующие аргументы считаются `0`.
Результат всех выражений — это строки,
которые представляют десятичные числа.
Важно отметить, что ни один из компонентов выражения
не может находиться в одном слове; за исключением случаев,
когда компоненты выражений находятся рядом с компонентами,
которые синтаксически значимы для парсера
(`&` `|` `<` `>` `(` `)`), они должны быть
окружены пробелами.
.SS "Код завершения команды"
Команды могут выполняться в выражениях, и их код завершения
возвращается, если команда заключена в фигурные скобки (`{}`).
Не забудьте, что скобки должны быть отделены от слов команды
пробелами. Команда считается успешной, если она завершилась
с кодом 0, возвращая истину, т.е. `1`; в противном случае она
считается неудачной, возвращая ложь, т.е. `0`.
Если требуется более детальная информация о коде завершения,
команда должна быть выполнена вне выражения, и переменная
оболочки \fBstatus\fR должна быть проверена.
.SS "Операторы проверки файлов"
Некоторые из этих операторов выполняют проверки истинности/ложности
для файлов и связанных объектов.
Они имеют форму \fB\-\fIop file\fR, где \fIop\fR — это один из
.PP
.PD 0
.RS +4
.TP 4
.B r
Доступ на чтение
.TP 4
.B w
Доступ на запись
.TP 4
.B x
Доступ на выполнение
.TP 4
.B X
Исполняемый файл в пути или встроенная команда оболочки,
например, `\-X ls` и `\-X ls\-F` обычно
возвращают истину, но `\-X /bin/ls` — нет (+)
.TP 4
.B e
Существование
.TP 4
.B o
Право собственности
.TP 4
.B z
Нулевой размер
.TP 4
.B s
Ненулевой размер (+)
.TP 4
.B f
Обычный файл
.TP 4
.B d
Каталог
.TP 4
.B l
Символическая ссылка (+) *
.TP 4
.B b
Блочное специальное устройство (+)
.TP 4
.B c
Символьное специальное устройство (+)
.TP 4
.B p
Именованный канал (fifo) (+) *
.TP 4
.B S
Сокет (+) *
.TP 4
.B u
Установлен бит set-user-ID (+)
.TP 4
.B g
Установлен бит set-group-ID (+)
.TP 4
.B k
Установлен бит "липкости" (+)
.TP 4
.B t
\fIfile\fR (который должен быть цифрой)
является открытым файловым дескриптором
для терминального устройства (+)
.TP 4
.B R
Был перемещён (только для Convex) (+)
.TP 4
.B L
Применяет последующие операторы в тесте с несколькими
операторами к символической ссылке,
а не к файлу, на который указывает ссылка (+) *
.RE
.PD
.PP
\fIfile\fR подвергается подстановке команд и имён файлов,
а затем проверяется, имеет ли он указанное отношение к
реальному пользователю.
Если \fIfile\fR не существует или недоступен или,
для операторов, обозначенных `*`,
если указанный тип файла не существует в текущей системе,
то все проверки возвращают ложь, т.е. `0`.
.PP
Эти операторы могут быть объединены для краткости:
`\-\fIxy file\fR` эквивалентно
`\-\fIx file\fR && \-\fIy file\fR`. (+)
Например, `\-fx` истинно (возвращает `1`) для обычных
исполняемых файлов, но не для каталогов.
.PP
\fBL\fR может быть использована в тесте с несколькими
операторами, чтобы применить последующие операторы к
символической ссылке, а не к файлу, на который она указывает.
Например, `\-lLo` истинно для ссылок,
принадлежащих вызывающему пользователю.
\fBLr\fR, \fBLw\fR и \fBLx\fR всегда истинны для ссылок
и ложны для нессылок.
\fBL\fR имеет другое значение, когда является
последним оператором в тесте с несколькими операторами;
см. ниже.
.PP
Возможно, но не полезно и иногда вводит в заблуждение,
сочетать операторы, которые ожидают, что \fIfile\fR
является файлом, с операторами, которые этого не делают
(например, \fBX\fR и \fBt\fR). Следование за \fBL\fR
оператором, не связанным с файлом, может привести
к особенно странным результатам.
.PP
Другие операторы возвращают другую информацию, т.е.
не только `0` или `1`. (+)
Они имеют тот же формат, что и раньше;
\fIop\fR может быть одним из следующих:
.PP
.PD 0
.RS +4
.TP 8
.B A
Время последнего доступа к файлу, как количество
секунд с момента эпохи
.TP 8
.B A:
Как \fBA\fR, но в формате метки времени,
например, `Fri May 14 16:36:10 1993`
.TP 8
.B M
Время последнего изменения файла
.TP 8
.B M:
Как \fBM\fR, но в формате метки времени
.TP 8
.B C
Время последнего изменения inode
.TP 8
.B C:
Как \fBC\fR, но в формате метки времени
.TP 8
.B D
Номер устройства
.TP 8
.B I
Номер inode
.TP 8
.B F
Составной идентификатор \fBf\fRайла,
в форме \fIdevice\fR:\fIinode\fR
.TP 8
.B L
Имя файла, на который указывает символическая ссылка
.TP 8
.B N
Количество (жёстких) ссылок
.TP 8
.B P
Права доступа, в восьмеричном формате, без ведущего нуля
.TP 8
.B P:
Как \fBP\fR, но с ведущим нулём
.TP 8
.B P\fImode
Эквивалентно `\-P \fIfile\fR & \fImode\fR`, например,
`\-P22 \fIfile\fR` возвращает `22`,
если \fIfile\fR доступен для записи группой и другими,
`20` — если только группой, и `0`, если недоступен ни для кого
.TP 8
.B P\fImode\fB:
Как \fBP\fImode\fR, но с ведущим нулём
.TP 8
.B U
Числовой идентификатор пользователя
.TP 8
.B U:
Имя пользователя, или числовой идентификатор,
если имя неизвестно
.TP 8
.B G
Числовой идентификатор группы
.TP 8
.B G:
Имя группы, или числовой идентификатор,
если имя неизвестно
.TP 8
.B Z
Размер в байтах
.RE
.PD
.PP
Только один из этих операторов может появляться в тесте
с несколькими операторами, и он должен быть последним.
Обратите внимание, что \fBL\fR имеет другое значение
в конце теста с несколькими операторами и в других местах.
Поскольку `0` является допустимым возвращаемым значением
для многих из этих операторов, они не возвращают `0`
при неудаче: большинство из них возвращает `\-1`,
а \fBF\fR возвращает `:`.
.PP
Если оболочка скомпилирована с определением POSIX
(см. переменную оболочки \fBversion\fR),
результат проверки файлов основывается на битах разрешений
файла, а не на результате системного вызова \fIaccess\fR(2).
Например, если проверяется файл с \fB\-w\fR, чьи разрешения
обычно позволяют запись, но который находится на файловой системе,
смонтированной только для чтения, проверка пройдёт в
POSIX-совместимой оболочке, но не в неподдерживающей POSIX.
.PP
Операторы проверки файлов также могут быть оценены
с помощью встроенной команды \fIfiletest\fR (см. там) (+).
.SS Задачи
Оболочка связывает \fIзадачу\fR с каждым конвейером.
Она хранит таблицу текущих задач, которая выводится
командой \fIjobs\fR, и назначает им небольшие целые
номера. Когда задача запускается асинхронно с помощью `&`,
оболочка выводит строку, которая выглядит как
.IP "" 4
[1] 1234
.PP
указывая, что задача, запущенная асинхронно,
была задачей номер 1 и имела один (на уровне верхнего уровня)
процесс с идентификатором процесса 1234.
.PP
Если вы выполняете задачу и хотите сделать что-то другое,
вы можете нажать клавишу приостановки (обычно `^Z`),
которая отправляет сигнал STOP текущей задаче.
Оболочка обычно сообщает, что задача была `Приостановлена`
и выводит другой приглашение.
Если переменная оболочки \fBlistjobs\fR установлена,
все задачи будут выведены как команда \fIjobs\fR;
если она установлена на `long`, вывод будет в длинном формате,
как `jobs \-l`.
Затем вы можете управлять состоянием приостановленной задачи.
Вы можете переместить её в «фон» с помощью команды
\fIbg\fR или выполнить несколько других команд и
в конце концов вернуть задачу на «передний план»
с помощью \fIfg\fR.
(См. также команду редактора \fIrun-fg-editor\fR.)
Сигнал `^Z` действует немедленно и похож на прерывание,
поскольку ожидающий вывод и непрочитанный ввод удаляются,
когда он вводится.
Встроенная команда \fIwait\fR заставляет оболочку
ждать завершения всех фоновых задач.
.PP
Клавиша `^]` отправляет отложенный сигнал приостановки,
который не генерирует сигнал STOP до тех пор,
пока программа не попытается вызвать \fIread\fR(2),
на текущую задачу.
Это может быть полезно, если вы подготовили несколько
команд для задачи, которую вы хотите остановить после её чтения.
Клавиша `^Y` выполняет эту функцию в \fIcsh\fR(1);
в \fItcsh\fR `^Y` является командой редактирования. (+)
.PP
Задача, выполняемая в фоновом режиме, останавливается,
если она пытается прочитать с терминала.
Фоновые задачи обычно могут выводить данные, но это можно
отключить, введя команду `stty tostop`.
Если вы установите эту параметр tty, фоновые задачи будут
останавливаться, когда они попытаются вывести данные,
так же как когда они пытаются прочитать ввод.
.PP
Существует несколько способов обращения к задачам в оболочке.
Символ `%` вводит имя задачи. Если вы хотите обратиться к
задаче номер 1, вы можете указать её как `%1`.
Просто указание задачи возвращает её на передний план;
таким образом, `%1` является синонимом для `fg %1`,
возвращающего задачу 1 на передний план. Аналогично,
ввод `%1 &` возобновляет задачу 1 в фоновом режиме,
так же как `bg %1`. Задачу можно также назвать
по однозначному префиксу строки, введённой для её запуска:
`%ex` обычно перезапускает приостановленную задачу \fIex\fR(1),
если существует только одна приостановленная задача,
имя которой начинается с строки `ex`.
Также возможно указать `%?\fIстрока\fR`,
чтобы обозначить задачу, текст которой содержит \fIстрока\fR,
если существует только одна такая задача.
.PP
Оболочка поддерживает понятие текущей и предыдущей задач.
В выводе, касающемся задач, текущая задача отмечается
знаком `+`, а предыдущая задача — знаком `\-`.
Аббревиатуры `%+`, `%` и (по аналогии с синтаксисом
механизма \fIhistory\fR) `%%` все ссылаются на текущую задачу,
а `%\-` ссылается на предыдущую задачу.
.PP
Механизм управления задачами требует, чтобы параметр
\fIstty\fR(1) `new` был установлен в некоторых системах.
Это артефакт от реализации драйвера tty который позволяет
генерировать символы прерывания с клавиатуры для остановки задач.
См. \fIstty\fR(1) и встроенную команду \fIsetty\fR для
подробностей о настройке параметров в новом драйвере tty.
.SS "Сообщения о состоянии"
Оболочка немедленно узнаёт, когда процесс изменяет состояние.
Обычно она сообщает вам всякий раз, когда задача блокируется так,
что дальнейший прогресс невозможен, но только перед
выводом приглашения.
Это делается для того, чтобы не прерывать вашу работу.
Если же вы установите переменную оболочки \fBnotify\fR,
оболочка будет немедленно уведомлять вас об изменениях состояния
фоновых задач. Также существует команда оболочки \fInotify\fR,
которая отмечает один процесс, чтобы его изменения состояния
сообщались немедленно. По умолчанию \fInotify\fR отмечает
текущий процесс; просто введите `notify` после
запуска фоновой задачи, чтобы отметить её.
.PP
Когда вы пытаетесь выйти из оболочки, пока задачи
приостановлены, вас предупредят, что
`Имеются приостановленные задачи`.
Вы можете использовать команду \fIjobs\fR,
чтобы узнать, что это за задачи.
Если вы сделаете это или сразу же попытаетесь
выйти снова, оболочка больше не будет вас предупреждать,
и приостановленные задачи будут завершены.
.SS "Автоматические, периодические и запланированные события (+)"
Существуют различные способы выполнения команд и других действий
автоматически в разные моменты «жизненного цикла» оболочки.
Они кратко описаны здесь и подробно описаны в соответствующих
разделах \fBBuiltin commands\fR,
\fBSpecial shell variables\fR
и \fBSpecial aliases\fR.
.PP
Встроенная команда \fIsched\fR добавляет команды в список
запланированных событий, которые будут выполнены оболочкой
в указанное время.
.PP
\fBSpecial aliases\fR \fIbeepcmd\fR, \fIcwdcmd\fR,
\fIperiodic\fR, \fIprecmd\fR, \fIpostcmd\fR, и \fIjobcmd\fR
могут быть настроены соответственно для выполнения команд,
когда оболочка хочет издать звуковой сигнал,
когда изменяется рабочий каталог, через каждые \fBtperiod\fR
минут, перед каждым приглашением, перед выполнением каждой команды,
после выполнения каждой команды и когда задача запускается
или возвращается в передний план.
.PP
Переменную оболочки \fBautologout\fR можно установить
для автоматического выхода или блокировки оболочки
после указанного количества минут бездействия.
.PP
Переменную оболочки \fBmail\fR можно установить для
периодической проверки новых сообщений.
.PP
Переменную оболочки \fBprintexitvalue\fR можно установить
для вывода кода завершения команд, которые завершились
с кодом, отличным от нуля.
.PP
Переменную оболочки \fBrmstar\fR можно установить
для запроса у пользователя подтверждения
при вводе `rm *`, если это действительно то,
что подразумевалось.
.PP
Переменную оболочки \fBtime\fR можно установить
для выполнения встроенной команды \fItime\fR
после завершения любого процесса, который
занял больше указанного количества секунд ЦП.
.PP
Переменные оболочки \fBwatch\fR и \fBwho\fR можно
установить для уведомления о входе и выходе выбранных
пользователей, а встроенная команда \fIlog\fR выводит
сообщения о таких пользователях в любое время.
.SS "Поддержка системы Native Language System (+)"
Оболочка поддерживает восьмибитные символы
(если скомпилирована с такой поддержкой;
см. переменную оболочки \fBversion\fR)
и, таким образом, поддерживает наборы символов,
требующие этой возможности.
Поддержка NLS различается в зависимости от того,
скомпилирована ли оболочка для использования системы
NLS (снова см. переменную \fBversion\fR).
В обоих случаях 7-битный ASCII является
кодировкой символов по умолчанию
(например, классификация печатных символов)
и сортировка, и изменение переменных окружения
\fBLANG\fR или \fBLC_CTYPE\fR приводит к проверке
возможных изменений в этих аспектах.
.PP
При использовании системной поддержки NLS вызывается
функция \fIsetlocale\fR(3), чтобы определить
соответствующую кодировку/классификацию символов и сортировку
(например, 'en_CA.UTF-8' даст "UTF-8" как кодировку символов).
Эта функция обычно проверяет переменные окружения
\fBLANG\fR и \fBLC_CTYPE\fR; обратитесь к документации
системы для получения дополнительных сведений.
Когда система NLS не используется, оболочка имитирует её,
предполагая, что используется набор символов ISO 8859-1,
всякий раз, когда установлены переменные \fBLANG\fR или
\fBLC_CTYPE\fR, независимо от их значений.
Сортировка при этом для эмулируемой NLS не меняется.
.PP
Кроме того, как для реальной, так и для эмулируемой
системы NLS, все печатные символы в диапазоне
\e200-\e377, т.е. те, которые имеют привязки
M-\fIchar\fR, автоматически перепривязываются к
команде \fIself-insert-command\fR.
Соответствующая привязка для последовательности
escape-\fIchar\fR, если она есть, остаётся без изменений.
Эти символы не перепривязываются, если установлена переменная
окружения \fBNOREBIND\fR. Это может быть полезно для эмулируемой
NLS или примитивной реальной системы NLS,
которая предполагает использование полного ISO 8859-1.
В противном случае все привязки M-\fIchar\fR
в диапазоне \e240-\e377 фактически отменяются.
Разумеется, явная перепривязка соответствующих клавиш
с помощью команды \fIbindkey\fR всё ещё возможна.
.PP
Неизвестные символы (т.е. те, которые не являются ни печатными,
ни управляющими символами) выводятся в формате \ennn.
Если tty не находится в 8-битном режиме,
другие 8-битные символы выводятся путём
преобразования их в ASCII и использования выделенного режима.
Оболочка никогда не изменяет 7/8-битный режим tty и
отслеживает изменения 7/8-битного режима,
инициированные пользователем.
Пользователи NLS (или, для того, кто хочет использовать клавишу
meta) могут нуждаться в явной установке tty в 8-битный режим
через соответствующую команду \fIstty\fR(1) в файле \fI~/.login\fR.
.SS "Поддержка ОС (+)"
Добавлен ряд новых встроенных команд для поддержки особенностей
различных операционных систем. Все они подробно описаны в разделе
\fBBuiltin commands\fR.
.PP
В системах, поддерживающих TCF (aix-ibm370, aix-ps2),
\fIgetspath\fR и \fIsetspath\fR получают и устанавливают
путь выполнения системы, \fIgetxvers\fR и \fIsetxvers\fR
получают и устанавливают префикс экспериментальной версии,
а \fImigrate\fR перемещает процессы между сайтами.
Встроенная команда \fIjobs\fR выводит сайт,
на котором выполняется каждая задача.
.PP
В BS2000 команда \fIbs2cmd\fR выполняет команды базовой
операционной системы BS2000/OSD.
.PP
В Domain/OS команда \fIinlib\fR добавляет общие
библиотеки в текущее окружение,
\fIrootnode\fR изменяет корневой узел,
а \fIver\fR изменяет системный тип.
.PP
В Mach команда \fIsetpath\fR эквивалентна
\fIsetpath\fR(1) в Mach.
.PP
В Masscomp/RTU и Harris CX/UX команда
\fIuniverse\fR задает вселенную.
.PP
В Harris CX/UX команды \fIucb\fR или
\fIatt\fR запускают команды под указанной
вселенной.
.PP
В Convex/OS команда \fIwarp\fR выводит
или устанавливает вселенную.
.PP
Переменные окружения \fBVENDOR\fR, \fBOSTYPE\fR и \fBMACHTYPE\fR
указывают соответственно производителя, операционную систему
и тип машины (класс микропроцессора или модель машины) системы,
на которой работает оболочка.
Эти переменные особенно полезны при совместном использовании
домашнего каталога на нескольких типах машин. Например,
можно настроить
.IP "" 4
set path = (~/bin.$MACHTYPE /usr/ucb /bin /usr/bin .)
.PP
в файле \fI~/.login\fR и разместить исполняемые файлы
для каждой машины в соответствующем каталоге.
.PP
Переменная оболочки \fBversion\fR указывает,
какие параметры были выбраны при компиляции оболочки.
.PP
Обратите внимание также на встроенную команду
\fInewgrp\fR, переменные оболочки \fBafsuser\fR и
\fBecho_style\fR, а также на системозависимые пути
расположения входных файлов оболочки
(см. раздел \fBFILES\fR).
.SS "Обработка сигналов"
Оболочки для входа игнорируют прерывания при
чтении файла \fI~/.logout\fR.
Оболочка игнорирует сигналы завершения,
если она не запущена с параметром \fB\-q\fR.
Оболочки для входа перехватывают сигнал завершения,
но оболочки без входа наследуют поведение завершения
от своих родительских процессов.
Остальные сигналы имеют значения, унаследованные от родителя.
.PP
В сценариях оболочек можно управлять обработкой оболочкой
сигналов прерывания и завершения с помощью команды \fIonintr\fR,
а управлять обработкой сигналов отключения — с помощью
команд \fIhup\fR и \fInohup\fR.
.PP
Оболочка завершает работу при отключении
(см. также переменную оболочки \fBlogout\fR).
По умолчанию дочерние процессы оболочки тоже завершают работу,
но оболочка не отправляет им сигнал отключения при своём завершении.
Команда \fIhup\fR позволяет оболочке отправлять сигнал отключения
дочернему процессу при выходе, а команда \fInohup\fR заставляет
дочерний процесс игнорировать сигналы отключения.
.SS "Управление терминалом (+)"
Оболочка использует три различных набора режимов терминала (``tty''):
`edit` для редактирования, `quote` для экранирования буквальных символов,
и `execute` для выполнения команд.
Оболочка сохраняет некоторые настройки в каждом режиме,
чтобы команды, которые оставляют tty в сбое, не мешали работе оболочки.
Оболочка также отслеживает изменения скорости и задержки в tty.
Список режимов tty, которые остаются неизменными,
можно просмотреть и изменить с помощью встроенной команды \fIsetty\fR.
Обратите внимание, что хотя редактор использует
режим CBREAK (или его эквивалент),
он принимает набранные символы впереди.
.PP
Команды \fIechotc\fR, \fIsettc\fR и \fItelltc\fR
могут быть использованы для управления и отладки
возможностей терминала через командную строку.
.PP
В системах, поддерживающих SIGWINCH или SIGWINDOW,
оболочка автоматически адаптируется к изменению
размеров окна и корректирует  переменные окружения
\fBLINES\fR и \fBCOLUMNS\fR, если они установлены.
Если переменная окружения \fBTERMCAP\fR содержит
поля li# и co#, оболочка корректирует их,
чтобы они отражали новый размер окна.
.SH СПРАВОЧНИК
Следующие разделы этого руководства описывают все доступные
\fBBuiltin commands\fR, \fBSpecial aliases\fR и
\fBSpecial shell variables\fR.
.SS "Встроенные команды"
.TP 8
.B %\fIзадача
Синоним встроенной команды \fIfg\fR.
.TP 8
.B %\fIзадача \fB&
Синоним встроенной команды \fIbg\fR.
.TP 8
.B :
Не выполняет никаких действий и завершает работу успешно.
.PP
.B @
.br
.B @ \fIимя\fB = \fIвыражение
.br
.B @ \fIимя\fR[\fIиндекс\fR]\fB = \fIвыражение
.br
.B @ \fIимя\fB++\fR|\fB--
.PD 0
.TP 8
.B @ \fIимя\fR[\fIиндекс\fR]\fB++\fR|\fB--
Первая форма выводит значения всех переменных оболочки.
.PD
.RS +8
.PP
Вторая форма присваивает значение \fIвыражения\fR
переменной \fIимя\fR.
Третья форма присваивает значение \fIвыражения\fR
компоненту \fIиндекс\fR
переменной \fIимя\fR; переменная \fIимя\fR и её
компонент с индексом \fIиндекс\fR
должны уже существовать.
.PP
\fIвыражение\fR может содержать операторы `*', `+', и т.д.,
как в языке C.
Если \fIвыражение\fR содержит `<', `>', `&' или `|',
то по крайней мере эта часть \fIвыражения\fR должна быть
заключена в скобки `()'.
Обратите внимание, что синтаксис \fIвыражения\fR не имеет
отношения к синтаксису, описанному в разделе \fBExpressions\fR.
.PP
Четвёртая и пятая формы увеличивают (`++') или уменьшают
(`\-\-') значение переменной \fIимя\fR
или её компонента с индексом \fIиндекс\fR.
.PP
Пробел между символом `@' и именем переменной \fIимя\fR обязателен.
Пробелы между \fIимя\fR и знаком `=' и между `=' и
\fIвыражением\fR опциональны. Компоненты
\fIвыражения\fR должны быть разделены пробелами.
.RE
.PD
.TP 8
.B alias \fR[\fIимя \fR[\fIсписок_слов\fR]]
Без аргументов выводит все псевдонимы.
С аргументом \fIимя\fR выводит псевдоним для указанного имени.
С аргументами \fIимя\fR и \fIсписок_слов\fR присваивает
\fIсписок_слов\fR как псевдоним для имени \fIимя\fR.
\fIсписок_слов\fR проходит подстановку команд и имён файлов.
\fIимя\fR не может быть `alias' или `unalias'.
См. также встроенную команду \fIunalias\fR.
.TP 8
.B alloc
Показывает количество динамической памяти, полученной программой,
с разбивкой на использованную и свободную память.
С аргументом показывает количество свободных и использованных блоков
в каждой категории размеров. Категории начинаются с размера 8
и удваиваются на каждом шаге. Вывод этой команды может варьироваться
в зависимости от типа системы, так как системы, отличные от VAX,
могут использовать другой механизм выделения памяти.
.TP 8
.B bg \fR[\fB%\fIзадача\fR ...]
Переводит указанные задачи (или, без аргументов, текущую задачу)
в фоновый режим, продолжая выполнение каждой, если она приостановлена.
\fIзадача\fR может быть числом, строкой, `%', `+' или `\-' как описано
в разделе \fBJobs\fR.
.PP
.B bindkey \fR[\fB\-l\fR|\fB\-d\fR|\fB\-e\fR|\fB\-v\fR|\fB\-u\fR] (+)
.br
\fBbindkey \fR[\fB\-a\fR] [\fB\-b\fR] [\fB\-k\fR] [\fB\-r\fR] [\fB\-\-\fR]
\fIклавиша \fR(+)
.PD 0
.TP 8
\fBbindkey \fR[\fB\-a\fR] [\fB\-b\fR] [\fB\-k\fR] [\fB\-c\fR|\fB\-s\fR]
[\fB\-\-\fR] \fIклавиша команда \fR(+)
.B bindkey \fR[\fB\-a\fR] [\fB\-b\fR] [\fB\-k\fR] [\fB\-c\fR|\fB\-s\fR]
[\fB\-\-\fR] \fIклавиша команда \fR(+)
Без параметров первая форма выводит список всех привязанных клавиш и команд
редактора,  связанных с каждым из них. Вторая форма выводит команду
редактора, связанную с клавишей \fIклавиша\fR. 
Третья форма привязывает команду редактора \fIкоманда\fR
к клавише \fIклавиша\fR.
Параметры включают:
.PD
.PP
.PD 0
.RS +8
.TP 4
.B \-l
Выводит список всех команд редактора и их краткое описание.
.TP 4
.B \-d
Привязывает все клавиши к стандартным привязкам по умолчанию
для редактора, как указано в \fB-e\fR и \fB-v\fR ниже.
.TP 4
.B \-e
Привязывает все клавиши в стиле привязок редактора
\fIemacs\fR(1). Сбрасывает \fBvimode\fR.
.TP 4
.B \-v
Привязывает все клавиши в стиле привязок редактора \fIvi\fR(1).
Включает \fBvimode\fR.
.TP 4
.B \-a
Выводит или изменяет привязки клавиш в альтернативной карте клавиш.
Это карта клавиш, используемая в командном режиме \fBvimode\fR.
.TP 4
.B \-b
\fIклавиша\fR интерпретируется как символ управления,
записанный как ^\fIсимвол\fR (например, `^A') или
C-\fIсимвол\fR (например, `C-A'),
символ мета-клавиши, записанный как M-\fIсимвол\fR
(например, `M-A'), функциональная клавиша,
записанная как F-\fIстрока\fR (например, `F-строка'),
или расширенная префиксная клавиша, записанная как
X-\fIсимвол\fR (например, `X-A').
.TP 4
.B \-k
\fIклавиша\fR интерпретируется как символическое имя
клавиши со стрелкой,  которое может быть одним из следующих:
`down', `up', `left' или `right'.
.TP 4
.B \-r
Удаляет привязку клавиши \fIклавиша\fR.
Будьте осторожны: команда `bindkey \-r' \fInе\fR
привязывает клавишу к команде \fIself-insert-command\fR
(см. ниже), она полностью удаляет привязку клавиши.
.TP 4
.B \-c
\fIкоманда\fR интерпретируется как встроенная или
внешняя команда вместо команды редактора.
.TP 4
.B \-s
\fIкоманда\fR интерпретируется как буквальная строка и
обрабатывается как ввод с терминала, когда нажимается клавиша
\fIклавиша\fR. Привязанные клавиши в \fIкоманде\fR 
интерпретируются заново, и это продолжается до десяти уровней
вложенности интерпретации.
.TP 4
.B \-\-
Прерывает обработку параметров, чтобы следующее слово было
интерпретировано как \fIклавиша\fR,
даже если оно начинается с символа `\-'.
.TP 4
.B \-u \fR(или любой недопустимый пааметр)
Выводит сообщение о неправильном использовании.
.PD
.PP
\fIклавиша\fR может быть одиночным символом или строкой.
Если команда привязана к строке, первый символ строки
привязывается к  \fIsequence-lead-in\fR,
а вся строка привязывается к команде.
.PP
Управляющие символы в \fIkey\fR могут быть буквальными
(их можно ввести, предварив командой редактора
\fIquoted-insert\fR, обычно связанной с `^V')
или записаны в стиле символов с кареткой, например,
`^A'. Символ удаления записывается как `^?'
(каретка-вопросительный знак).
\fIkey\fR и \fIcommand\fR могут содержать экранированные
последовательности (в стиле System V \fIecho\fR(1))
следующим образом:
.RS +4
.TP 8
.PD 0
.B \ea
Звонок
.TP 8
.B \eb
Забой
.TP 8
.B \ee
Escape
.TP 8
.B \ef
Перевод страницы
.TP 8
.B \en
Новая строка
.TP 8
.B \er
Возврат каретки
.TP 8
.B \et
Горизонтальная табуляция
.TP 8
.B \ev
Вертикальная табуляция
.TP 8
.B \e\fInnn
ASCII-символ, соответствующий восьмеричному
числу \fInnn\fR
.PD
.RE
.PP
`\e' устраняет специальное значение следующего символа,
если оно есть, в частности `\e' и `^'.
.RE
.TP 8
.B bs2cmd \fIbs2000-command\fR (+)
Передает \fIbs2000-command\fR интерпретатору команд BS2000
для выполнения. Можно выполнить только неинтерактивные команды,
и нельзя выполнять команды, которые могут перезаписать образ
текущего процесса, такие как /EXECUTE или /CALL-PROCEDURE.
(только для BS2000)
.TP 8
.B break
Прерывает выполнение после \fIend\fR ближайшего окружающего
цикла \fIforeach\fR или \fIwhile\fR. Оставшиеся команды на
текущей строке будут выполнены. Таким образом, возможны
многоуровневые прерывания, если записать их все на одной строке.
.TP 8
.B breaksw
Прерывает выполнение внутри \fIswitch\fR,
продолжая выполнение после \fIendsw\fR.
.TP 8
.B builtins \fR(+)
Выводит список всех встроенных команд.
.TP 8
.B bye \fR(+)
Синоним для встроенной команды \fIlogout\fR.
 только если оболочка была скомпилирована с этой возможностью;
 см. переменную оболочки \fBversion\fR.
.TP 8
.B case \fIlabel\fB:
Метка в операторе \fIswitch\fR, обсуждается ниже.
.TP 8
.B cd \fR[\fB\-p\fR] [\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR]
[\I--\fR] [\fIname\fR]
Если задан каталог \fIname\fR, изменяет рабочий каталог
оболочки на \fIname\fR. Если не задано, изменяет на \fBhome\fR,
если переменная \fBcdtohome\fR не установлена,
в этом случае требуется указать \fIname\fR.
Если \fIname\fR равно `\-' это интерпретируется как предыдущий
рабочий каталог (см. \fBOther substitutions\fR). (+)
Если \fIname\fR не является подкаталогом текущего каталога
(и не начинается с `/', `./' или `../'),
то каждый компонент переменной \fBcdpath\fR проверяется
на наличие подкаталога \fIname\fR. В конце концов,
если всё остальное не сработало, но \fIname\fR является
переменной оболочки, значение которой начинается с `/' или '.',
тогда это будет пробовано как каталог,
и параметр \fB\-p\fR будет подразумеваться.
.RS +8
.PP
С параметромей \fB\-p\fR выводится окончательный стек каталогов,
как в команде \fIdirs\fR. Флаги \fB\-l\fR, \fB\-n\fR и
\fB\-v\fR оказывают на \fIcd\fR такое же влияние,
как и на \fIdirs\fR, и они подразумевают \fB\-p\fR. (+)
Использование \fB\-\-\fR прерывает обработку параметров,
так что следующее слово принимается за каталог \fIname\fR,
даже если оно начинается с `\-'. (+)
.PP
См. также переменные оболочки \fBimplicitcd\fR
и \fBcdtohome\fR.
.RE
.TP 8
.B chdir
Синоним для встроенной команды \fIcd\fR.
.TP 8
.B complete \fR[\fIcommand\fR [\fIword\fB/\fIpattern\fB/\fIlist\fR[\fB:\fIselect\fR]\fB/\fR[[\fIsuffix\fR]\fB/\fR] ...]] (+)
Без аргументов выводит список всех завершений.
С \fIcommand\fR выводит завершения для \fIcommand\fR.
С \fIcommand\fR и \fIword\fR и т.д. определяет завершения.
.RS +8
.PP
\fIcommand\fR может быть полным именем команды или шаблоном
с глобальными символами (см. \fBFilename substitution\fR).
Может начинаться с `\-' для указания, что завершение должно
использоваться только при неоднозначности \fIcommand\fR.
.PP
\fIword\fR указывает, какое слово относительно текущего нужно
завершить, и может быть одним из следующих:
.PP
.PD 0
.RS +4
.TP 4
.B c
Завершение текущего слова. \fIpattern\fR — это шаблон,
который должен соответствовать началу текущего слова в
командной строке. \fIpattern\fR игнорируется при
завершении текущего слова.
.TP 4
.B C
Как \fBc\fR, но включает \fIpattern\fR при завершении текущего слова.
.TP 4
.B n
Завершение следующего слова. \fIpattern\fR — это шаблон, который
должен соответствовать началу предыдущего слова в командной строке.
.TP 4
.B N
Как \fBn\fR, но должен соответствовать началу слова,
находящегося на два слова перед текущим.
.TP 4
.B p
Завершение в зависимости от позиции.
\fIpattern\fR — это числовой диапазон с тем же синтаксисом,
который используется для индексации переменных оболочки и
который должен включать текущее слово.
.PD
.RE
.PP
\fIlist\fR, список возможных завершений,
может быть одним из следующих:
.PP
.PD 0
.RS +4
.TP 8
.B a
Алиасы
.TP 8
.B b
Привязки (команды редактора)
.TP 8
.B c
Команды (встроенные или внешние команды)
.TP 8
.B C
Внешние команды, которые начинаются с
указанного префикса пути
.TP 8
.B d
Каталоги
.TP 8
.B D
Каталоги, которые начинаются с указанного
префикса пути
.TP 8
.B e
Переменные окружения
.TP 8
.B f
Имена файлов
.TP 8
.B F
Имена файлов, которые начинаются с указанного
префикса пути
.TP 8
.B g
Имена групп
.TP 8
.B j
Задачи
.TP 8
.B l
Ограничения
.TP 8
.B n
Ничего
.TP 8
.B s
Переменные оболочки
.TP 8
.B S
Сигналы
.TP 8
.B t
Обычные (``текстовые'') файлы
.TP 8
.B T
Обычные (``текстовые'') файлы,
которые начинаются с указанного префикса пути
.TP 8
.B v
Любые переменные
.TP 8
.B u
Имена пользователей
.TP 8
.B x
Как \fBn\fR, но выводит \fIselect\fR при
использовании \fIlist-choices\fR.
.TP 8
.B X
Завершения
.TP 8
$\fIvar\fR
Слова из переменной \fIvar\fR
.TP 8
(...)
Слова из указанного списка
.TP 8
\`...\`
Слова из вывода команды
.PD
.RE
.PP
\fIselect\fR — это необязательный шаблон глобального поиска.
Если указан, рассматриваются только слова из \fIlist\fR,
которые соответствуют \fIselect\fR, и переменная оболочки
\fBfignore\fR игнорируется.
Последние три типа завершения не могут иметь шаблон \fIselect\fR,
а \fBx\fR использует \fIselect\fR как поясняющее сообщение,
когда используется команда редактора \fIlist-choices\fR.
.PP
\fIsuffix\fR — это одиночный символ, который добавляется
к успешному завершению. Если он пуст, символ не добавляется.
Если не указан (в этом случае четвертый разделитель также
может быть опущен), к каталогам добавляется слэш,
а к остальным словам — пробел.
.PP
\fIcommand\fR, вызванный из версии \`...\`,
имеет дополнительную переменную окружения,
имя переменной — \%\fBCOMMAND_LINE\fR\%,
и она содержит (как и указывает ее имя) содержимое текущей
(уже введенной) командной строки.
Можно проверить и использовать содержимое переменной
\%\fBCOMMAND_LINE\fR\% в пользовательском сценарии
для создания более сложных завершений
(см. завершение для svn(1), включенное в этот пакет).
.PP
Теперь несколько примеров. Некоторые команды принимают
только каталоги в качестве аргументов, поэтому
нет смысла завершать обычные файлы.
.IP "" 4
> complete cd 'p/1/d/'
.PP
завершает только первое слово, следующее за `cd` (`p/1`),
как каталог.
Завершение типа \fBp\fR также может быть использовано
для сужения завершения команд:
.IP "" 4
> co[^D]
.br
complete compress
.br
> complete \-co* 'p/0/(compress)/'
.br
> co[^D]
.br
> compress
.PP
Это завершение завершает команды (слова на позиции 0, `p/0`),
которые начинаются с `co` (тем самым соответствуют `co*`) на
`compress` (единственное слово в списке).
Ведущий `\-' указывает, что это завершение должно использоваться
только для неоднозначных команд.
.IP "" 4
> complete find 'n/\-user/u/'
.PP
Это пример завершения типа \fBn\fR. Любое слово,
следующее за `find` и непосредственно за `\-user`,
завершается из списка пользователей.
.IP "" 4
> complete cc 'c/\-I/d/'
.PP
демонстрирует завершение типа \fBc\fR. Любое слово,
следующее за `cc` и начинающееся с `\-I`, завершается
как каталог. `\-I` не считается частью каталога,
потому что мы использовали строчную букву \fBc\fR.
.PP
Разные \fIlist\fR полезны для разных команд.
.IP "" 4
> complete alias 'p/1/a/'
.br
> complete man 'p/*/c/'
.br
> complete set 'p/1/s/'
.br
> complete true 'p/1/x:Truth has no options./'
.PP
Эти команды завершают слова, следующие за `alias`,
как алиасы, `man` — как команды, а `set` — как переменные оболочки.
У `true` нет параметров, поэтому \fBx\fR ничего не делает при попытке
завершения и выводит сообщение «Правда не имеет параметров»,
когда выводятся возможные варианты завершений.
.PP
Заметьте, что в примере с \fIman\fR, а также в нескольких
других примерах ниже, можно было бы использовать 'c/*'
или 'n/*' вместо 'p/*'.
.PP
Слова могут завершаться из переменной,
оцениваемой во время завершения,
.IP "" 4
> complete ftp 'p/1/$hostnames/'
.br
> set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu)
.br
> ftp [^D]
.br
rtfm.mit.edu tesla.ee.cornell.edu
.br
> ftp [^C]
.br
> set hostnames = (rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net)
.br
> ftp [^D]
.br
rtfm.mit.edu tesla.ee.cornell.edu uunet.uu.net
.PP
или из команды, выполняемой во время завершения:
.IP "" 4
> complete kill 'p/*/\`ps | awk \e{print\e \e$1\e}\`/'
.br
> kill \-9 [^D]
.br
23113 23377 23380 23406 23429 23529 23530 PID
.PP
Обратите внимание, что команда \fIcomplete\fR не экранирует
свои аргументы, поэтому фигурные скобки, пробел и `$` в `{print $1}`
должны быть экранированы явно.
.PP
Одна команда может иметь несколько завершений:
.IP "" 4
> complete dbx 'p/2/(core)/' 'p/*/c/'
.PP
завершает второй аргумент команды `dbx` словом `core`,
а все остальные аргументы — как команды. Обратите внимание,
что позиционное завершение указывается перед завершением
следующего слова.
Поскольку завершения обрабатываются слева направо,
если бы сначала было указано завершение следующего слова,
оно всегда бы срабатывало, и позиционное завершение никогда
не выполнялось бы. Это частая ошибка при определении завершений.
.PP
Шаблон \fIselect\fR полезен, когда команда принимает в качестве
аргументов файлы только определенных форм. Например,
.IP "" 4
> complete cc 'p/*/f:*.[cao]/'
.PP
завершает аргументы команды `cc` как файлы,
оканчивающиеся только на `.c`, `.a` или `.o`.
\fIselect\fR также может исключать файлы,
используя отрицание шаблона глобального поиска,
как описано в разделе \fBFilename substitution\fR.
Можно использовать
.IP "" 4
> complete rm 'p/*/f:^*.{c,h,cc,C,tex,1,man,l,y}/'
.PP
чтобы исключить драгоценный исходный код из завершения команды `rm`.
Конечно, можно все равно вручную ввести исключенные имена или обойти
механизм завершения, используя команды редактора \fIcomplete-word-raw\fR
или \fIlist-choices-raw\fR (см.).
.PP
Списки \fIlist\fR типа `C`, `D`, `F` и `T` аналогичны
спискам `c`, `d`, `f` и `t` соответственно,
но используют аргумент \fIselect\fR по-другому:
чтобы ограничить завершение файлами, начинающимися
с определенного префикса пути. Например, программа почты Elm
использует `=` как сокращение для каталога почты.
Можно использовать
.IP "" 4
> complete elm c@=@F:$HOME/Mail/@
.PP
чтобы завершить `elm \-f =` как если бы это было `elm \-f ~/Mail/`.
Обратите внимание, что мы использовали `@` вместо `/`,
чтобы избежать путаницы с аргументом \fIselect\fR, и использовали
`$HOME` вместо `~`, потому что подстановка домашнего каталога
работает только в начале слова.
.PP
\fIsuffix\fR используется для добавления нестандартного суффикса
(не пробела или `/` для каталогов) к завершенным словам.
.IP "" 4
> complete finger 'c/*@/$hostnames/' 'p/1/u/@'
.PP
завершает аргументы команды `finger` из списка пользователей,
добавляет `@`, а затем завершает после `@` из переменной `hostnames`.
Обратите внимание на порядок указания завершений.
.PP
Наконец, вот сложный пример для вдохновения:
.IP "" 4
> complete find \e
.br
\&'n/\-name/f/' 'n/\-newer/f/' 'n/\-{,n}cpio/f/' \e
.br
\&\'n/\-exec/c/' 'n/\-ok/c/' 'n/\-user/u/' \e
.br
\&'n/\-group/g/' 'n/\-fstype/(nfs 4.2)/' \e
.br
\&'n/\-type/(b c d f l p s)/' \e
.br
\'c/\-/(name newer cpio ncpio exec ok user \e
.br
group fstype type atime ctime depth inum \e
.br
ls mtime nogroup nouser perm print prune \e
.br
size xdev)/' \e
.br
\&'p/*/d/'
.PP
Это завершает слова, следующие за `\-name`, `\-newer`, `\-cpio`
или `ncpio` (обратите внимание на шаблон, который соответствует обоим)
как файлы, слова, следующие за `\-exec` или `\-ok` как команды, слова,
следующие за `user` и `group` как пользователи и группы соответственно,
и слова, следующие за `\-fstype` или `\-type` как члены данных списков.
Оно также завершает сами ключи из данного списка
(обратите внимание на использование завершения типа \fBc\fR)
и завершает все, что не завершилось другим способом, как каталог. Уф.
.PP
Помните, что программируемые завершения игнорируются, если слово,
которое завершается, является подстановкой тильды (начинается с `~`)
или переменной (начинается с `$`). См. также встроенную
команду \fIuncomplete\fR.
.RE
.TP 8
.B continue
Продолжает выполнение ближайшего окружающего цикла
\fIwhile\fR или \fIforeach\fR. Остальные команды на
текущей строке выполняются.
.TP 8
.B default:
Метка по умолчанию в операторе \fIswitch\fR.
Она должна следовать за всеми метками \fIcase\fR.
.PP
.B dirs \fR[\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR]
.br
.B dirs \-S\fR|\fB\-L \fR[\fIfilename\fR] (+)
.PD 0
.TP 8
.B dirs \-c \fR(+)
Первая форма выводит стек каталогов. Верх стека находится слева,
а первый каталог в стеке — это текущий каталог.
С параметромей \fB\-l\fR `~` или `~\fIname\fP` в выводе явно заменяется
на \fBhome\fR или путь к домашнему каталогу пользователя \fIname\fP. (+)
С параметромей \fB\-n\fR, записи переносятся на следующую строку до того,
как они достигнут края экрана. (+)
С параметромей \fB\-v\fR, записи выводятся по одной на строку,
предшествуя их позициями в стеке. (+)
Если указано несколько параметров \fB\-n\fR или \fB\-v\fR,
\fB\-v\fR имеет приоритет.
Параметр \fB\-p\fR принимается, но ничего не делает.
.PD
.RS +8
.PP
С параметромей \fB\-S\fR, вторая форма сохраняет стек каталогов
в файл \fIfilename\fR в виде серии команд \fIcd\fR и \fIpushd\fR.
С параметромей \fB\-L\fR, оболочка загружает файл \fIfilename\fR, который,
предположительно, является файлом стека каталогов, сохраненным
с помощью параметра \fB\-S\fR или механизма \fBsavedirs\fR.
В любом случае используется \fBdirsfile\fR,
если \fIfilename\fR
не указан, и используется \fI~/.cshdirs\fR,
если \fBdirsfile\fR не установлен.
.PP
Обратите внимание, что оболочки при входе делают
эквивалент команды `dirs \-L` при запуске и,
если установлен параметр \fBsavedirs\fR, выполняют `dirs \-S` перед выходом.
Поскольку только \fI~/.tcshrc\fR обычно загружается перед \fI~/.cshdirs\fR,
переменную \fBdirsfile\fR следует устанавливать в \fI~/.tcshrc\fR,
а не в \fI~/.login\fR.
.PP
Последняя форма очищает стек каталогов.
.RE
.TP 8
.B echo \fR[\fB\-n\fR] \fIword\fR ...
Записывает каждое \fIword\fR в стандартный вывод оболочки,
разделяя их пробелами и заканчивая новой строкой.
Переменная оболочки \fBecho_style\fR может быть установлена
для эмуляции (или нет) флагов и экранированных последовательностей
версий BSD и/или System V \fIecho\fR; см. \fIecho\fR(1).
.TP 8
.B echotc \fR[\fB\-sv\fR] \fIarg\fR ... (+)
Использует возможности терминала (см. \fItermcap\fR(5)) в \fIargs\fR.
Например, 'echotc home' перемещает курсор в начальную позицию, 
\&'echotc cm 3 10' перемещает его в столбец 3 и строку 10, а 
\&'echotc ts 0; echo "Это тест."; echotc fs' выводит "Это тест."
на строке состояния.
.RS +8
.PP
Если \fIarg\fR — это 'baud', 'cols', 'lines', 'meta' или 'tabs',
выводит значение этой возможности ("yes" или "no", указывающее,
что терминал имеет или не имеет эту возможность).
Это может использоваться для того, чтобы сделать вывод
из скрипта менее подробным на медленных терминалах или
ограничить вывод команд количеством строк на экране:
.IP "" 4
> set history=\`echotc lines\`
.br
> @ history\-\-
.PP
Строки termcap могут содержать подстановочные символы,
которые не будут корректно выводиться.
Следует использовать двойные кавычки при установке
переменной оболочки в строку возможностей терминала,
как в следующем примере, который выводит дату на строке состояния:
.IP "" 4
> set tosl="\`echotc ts 0\`"
.br
> set frsl="\`echotc fs\`"
.br
> echo \-n "$tosl";date; echo \-n "$frsl"
.PP
С параметромей \fB\-s\fR, несуществующие возможности возвращают
пустую строку, а не вызывают ошибку.
С параметромей \fB\-v\fR, вывод становится подробным.
.RE
.PP
.B else
.br
.B end
.br
.B endif
.PD 0
.TP 8
.B endsw
См. описание операторов \fIforeach\fR, \fIif\fR,
\fIswitch\fR и \fIwhile\fR ниже.
.PD
.TP 8
.B eval \fIarg\fR ...
Обрабатывает аргументы как входные данные для оболочки
и выполняет полученные команды в контексте текущей оболочки.
Обычно используется для выполнения команд, сгенерированных
в результате подстановки команд или переменных,
так как разбор происходит до этих подстановок.
См. \fItset\fR(1) для примера использования \fIeval\fR.
.TP 8
.B exec \fIcommand\fR
Выполняет указанную команду вместо текущей оболочки.
.TP 8
.B exit \fR[\fIexpr\fR]
Оболочка завершает работу либо с указанным значением
\fIexpr\fR (выражение, как описано в разделе \fBExpressions\fR),
либо, если \fIexpr\fR не указан, с кодом возврата 0.
.TP 8
.B fg \fR[\fB%\fIjob\fR ...]
Возвращает указанные задачи (или, если аргументы не указаны,
текущую задачу) в передний план, продолжая выполнение каждой,
если она была остановлена.
\fIjob\fR может быть числом, строкой, `', `%', `+' или `\-',
как описано в разделе \fBJobs\fR.
См. также команду редактора \fIrun-fg-editor\fR.
.TP 8
.B filetest \-\fIop file\fR ... (+)
Применяет \fIop\fR (это оператор проверки файлов,
как описано в разделе \fBFile inquiry operators\fR) к каждому
\fIfile\fR и возвращает результаты в виде списка,
разделенного пробелами.
.PP
.B foreach \fIname \fB(\fIwordlist\fB)
.br
\&...
.PD 0
.TP 8
.B end
Последовательно присваивает переменной \fIname\fR каждое значение
из \fIwordlist\fR и выполняет последовательность команд между этой
командой и соответствующей командой \fIend\fR.
(Обе команды \fIforeach\fR и \fIend\fR должны быть указаны
по отдельности на отдельных строках.) Встроенная команда
\fIcontinue\fR может быть использована для досрочного продолжения цикла,
а встроенная команда \fIbreak\fR — для его досрочного завершения.
Когда эта команда выполняется из терминала, цикл считывается
один раз с запросом `foreach? ' (или \fBprompt2\fR) до выполнения
любых команд в цикле. Если вы допустили ошибку при вводе цикла
в терминале, вы можете стереть его.
.PD
.TP 8
.B getspath \fR(+)
Выводит путь выполнения системы. (Только для TCF)
.TP 8
.B getxvers \fR(+)
Выводит префикс экспериментальной версии. (Только для TCF)
.TP 8
.B glob \fIwordlist
Как \fIecho\fR, но параметр `-n' не распознается, и
слова в выводе разделены нулевыми символами.
Полезно для программ, которые хотят использовать
оболочку для расширения списка файлов.
.TP 8
.B goto \fIword
\fIword\fR подставляется в виде имени файла и команды,
чтобы получить строку формата `label'.
Оболочка перематывает свой входной поток как можно дальше,
ищет строку формата `label:', возможно, предшествующую пробелами
или табуляцией, и продолжает выполнение после этой строки.
.TP 8
.B hashstat
Выводит строку статистики, указывающую, насколько эффективнов
нутренняя хеш-таблица находит команды (и избегает \fIexec\fR).
Попытка \fIexec\fR выполняется для каждого компонента \fBpath\fR,
где хеш-функция указывает на возможное совпадение,
и для каждого компонента, который не начинается с `/'.
.IP
На машинах без \fIvfork\fR(2) выводится только количество
и размер хеш-бакетов.
.PP
.B history \fR[\fB\-hTr\fR] [\fIn\fR]
.br
.B history \-S\fR|\fB\-L|\fB\-M \fR[\fIfilename\fR] (+)
.PD 0
.TP 8
.B history \-c \fR(+)
Первая форма выводит список событий истории.
Если указано \fIn\fR, выводятся или сохраняются
только \fIn\fR последних событий.
С флагом \fB\-h\fR список истории выводится без начальных номеров.
Если указан \fB\-T\fR, временные метки также выводятся в виде комментариев.
(Это может быть использовано для создания файлов, пригодных для загрузки
с помощью 'history \-L' или 'source \-h'.)
С флагом \fB\-r\fR, порядок вывода изменяется на самый новый сначала,
а не самый старый.
.PD
.RS +8
.PP
С флагом \fB\-S\fR, вторая форма сохраняет список истории в
файл \fIfilename\fR. Если первое слово переменной оболочки
\fBsavehist\fR установлено в число, сохраняется не более
указанного количества строк. Если второе слово переменной
\fBsavehist\fR установлено на `merge`, список истории объединяется
с существующим файлом истории вместо его замены (если такой существует)
и сортируется по временной метке. (+) Объединение предназначено для среды,
такой как X Window System, с несколькими одновременно работающими оболочками.
Если второе слово переменной \fBsavehist\fR установлено на `merge`,
а третье слово установлено на `lock`, обновление файла истории будет
синхронизировано с другими сеансами оболочки, которые могут захотеть
объединить историю одновременно.
.PP
С флагом \fB\-L\fR оболочка добавляет \fIfilename\fR, который,
предположительно, является списком истории, сохраненным с помощью
параметры \fB\-S\fR или механизма \fBsavehist\fR, в список истории.
Флаг \fB\-M\fR аналогичен \fB\-L\fR, но содержимое файла \fIfilename\fR
объединяется со списком истории и сортируется по временной метке.
В любом случае, используется \fBhistfile\fR, если \fIfilename\fR
не указано, и используется \fI~/.history\fR, если \fBhistfile\fR
не установлено.`history \-L` эквивалентно команде 'source \-h',
за исключением того, что для нее не требуется указание имени файла.
.PP 
Обратите внимание, что входные оболочки выполняют эквивалент
команды `history \-L` при запуске и, если установлена переменная
\fBsavehist\fR, выполняют команду `history \-S` перед выходом.
Поскольку только \fI~/.tcshrc\fR обычно загружается перед \fI~/.history\fR,
переменную \fBhistfile\fR следует устанавливать в \fI~/.tcshrc\fR,
а не в \fI~/.login\fR.
.PP
Если установлена переменная \fBhistlit\fR, первая и вторая формы выводят
и сохраняют буквальную (неразвернутую) форму списка истории.
.PP
Последняя форма очищает список истории.
.RE
.TP 8
.B hup \fR[\fIcommand\fR] \fR(+)
С командой \fIcommand\fR выполняет \fIcommand\fR таким образом,
что она завершится при получении сигнала завершения соединения,
и настраивает оболочку на отправку ей сигнала завершения
при завершении оболочки.
Обратите внимание, что команды могут самостоятельно установить
реакцию на завершение соединения, переопределив действие \fIhup\fR.
Без аргумента вызывает завершение неинтерактивной оболочки
при получении сигнала завершения соединения для оставшейся части скрипта.
См. также раздел \fBSignal handling\fR и встроенную команду \fInohup\fR.
.TP 8
.B if (\fIexpr\fB) \fIcommand
Если \fIexpr\fR (выражение, как описано в разделе \fBExpressions\fR)
оценивается как истинное, то выполняется \fIcommand\fR.
Подстановка переменных в \fIcommand\fR происходит на ранней стадии,
одновременно с обработкой остальных частей команды \fIif\fR.
\fIcommand\fR должен быть простой командой, не алиасом, не конвейером,
не списком команд и не списком команд в круглых скобках,
но она может иметь аргументы.
Перенаправление ввода/вывода происходит даже если \fIexpr\fR
ложно, и \fIcommand\fR, следовательно, \fInot\fR выполняется;
это ошибка.
.PP
.B if (\fIexpr\fB) then
.br
\&...
.br
.B else if (\fIexpr2\fB) then
.br
\&...
.br
.B else
.br
\&...
.PD 0
.TP 8
.B endif
Если указанное выражение \fIexpr\fR истинно, то выполняются
команды до первого оператора \fIelse\fR; в противном случае,
если выражение \fIexpr2\fR истинно, то выполняются команды
до второго оператора \fIelse\fR и т.д.
Возможны любые комбинации операторов \fIelse-if\fR;
только один оператор \fIendif\fR требуется. Оператор \fIelse\fR
также является необязательным. (Слова \fIelse\fR и \fIendif\fR
должны начинаться с начала строки; оператор \fIif\fR должен быть
указан отдельно на строке ввода или после оператора \fIelse\fR.)
.PD
.TP 8
.B inlib \fIshared-library\fR ... (+)
Добавляет каждую \fIshared-library\fR в текущую среду.
Нет возможности удалить общую библиотеку. (Только для Domain/OS)
.TP 8
.B jobs \fR[\fB\-l\fR]
Выводит список активных задач. С флагом \fB\-l\fR выводит идентификаторы
процессов в дополнение к обычной информации.
В системах TCF выводит узел, на котором выполняется каждая задача.
.PP
.PD 0
.TP 8
.B kill \fR[\fB\-s \fIsignal\fR] \fB%\fIjob\fR|\fIpid\fR ...
.PD 0
.TP 8
.B kill \-l
Первая и вторая формы отправляют указанный \fIsignal\fR
(или, если сигнал не указан, сигнал TERM (terminate)) указанным
задачам или процессам.
\fIjob\fR может быть числом, строкой, `', `%', `+' или `\-',
как описано в разделе \fBJobs\fR.
Сигналы могут быть заданы либо по номеру, либо по имени (как указано в
\fI/usr/include/signal.h\fR, без префикса `SIG').
Не существует значения \fIjob\fR по умолчанию; указание только `kill`
не отправляет сигнал текущей задаче. Если отправляется сигнал TERM
(terminate) или HUP (hangup), то задаче или процессу также
отправляется сигнал CONT (continue).
Третья форма выводит список названий сигналов.
.PD
.TP 8
.B limit \fR[\fB\-h\fR] [\fIresource\fR [\fImaximum-use\fR]]
Ограничивает потребление текущим процессом и каждым
созданным им процессом, чтобы оно не превышало \fImaximum-use\fR на
указанном \fIresource\fR. Если \fImaximum-use\fR не указано,
выводится текущее ограничение; если \fIresource\fR не указано,
выводятся все ограничения. Если указан флаг \fB\-h\fR,
используются жесткие ограничения вместо текущих.
Жесткие ограничения накладывают верхний предел на значения
текущих ограничений. Только суперпользователь может повысить
жесткие ограничения, но пользователь может понижать или повышать
текущие ограничения в рамках допустимого диапазона.
.RS +8
.PP
В настоящее время управляемые ресурсы включают
(если поддерживается ОС):
.TP
\fIcputime\fR
максимальное количество секунд процессора,
которое может использовать каждый процесс
.TP
\fIfilesize\fR
наибольший создаваемый файл
.TP
\fIdatasize\fR
максимальный рост области данных + стека
через sbrk(2) за пределами
текста программы
.TP
\fIstacksize\fR
максимальный размер автоматически расширяемой области стека
.TP
\fIcoredumpsize\fR
максимальный размер дампа памяти, который будет создан
.TP
\fImemoryuse\fR
максимальный объем физической памяти, выделяемой
процессу в любой момент времени
.TP
\fIvmemoryuse\fR
максимальный объем виртуальной памяти, выделяемой
процессу в любой момент времени (адресное пространство)
.TP
\fIheapsize\fR
максимальный объем памяти, выделяемой процессу
на системный вызов \fIbrk()\fR
.TP
\fIdescriptors\fR или \fIopenfiles\fR
максимальное количество открытых файлов
для этого процесса
.TP
\fIpseudoterminals\fR
максимальное количество псевдотерминалов
для этого пользователя
.TP
\fIkqueues\fR
максимальное количество kqueue, выделенных
для этого процесса
.TP
\fIconcurrency\fR
максимальное количество потоков для этого процесса
.TP
\fImemorylocked\fR
максимальный размер, который процесс может заблокировать
в памяти с использованием mlock(2)
.TP
\fImaxproc\fR
максимальное количество одновременных процессов
для этого идентификатора пользователя
.TP
\fImaxthread\fR
максимальное количество одновременных потоков
(легковесных процессов) для этого идентификатора пользователя
.TP
\fIthreads\fR
максимальное количество потоков для этого процесса
.TP
\fIsbsize\fR
максимальный размер использования сокетного буфера
для этого пользователя
.TP
\fIswapsize\fR
максимальный объем зарезервированного или используемого
пространства подкачки для этого пользователя
.TP
\fImaxlocks\fR
максимальное количество блокировок
для этого пользователя
.TP
\fIposixlocks\fR
максимальное количество блокировок POSIX
для этого пользователя
.TP
\fImaxsignal\fR
максимальное количество ожидающих сигналов
для этого пользователя
.TP
\fImaxmessage\fR
максимальный объем байтов в POSIX mqueues
для этого пользователя
.TP
\fImaxnice\fR
максимальный приоритет nice, который пользователь
может повысить, отображаемый от [19...-20] до [0...39]
для этого пользователя
.TP
\fImaxrtprio\fR
максимальный приоритет реального времени
для этого пользователя
\fImaxrttime\fR
время ожидания для задач реального времени
в микросекундах для этого пользователя.
.PP
\fImaximum-use\fR может быть указано как (числовое или целое)
значение с последующим указанием единицы измерения.
Для всех ограничений, кроме \fIcputime\fR, единица измерения
по умолчанию — `k` или `килобайты` (1024 байта); можно также
использовать единицы `m` или `мегабайты` или `g` или `гигабайты`.
Для \fIcputime\fR единица измерения по умолчанию — `секунды`,
но также можно использовать `m` для минут или `h` для часов,
или указать время в формате `мм:сс`, задавая минуты и секунды.
.PP
Если \fImaximum-use\fR равно `unlimited`, то ограничение на
указанный \fIresource\fR снимается
(это эквивалентно встроенной команде \fIunlimit\fR).
.PP
Для имен \fIresource\fR и единиц измерения достаточно
указания их уникальных префиксов.
.RE
.TP 8
.B log \fR(+)
Выводит переменную оболочки \fBwatch\fR и сообщает о каждом
пользователе, указанном в \fBwatch\fR, который вошел в систему,
независимо от времени его последнего входа.
См. также \fIwatchlog\fR.
.TP 8
.B login
Завершает сеанс входа оболочки, заменяя его экземпляром
\fI/bin/login\fR. Это один из способов выйти из системы,
включенный для совместимости с \fIsh\fR(1).
.TP 8
.B logout
Завершает сеанс входа в систему. Особенно полезен,
если установлена переменная \fBignoreeof\fR.
.TP 8
.B ls\-F \fR[\-\fIswitch\fR ...] [\fIfile\fR ...] (+)
Выводит список файлов как `ls \-F`, но гораздо быстрее.
Определяет каждый тип специального файла в списке с помощью
специального символа:
.PP
.RS +8
.PD 0
.TP 4
/
Каталог
.TP 4
*
Исполняемый файл
.TP 4
#
Блочное устройство
.TP 4
%
Символьное устройство
.TP 4
|
Именованный канал (только на системах с именованными каналами)
.TP 4
=
Сокет (только на системах с сокетами)
.TP 4
@
Символьная ссылка (только на системах с символьными ссылками)
.TP 4
+
Скрытый каталог (только для AIX) или контекстно-зависимый
(только для HP/UX)
.TP 4
:
Сетевой специальный файл (только для HP/UX)
.PD
.PP
Если установлена переменная оболочки \fBlistlinks\fR,
символьные ссылки отображаются более подробно
(только на системах, где они поддерживаются, разумеется):
.PP
.PD 0
.TP 4
@
Символьная ссылка на не-каталог
.TP 4
>
Символьная ссылка на каталог
.TP 4
&
Символьная ссылка в никуда
.PD
.PP
\fBlistlinks\fR также замедляет \fIls\-F\fR и заставляет
монтировать разделы, на которых находятся файлы,
на которые указывают символьные ссылки.
.PP
Если переменная оболочки \fBlistflags\fR установлена
на `x`, `a` или `A`, или на любую комбинацию этих значений
(например, `xA`), они используются как флаги для \fIls\-F\fR,
заставляя его действовать как `ls \-xF`, `ls \-Fa`, `ls \-FA`
или их комбинации (например, `ls \-FxA`).
На машинах, где `ls \-C` не является значением по умолчанию,
\fIls\-F\fR действует как `ls \-CF`,
если переменная \fBlistflags\fR не содержит `x`,
в противном случае она действует как `ls \-xF`.
\fIls\-F\fR передает свои аргументы команде \fIls\fR(1),
если указаны какие-либо флаги, поэтому `alias ls ls\-F`
обычно работает правильно.
.PP
\fBls\-F\fR встроенная команда может выводить файлы
с разными цветами в зависимости от типа файла или расширения.
См. переменную оболочки \fBcolor\fR и переменную
окружения \fBLS_COLORS\fR.
.RE
.PP
.B migrate \fR[\fB\-\fIsite\fR] \fIpid\fR|\fB%\fIjobid\fR ... (+)
.PD 0
.TP 8
.B migrate \-\fIsite\fR (+)
Первая форма перемещает процесс или задачу на указанный
сайт или на сайт по умолчанию, определенный системным путем.
Вторая форма эквивалентна `migrate \-\fIsite\fR $$`: она перемещает
текущий процесс на указанный сайт. Перемещение самой оболочки
может привести к непредсказуемому поведению, так как оболочке
не нравится терять свой tty. (Только для TCF)
.PD
.TP 8
.B newgrp \fR[\fB\-\fR] \fI[group]\fR (+)
Эквивалентно `exec newgrp`; см. \fInewgrp\fR(1).
Доступно только если оболочка была скомпилирована с этой функцией;
см. переменную оболочки \fBversion\fR.
.TP 8
.B nice \fR[\fB+\fInumber\fR] [\fIcommand\fR]
Устанавливает приоритет планирования для оболочки на \fInumber\fR или,
если \fInumber\fR не указан, на 4.
С \fIcommand\fR запускает \fIcommand\fR с соответствующим приоритетом.
Чем больше \fInumber\fR, тем меньше процессорного времени
выделяется процессу. Суперпользователь может указать отрицательный приоритет,
используя `nice \-number ...`. Команда всегда выполняется в под-оболочке,
и на нее распространяются ограничения, накладываемые на команды
в простых выражениях \fIif\fR.
.TP 8
.B nohup \fR[\fIcommand\fR]
С \fIcommand\fR запускает \fIcommand\fR таким образом,
что он будет игнорировать сигналы завершения соединения.
Обратите внимание, что команды могут самостоятельно установить
реакцию на сигналы завершения, переопределив действие \fInohup\fR.
Без аргумента вызывает игнорирование сигналов завершения для
неинтерактивной оболочки в оставшейся части скрипта.
См. также раздел \fBSignal handling\fR и встроенную команду \fIhup\fR.
.TP 8
.B notify \fR[\fB%\fIjob\fR ...]
Настраивает оболочку на асинхронное уведомление пользователя,
когда статус любой из указанных задач (или, если \fIjob\fR не указан,
текущей задачи) изменится, вместо того чтобы ждать следующего запроса,
как обычно. 
\fIjob\fR может быть числом, строкой, `', `%', `+' или `\-',
как описано в разделе \fBJobs\fR.
См. также переменную оболочки \fBnotify\fR.
.TP 8
.B onintr \fR[\fB\-\fR|\fIlabel\fR]
Управляет действием оболочки при прерываниях. Без аргументов
восстанавливает действие по умолчанию для прерываний,
которое заключается в завершении скриптов оболочки или возврате
на уровень ввода команд с терминала.
С параметром `\-', игнорирует все прерывания.
С параметром \fIlabel\fR, заставляет оболочку
выполнить команду `goto \fIlabel\fR'
при получении прерывания или завершении
дочернего процесса из-за прерывания.
.IP "" 8
\fIonintr\fR игнорируется, если оболочка запущена
в фоновом режиме или в системных
файлах запуска (см. \fBFILES\fR), где прерывания
в любом случае отключены.
.TP 8
.B popd \fR[\fB\-p\fR] [\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR] \fR[\fB+\fIn\fR]
Без аргументов извлекает каталог из стека каталогов и возвращается
к новому верхнему каталогу.
С номером `+\fIn\fR` удаляет \fIn\fR-й элемент из стека.
.IP "" 8
Наконец, все формы команды \fIpopd\fR выводят итоговый стек каталогов,
точно так же, как \fIdirs\fR. Переменную оболочки \fBpushdsilent\fR
можно установить для предотвращения этого, а флаг \fB\-p\fR можно
указать для отмены действия \fBpushdsilent\fR.
Флаги \fB\-l\fR, \fB\-n\fR и \fB\-v\fR оказывают
на \fIpopd\fR такое же влияние, как и на \fIdirs\fR.  (+)
.TP 8
.B printenv \fR[\fIname\fR] (+)
Выводит имена и значения всех переменных окружения или,
с параметром \fIname\fR, значение переменной окружения \fIname\fR.
.TP 8
.B pushd \fR[\fB\-p\fR] [\fB\-l\fR] [\fB\-n\fR|\fB\-v\fR] [\fIname\fR|\fB+\fIn\fR]
Без аргументов меняет местами два верхних элемента стека каталогов.
Если установлена переменная \fBpushdtohome\fR, то команда \fIpushd\fR
без аргументов выполняет `pushd ~', как команда \fIcd\fR.  (+)
С параметром \fIname\fR, помещает текущий рабочий каталог
в стек каталогов и переходит в каталог \fIname\fR.
Если \fIname\fR равно `\-' это интерпретируется как
предыдущий рабочий каталог
(см. \fBFilename substitution\fR).  (+)
Если установлена переменная \fBdunique\fR,
команда \fIpushd\fR удаляет любые экземпляры каталога \fIname\fR
из стека перед добавлением его в стек.  (+)
С номером `+\fIn\fR` вращает \fIn\fR-й элемент стека каталогов,
перемещая его на верхнюю позицию, и переходит в него.
Если установлена переменная \fBdextract\fR, однако,
команда `pushd +\fIn\fR` извлекает \fIn\fR-й
каталог, помещает его на вершину стека и переходит в него.  (+)
.IP "" 8
Наконец, все формы команды \fIpushd\fR выводят
итоговый стек каталогов, точно так же, как команда \fIdirs\fR.
Переменную оболочки \fBpushdsilent\fR можно установить для
предотвращения этого, а флаг \fB\-p\fR можно указать для
отмены действия \fBpushdsilent\fR.
Флаги \fB\-l\fR, \fB\-n\fR и \fB\-v\fR оказывают на \fIpushd\fR
такое же влияние, как и на \fIdirs\fR.  (+)
.TP 8
.B rehash
Заставляет пересчитать внутреннюю хеш-таблицу содержимого
каталогов, указанных в переменной \fBpath\fR. Это необходимо,
если переменная оболочки \fBautorehash\fR не установлена,
и новые команды добавляются в каталоги, указанные в \fBpath\fR,
пока вы находитесь в системе. С переменной \fBautorehash\fR новая
команда будет найдена автоматически, за исключением особого случая,
когда другая команда с тем же именем, находящаяся в другом каталоге,
уже существует в хеш-таблице.
Также очищается кэш домашних каталогов, созданный при расширении тильды.
.TP 8
.B repeat \fIcount command
Указанная команда \fIcommand\fR,
которая подчиняется тем же ограничениям, что и команда \fIcommand\fR
в однострочном операторе \fIif\fR выше, выполняется \fIcount\fR раз.
Перенаправления ввода/вывода происходят ровно один раз, даже
если \fIcount\fR равен 0.
.TP 8
.B rootnode //\fInodename \fR(+)
Изменяет корневой узел на //\fInodename\fR, так что `/'
будет интерпретироваться как `//\fInodename\fR'.
(Только для Domain/OS)
.PP
.B sched \fR(+)
.br
.B sched \fR[\fB+\fR]\fIhh:mm command\fR \fR(+)
.PD 0
.TP 8
.B sched \-\fIn\fR (+)
Первая форма выводит список запланированных событий.
Переменную оболочки \fBsched\fR можно установить
для определения формата, в котором
будет выводиться список запланированных событий.
Вторая форма добавляет команду \fIcommand\fR в список
запланированных событий.
Например,
.PD
.RS +8
.IP "" 4
> sched 11:00 echo Сейчас 11 часов.
.PP
заставляет оболочку вывести `Сейчас 11 часов.' в 11:00.
Время может быть указано в 12-часовом формате AM/PM.
.IP "" 4
> sched 5pm set prompt='[%h] Уже после 5; иди домой: >'
.PP
или может быть указано относительно текущего времени:
.IP "" 4
> sched +2:15 /usr/lib/uucp/uucico \-r1 \-sother
.PP
Относительное указание времени не может использовать формат AM/PM.
Третья форма удаляет элемент \fIn\fR из списка событий:
.IP "" 4
> sched
.br
     1  Ср Апр  4 15:42  /usr/lib/uucp/uucico \-r1 \-sother
.br
     2  Ср Апр  4 17:00  set prompt=[%h] Уже после 5; иди домой: >
.br
> sched \-2
.br
> sched
.br
     1  Ср Апр  4 15:42  /usr/lib/uucp/uucico \-r1 \-sother
.PP
Команда из списка запланированных событий выполняется
непосредственно перед первым приглашением к вводу
после запланированного времени выполнения команды.
Можно пропустить точное время выполнения команды, но
просроченная команда будет выполнена при следующем приглашении.
Команда, которая подошла во время ожидания ввода пользователя
оболочкой, выполняется немедленно.
Однако нормальная работа уже выполняемой команды не будет
прервана для выполнения элемента списка запланированных событий.
.PP
Этот механизм похож, но не идентичен команде \fIat\fR(1)
в некоторых Unix-системах.
Его основной недостаток заключается в том, что команда
может не выполниться в точно указанное время.
Его основное преимущество заключается в том, что,
поскольку \fIsched\fR работает непосредственно из
оболочки, он имеет доступ к переменным оболочки и другим структурам.
Это предоставляет механизм изменения рабочего окружения
в зависимости от времени суток.
.RE
.PP
.B set
.br
.B set \fIname\fR ...
.br
.B set \fIname\fR\fB=\fIword\fR ...
.br
.B set [\-r] [\-f|\-l] \fIname\fR\fB=(\fIwordlist\fB)\fR ... (+)
.br
.B set \fIname[index]\fR\fB=\fIword\fR ...
.br
.B set \-r \fR(+)
.br
.B set \-r \fIname\fR ... (+)
.PD 0
.TP 8
.B set \-r \fIname\fR\fB=\fIword\fR ... (+)
Первая форма команды выводит значение всех переменных оболочки.
Переменные, содержащие более одного слова, выводятся как список
слов в скобках.
Вторая форма присваивает переменной \fIname\fR пустую строку.
Третья форма присваивает переменной \fIname\fR одно слово \fIword\fR.
Четвертая форма присваивает переменной \fIname\fR список слов из
\fIwordlist\fR.
Во всех случаях значение подвергается подстановке команд и имен файлов.
Если указан флаг \fB\-r\fR, значение переменной устанавливается как "только для чтения".
Если указаны флаги \fB\-f\fR или \fB\-l\fR, устанавливаются только уникальные слова,
сохраняя их порядок.
\fB\-f\fR отдает предпочтение первому вхождению слова, а \fB\-l\fR — последнему.
Пятая форма присваивает \fIindex\fR-ый компонент переменной \fIname\fR
значение \fIword\fR;
этот компонент должен уже существовать.
Шестая форма выводит только имена всех переменных оболочки,
которые имеют статус "только для чтения".
Седьмая форма делает переменную \fIname\fR "только для чтения",
независимо от того, имеет ли она значение.
Восьмая форма аналогична третьей, но одновременно делает
переменную \fIname\fR "только для чтения".
.PD
.IP "" 8
Эти аргументы могут повторяться для установки и/или присвоения
статуса "только для чтения" нескольким переменным в одной команде set.
Однако, обратите внимание, что подстановка переменных происходит для всех
аргументов до того, как будет выполнена установка значений.
Также обратите внимание, что `=` может находиться рядом как
с \fIname\fR, так и с \fIword\fR, или разделяться пробелами,
но не может находиться рядом только с одной из сторон.
См. также встроенную команду \fIunset\fR.
.TP 8
.B setenv \fR[\fIname \fR[\fIvalue\fR]]
Без аргументов выводит имена и значения всех переменных окружения.
С параметром \fIname\fR устанавливает переменную окружения \fIname\fR
в значение \fIvalue\fR или, если \fIvalue\fR не указано,
присваивает пустую строку.
.TP 8
.B setpath \fIpath \fR(+)
Эквивалентно команде \fIsetpath\fR(1). (Только для Mach)
.TP 8
.B setspath\fR LOCAL|\fIsite\fR|\fIcpu\fR ...  (+)
Устанавливает системный путь выполнения. (Только для TCF)
.TP 8
.B settc \fIcap value \fR(+)
Заставляет оболочку полагать, что возможность терминала \fIcap\fR
(как определено в \fItermcap\fR(5)) имеет значение \fIvalue\fR.
Проверка на корректность не выполняется.
Пользователи терминалов Concept могут использовать `settc xn no`,
чтобы получить правильную переносимость в крайнем правом столбце.
.TP 8
.B setty \fR[\fB\-d\fR|\fB\-q\fR|\fB\-x\fR] [\fB\-a\fR] [[\fB+\fR|\fB\-\fR]\fImode\fR] (+)
Управляет, какие режимы tty (см. \fBTerminal management\fR)
оболочка не разрешает изменять.
\fB\-d\fR, \fB\-q\fR или \fB\-x\fR указывают, чтобы \fIsetty\fR действовал
на наборы режимов tty `edit', `quote' или `execute' соответственно; без
\fB\-d\fR, \fB\-q\fR или \fB\-x\fR используется `execute'.
.IP "" 8
Без других аргументов \fIsetty\fR выводит режимы в выбранном наборе,
которые зафиксированы как включенные (`+mode') или выключенные (`\-mode').
Доступные режимы, и, следовательно, вывод, различаются в зависимости от системы.
С флагом \fB\-a\fR выводит все tty режимы в выбранном наборе,
независимо от того, зафиксированы они или нет.
С параметрами \fB+\fImode\fR, \fB\-\fImode\fR или просто \fImode\fR фиксирует
режим \fImode\fR как включенный, выключенный или снимает управление
с режима в выбранном наборе.
Например, `setty +echok echoe' фиксирует режим `echok' включенным
и разрешает командам включать или отключать режим `echoe',
как при выполнении команд оболочки.
.TP 8
.B setxvers\fR [\fIstring\fR] (+)
Устанавливает префикс экспериментальной версии
на \fIstring\fR или удаляет его,
если \fIstring\fR опущен. (Только для TCF)
.TP 8
.B shift \fR[\fIvariable\fR]
Без аргументов удаляет \fBargv\fR[1] и сдвигает элементы
\fBargv\fR влево. Ошибкой является, если \fBargv\fR не
установлена или имеетт меньше одного слова в качестве значения.
С параметром \fIvariable\fR выполняет
ту же функцию для переменной \fIvariable\fR.
.TP 8
.B source \fR[\fB\-h\fR] \fIname\fR [\fIargs\fR ...]
Оболочка читает и выполняет команды из файла \fIname\fR.
Команды не помещаются в список истории.
Если указаны какие-либо \fIargs\fR, они помещаются в переменную \fBargv\fR.  (+)
Команды \fIsource\fR могут быть вложены;
если они вложены слишком глубоко, оболочке может не хватить
файловых дескрипторов.
Ошибка в любой команде \fIsource\fR на любом уровне завершает
выполнение всех вложенных
команд \fIsource\fR.
С флагом \fB\-h\fR команды помещаются в список истории,
вместо того чтобы быть
выполненными, как в случае с `history \-L'.
.TP 8
.B stop \fB%\fIjob\fR|\fIpid\fR ...
Останавливает указанные задачи или процессы,
которые выполняются в фоновом режиме.
\fIjob\fR может быть числом, строкой, `', `%', `+' или `\-',
как описано в разделе \fBJobs\fR.
Нет значения \fIjob\fR по умолчанию; команда `stop`
без указания задачи не останавливает текущую задачу.
.TP 8
.B suspend
Заставляет оболочку приостановить свою работу,
как если бы ей был послан сигнал остановки с помощью \fB^Z\fR.
Это чаще всего используется для приостановки оболочек,
запущенных с помощью команды \fIsu\fR(1).
.PP
.B switch (\fIstring\fB)
.br
.B case \fIstr1\fB:
.PD 0
.IP "" 4
\&...
.br
.B breaksw
.PP
\&...
.PP
.B default:
.IP "" 4
\&...
.br
.B breaksw
.TP 8
.B endsw
Каждая метка case последовательно сравнивается с указанной
строкой \fIstring\fR, которая предварительно подвергается
подстановке команд и имен файлов.
Метасимволы файлов `*', `?' и `[...]' могут использоваться
в метках case, которые также подвергаются подстановке переменных.
Если ни одна из меток не совпадет до того, как будет найдена
метка `default', то выполнение начнется после метки default.
Каждая метка case и метка default должны начинаться с начала строки.
Команда \fIbreaksw\fR заставляет выполнение продолжаться после \fIendsw\fR.
В противном случае, управление может переходить через метки case
и метки default, как в языке C. Если ни одна метка не совпадает и
отсутствует метка default, выполнение продолжается после \fIendsw\fR.
.PD
.TP 8
.B telltc \fR(+)
Выводит значения всех возможностей терминала (см. \fItermcap\fR(5)).
.TP 8
.B termname \fR[\fIterminal type\fR] \fR(+)
Проверяет, имеет ли указанный тип терминала \fIterminal type\fR
(или текущее значение переменной \fBTERM\fR, если тип терминала не указан)
запись в базе данных termcap(5) или terminfo(5) хоста.
Выводит тип терминала в стандартный вывод и возвращает 0,
если запись присутствует, в противном случае возвращает 1.
.TP 8
.B time \fR[\fIcommand\fR]
Выполняет команду \fIcommand\fR (которая должна быть простой командой,
а не алиасом, конвейером, списком команд или списком команд
в круглых скобках) и выводит сводку времени,
как описано в переменной \fBtime\fR.
При необходимости создается дополнительная оболочка для
вывода статистики времени после завершения команды.
Без команды \fIcommand\fR выводит сводку времени для
текущей оболочки и ее дочерних процессов.
.TP 8
.B umask \fR[\fIvalue\fR]
Устанавливает маску создания файлов в значение \fIvalue\fR,
которое задается в восьмеричном формате.
Обычные значения маски:
002, дающее полный доступ группе и доступ на чтение и
выполнение для остальных, и 022, дающее доступ на чтение
и выполнение для группы и остальных.
Без указания \fIvalue\fR выводит текущую маску создания файлов.
.TP 8
.B unalias \fIpattern\fR
.br
Удаляет все алиасы, имена которых совпадают с \fIpattern\fR.
Команда `unalias *` удаляет все алиасы.
Ошибкой не является, если ничего не будет удалено.
.TP 8
.B uncomplete \fIpattern\fR (+)
Удаляет все завершения, имена которых совпадают с \fIpattern\fR.
Команда `uncomplete *` удаляет все завершения.
Ошибкой не является, если ничего не будет удалено.
.TP 8
.B unhash
Отключает использование внутренней хеш-таблицы для
ускорения поиска выполняемых программ.
.TP 8
.B universe \fIuniverse\fR (+)
Устанавливает вселенную в значение \fIuniverse\fR.
(Только для Masscomp/RTU)
.TP 8
.B unlimit \fR[\fB\-hf\fR] [\fIresource\fR]
Удаляет ограничение на \fIresource\fR или,
если \fIresource\fR не указано, все ограничения \fIresource\fR.
С флагом \fB\-h\fR удаляются соответствующие жесткие ограничения.
Только суперпользователь может это сделать.
Обратите внимание, что команда \fBunlimit\fR может
не завершиться успешно, так как большинство систем
не позволяют снимать ограничение на \fIdescriptors\fR.
С флагом \fB\-f\fR ошибки игнорируются.
.TP 8
.B unset \fIpattern
Удаляет все переменные, имена которых совпадают
с \fIpattern\fR, если они не имеют статус "только для чтения".
Команда `unset *` удаляет все переменные, кроме переменных
"только для чтения";
это плохая идея.
Ошибкой не является, если ничего не будет удалено.
.TP 8
.B unsetenv \fIpattern
Удаляет все переменные окружения, имена которых совпадают
с \fIpattern\fR.
Команда `unsetenv *` удаляет все переменные окружения;
это плохая идея.
Ошибкой не является, если ничего не будет удалено.
.TP 8
.B ver \fR[\fIsystype\fR [\fIcommand\fR]] (+)
Без аргументов выводит значение \fBSYSTYPE\fR.
С параметром \fIsystype\fR устанавливает \fBSYSTYPE\fR
в значение \fIsystype\fR. С параметрами \fIsystype\fR
и \fIcommand\fR выполняет команду \fIcommand\fR
под \fIsystype\fR. \fIsystype\fR может быть `bsd4.3`
или `sys5.3`.
(Только для Domain/OS)
.TP 8
.B wait
Оболочка ожидает завершения всех фоновых задач.
Если оболочка является интерактивной, прерывание
нарушит ожидание и заставит оболочку вывести имена
и номера всех незавершенных задач.
.TP 8
.B warp \fIuniverse\fR (+)
Устанавливает вселенную в значение \fIuniverse\fR.
(Только для Convex/OS)
.TP 8
.B watchlog \fR(+)
Альтернативное название для встроенной команды
\fIlog\fR (см. выше).
Доступно только если оболочка была скомпилирована
с этой функцией;
см. переменную оболочки \fBversion\fR.
.TP 8
.B where \fIcommand\fR (+)
Выводит все известные экземпляры команды \fIcommand\fR,
включая алиасы, встроенные команды и
исполняемые файлы в переменной \fBpath\fR.
.TP 8
.B which\fR \fIcommand\fR (+)
Отображает команду, которая будет выполнена оболочкой
после подстановок, поиска в \fBpath\fR и т. д.
Встроенная команда аналогична \fIwhich\fR(1),
но она корректно выводит алиасы \fItcsh\fR и
встроенные команды и работает в 10-100 раз быстрее.
См. также команду редактора \fIwhich-command\fR.
.PP
.B while (\fIexpr\fB)\fR
.br
\&...
.PD 0
.TP 8
.B end
Выполняет команды между \fIwhile\fR и соответствующей
командой \fIend\fR пока выражение \fIexpr\fR
(описанное в разделе \fBExpressions\fR)
оценивается как ненулевое.
\fIwhile\fR и \fIend\fR должны находиться отдельно
на своих строках ввода.
\fIbreak\fR и \fIcontinue\fR могут использоваться для
преждевременного завершения или продолжения цикла.
Если ввод осуществляется с терминала, пользователь
получает приглашение в первый раз внутри цикла,
как в команде \fIforeach\fR.
.PD
.SS "Специальные алиасы (+)"
Если установлены, каждый из этих алиасов выполняется
автоматически в указанное время.
Изначально они все не определены.
.TP 8
.B beepcmd
Выполняется, когда оболочка хочет
подать звуковой сигнал терминала.
.TP 8
.B cwdcmd
Выполняется после каждого изменения рабочего каталога.
Например, если пользователь работает
в системе X Window, используя \fIxterm\fR(1) и окно
с поддержкой заголовков, такое как \fItwm\fR(1), и делает:
.RS +8
.IP "" 4
> alias cwdcmd  'echo \-n "^[]2;${HOST}:$cwd ^G"'
.PP
тогда оболочка изменит заголовок запущенного
\fIxterm\fR(1) на имя хоста, двоеточие и полный
путь к текущему рабочему каталогу.
Более сложный способ сделать это:
.IP "" 4
> alias cwdcmd 'echo \-n "^[]2;${HOST}:$cwd^G^[]1;${HOST}^G"'
.PP
Это поместит имя хоста и рабочий каталог в строку заголовка,
а в меню управления иконками — только имя хоста.
.PP
Обратите внимание, что использование команд \fIcd\fR,
\fIpushd\fR или \fIpopd\fR в \fIcwdcmd\fR
может привести к бесконечному циклу.
По мнению автора, любой, кто это сделает,
получит то, что заслуживает.
.RE
.TP 8
.B jobcmd
Выполняется перед каждой командой или при
изменении состояния команды.
Это похоже на \fIpostcmd\fR,
но не выводит встроенные команды.
.RS +8
.IP "" 4
> alias jobcmd  'echo \-n "^[]2\e;\e!#:q^G"'
.PP
тогда при выполнении команды \fIvi foo.c\fR
строка команды появится в заголовке xterm.
.RE
.TP 8
.B helpcommand
Вызывается командой редактора \fBrun-help\fR.
Имя команды, для которой требуется помощь,
передается в качестве единственного аргумента.
Например, если выполнить:
.RS +8
.IP "" 4
> alias helpcommand '\e!:1 --help'
.PP
тогда будет вызван справочный вывод самой команды,
используя синтаксис вызова справки GNU.
В настоящее время нет простого способа учесть различные
синтаксисы вызова (например, обычный Unix `-h'),
за исключением использования таблицы для многих команд.
.RE
.TP 8
.B periodic
Выполняется каждые \fBtperiod\fR минут.
Это удобный способ проверять нечасто изменяющиеся события,
такие как новая почта. Например, если выполнить:
.RS +8
.IP "" 4
> set tperiod = 30
.br
> alias periodic checknews
.PP
то программа \fIchecknews\fR(1) будет запускаться каждые 30 минут.
Если \fIperiodic\fR установлен,
но \fBtperiod\fR не задан или равен 0,
\fIperiodic\fR ведет себя так же, как \fIprecmd\fR.
.RE
.TP 8
.B precmd
Выполняется непосредственно перед выводом каждого запроса.
Например, если выполнить:
.RS +8
.IP "" 4
> alias precmd date
.PP
то команда \fIdate\fR(1) будет выполняться
перед каждым запросом оболочки.
Нет ограничений на то, что может делать
\fIprecmd\fR, но следует проявлять осторожность.
.RE
.TP 8
.B postcmd
Выполняется перед каждой командой.
.RS +8
.IP "" 4
> alias postcmd  'echo \-n "^[]2\e;\e!#:q^G"'
.PP
тогда при выполнении команды \fIvi foo.c\fR
строка команды появится в заголовке xterm.
.RE
.TP 8
.B shell
Определяет интерпретатор для исполняемых скриптов,
которые сами не указывают интерпретатор.
Первое слово должно быть полным путем к желаемому
интерпретатору (например, `/bin/csh` или `/usr/local/bin/tcsh`).
.SS "Специальные переменные оболочки"
Переменные, описанные в этом разделе,
имеют особое значение для оболочки.
.PP
Оболочка устанавливает \fBaddsuffix\fR, \fBargv\fR,
\fBautologout\fR, \fBcsubstnonl\fR, \fBcommand\fR,
\fBecho_style\fR, \fBedit\fR, \fBgid\fR, \fBgroup\fR,
\fBhome\fR, \fBloginsh\fR, \fBoid\fR, \fBpath\fR,
\fBprompt\fR, \fBprompt2\fR, \fBprompt3\fR, \fBshell\fR,
\fBshlvl\fR, \fBtcsh\fR, \fBterm\fR, \fBtty\fR, \fBuid\fR,
\fBuser\fR и \fBversion\fR при запуске;
они не изменяются после этого,
если только не изменяются пользователем.
Оболочка обновляет \fBcwd\fR, \fBdirstack\fR, \fBowd\fR
и \fBstatus\fR при необходимости, и устанавливает
\fBlogout\fR при выходе.
.PP
Оболочка синхронизирует переменные \fBgroup\fR, \fBhome\fR,
\fBpath\fR, \fBshlvl\fR, \fBterm\fR и \fBuser\fR
с одноименными переменными окружения:
когда переменная окружения изменяется,
оболочка меняет соответствующую
переменную оболочки (если переменная оболочки не установлена
как "только для чтения") и наоборот.
Обратите внимание, что хотя \fBcwd\fR и \fBPWD\fR имеют
одинаковое значение, они не синхронизируются таким образом,
и что оболочка автоматически конвертирует между разными
форматами переменных \fBpath\fR и \fBPATH\fR.
.TP 8
.B addsuffix \fR(+)
Если установлена, автозавершение имен файлов добавляет `/'
в конце каталогов и пробел в конце обычных файлов,
когда они совпадают точно. Установлена по умолчанию.
.TP 8
.B afsuser \fR(+)
Если установлена, функция автозакрытия \fBautologout\fR
использует это значение вместо локального имени
пользователя для аутентификации kerberos.
.TP 8
.B ampm \fR(+)
Если установлена, все времена отображаются в
12-часовом формате AM/PM.
.TP 8
.B anyerror \fR(+)
Эта переменная определяет, что передается в значение
переменной \fBstatus\fR. Подробнее см. описание
переменной \fBstatus\fR ниже.
.TP 8
.B argv
Аргументы для оболочки. Позиционные параметры берутся
из переменной \fBargv\fR, т.е. `$1` заменяется
на `$argv[1]` и т.д.
Установлена по умолчанию, но обычно пуста
в интерактивных оболочках.
.TP 8
.B autocorrect \fR(+)
Если установлена, команда редактора \fIspell-word\fR
вызывается автоматически перед
каждой попыткой завершения.
.TP 8
.B autoexpand \fR(+)
Если установлена, команда редактора \fIexpand-history\fR
вызывается автоматически перед каждой попыткой завершения.
Если установлена в значение \fIonlyhistory\fR, то
развертыванию подлежит только история, а второе
завершение развернет имена файлов.
.TP 8
.B autolist \fR(+)
Если установлена, варианты выводятся после
неоднозначного завершения.
Если установлена в значение `ambiguous`,
варианты выводятся только тогда, когда
при завершении не добавляются новые символы.
.TP 8
.B autologout \fR(+)
Первое слово — это количество минут бездействия до
автоматического выхода.
Необязательное второе слово — количество минут
бездействия до автоматической блокировки.
Когда оболочка автоматически завершает сеанс, она
выводит `auto-logout`, устанавливает переменную
\fBlogout\fR в значение `automatic`
и завершает работу.
Когда оболочка автоматически блокируется,
пользователю необходимо ввести свой пароль
для продолжения работы.
Пять неверных попыток приводят к
автоматическому выходу.
По умолчанию установлено значение `60`
(автоматический выход через 60 минут,
без блокировки)
в оболочках входа и суперпользователя,
но не если оболочка считает,
что она работает в оконной системе
(т.е. установлена переменная
окружения \fBDISPLAY\fR),
tty — это псевдотерминал (pty) или оболочка
не была скомпилирована с этой функцией
(см. переменную оболочки \fBversion\fR).
Сбросьте или установите значение `0`,
чтобы отключить автоматический выход.
См. также переменные оболочки
\fBafsuser\fR и \fBlogout\fR.
.TP 8
.B autorehash \fR(+)
Если установлена, внутренняя хеш-таблица
содержимого каталогов в переменной \fBpath\fR
будет пересчитываться, если команда не найдена
в хеш-таблице.
Кроме того, список доступных команд будет
пересчитываться для каждой
попытки завершения команды или исправления опечатки,
если установлено значение `complete` или `correct`
соответственно; если установлено значение `always`,
это будет происходить в обоих случаях.
.TP 8
.B backslash_quote \fR(+)
.\" TODO
Если установлена, обратные косые черты (`\e`) всегда
экранируют `\e`, `''` и `"`. Это может упростить
сложные задачи экранирования, но может вызвать
синтаксические ошибки в скриптах \fIcsh\fR(1).
.TP 8
.B catalog
Имя файла каталога сообщений.
Если установлено, tcsh использует `tcsh.${catalog}`
в качестве каталога сообщений вместо стандартного `tcsh`.
.TP 8
.B cdpath
Список каталогов, в которых \fIcd\fR должен искать
подкаталоги, если они не найдены в текущем каталоге.
.TP 8
.B cdtohome \fR(+)
Если не установлено, \fIcd\fR требует указания
имени каталога \fIname\fR и не перейдет в
каталог \fBhome\fR, если он пропущен.
Эта переменная установлена по умолчанию.
.TP 8
.B color
Если установлена, она включает цветное отображение
для встроенной команды \fBls\-F\fR и передает
\fB\-\-color=auto\fR команде \fBls\fR.
В качестве альтернативы, она может быть установлена
только для \fBls\-F\fR или только для \fBls\fR,
чтобы включить цвет только для одной из команд.
Установка пустого значения эквивалентна установке
значения \fB(ls\-F ls)\fR.
.TP 8
.B colorcat
Если установлена, она включает цветные
escape-последовательности для файлов сообщений NLS.
И отображает цветные сообщения NLS.
.TP 8
.B command \fR(+)
Если установлена, команда, которая была передана
оболочке с флагом \fB-c\fR (см. выше).
.TP 8
.B compat_expr \fR(+)
Если установлена, оболочка будет оценивать выражения
справа налево, как это делала оригинальная \fIcsh\fR.
.TP 8
.B complete \fR(+)
Если установлено в `igncase`, автозавершение становится
нечувствительным к регистру.
Если установлено в `enhance`, автозавершение игнорирует
регистр и считает дефисы и подчеркивания эквивалентными;
также будут рассматриваться точки, дефисы и подчеркивания
(`.', `\-' и `_') как разделители слов.
Если установлено в `Enhance`, автозавершение явно
сопоставляет символы верхнего регистра и подчеркивания,
а символы нижнего регистра и дефисы сопоставляет
нечувствительно к регистру; точки, дефисы и подчеркивания
также считаются разделителями слов.
.TP 8
.B continue \fR(+)
Если установлено в список команд, оболочка продолжит
выполнение указанных команд, вместо того чтобы начинать
новую.
.TP 8
.B continue_args \fR(+)
То же самое, что и continue, но оболочка выполнит:
.RS +8
.IP "" 4
echo \`pwd\` $argv > ~/.<cmd>_pause; %<cmd>
.RE
.TP 8
.B correct \fR(+)
Если установлено в `cmd`,
команды автоматически исправляются по орфографии.
Если установлено в `complete`,
команды автоматически завершаются.
Если установлено в `all`,
исправляется вся строка команды.
.TP 8
.B csubstnonl \fR(+)
Если установлено, переводы строк и возвраты каретки
в подстановке команд заменяются пробелами.
Установлено по умолчанию.
.TP 8
.B cwd
Полный путь к текущему каталогу.
См. также переменные оболочки
\fBdirstack\fR и \fBowd\fR.
.TP 8
.B dextract \fR(+)
Если установлено, команда `pushd +\fIn\fR`
извлекает \fIn\fR-й каталог из стека каталогов,
а не перемещает его наверх.
.TP 8
.B dirsfile \fR(+)
Путь по умолчанию, в который команды `dirs \-S`
и `dirs \-L` ищут файл истории.
Если не установлено, используется \fI~/.cshdirs\fR.
Так как только \fI~/.tcshrc\fR обычно обрабатывается
до \fI~/.cshdirs\fR, переменную \fBdirsfile\fR следует
устанавливать в \fI~/.tcshrc\fR, а не в \fI~/.login\fR.
.TP 8
.B dirstack \fR(+)
Массив всех каталогов в стеке каталогов.
`$dirstack[1]` — это текущий рабочий каталог,
`$dirstack[2]` — первый каталог в стеке и т.д.
Обратите внимание, что текущий рабочий каталог — это
`$dirstack[1]`, но в подстановках стека каталогов
это `=0`. Можно изменять стек произвольно,
устанавливая \fBdirstack\fR, но первый элемент
(текущий рабочий каталог) всегда будет правильным.
См. также переменные оболочки \fBcwd\fR и \fBowd\fR.
.TP 8
.B dspmbyte \fR(+)
Эффект проявляется только если 'dspm' указан
как часть переменной \fBversion\fR.
Если установлено в `euc`, включается отображение
и редактирование кодировки EUC-kanji (японский).
Если установлено в `sjis`, включается отображение
и редактирование кодировки Shift-JIS (японский).
Если установлено в `big5`, включается отображение
и редактирование кодировки Big5 (китайский).
Если установлено в `utf8`, включается отображение
и редактирование кодировки Utf8 (Unicode).
Если установлено в следующий формат, включается
отображение и редактирование оригинального
формата многобайтового кода:
.RS +8
.IP "" 4
> set dspmbyte = 0000....(256 байт)....0000
.PP
Таблица требует \fBjust\fR 256 байт.
Каждый символ из 256 символов
соответствует (слева направо)
кодам ASCII 0x00, 0x01, ... 0xff.
Каждый символ
.\" (позиция в этой таблице?)
устанавливается в число 0,1,2 или 3.
Каждое число имеет следующее значение:
.br
  0 ... не используется для многобайтовых символов.
.br
  1 ... используется для первого байта многобайтового символа.
.br
  2 ... используется для второго байта многобайтового символа.
.br
  3 ... используется для обоих байтов многобайтового символа.
.PP
Пример:
.br
Если установлено в `001322`, первый символ
(означает 0x00 ASCII) и второй символ
(означает 0x01 ASCII) установлены в `0`.
Тогда они не используются для многобайтовых
символов. Третий символ (0x02) установлен в '1',
что указывает на использование его как первого байта
многобайтового символа. Четвертый символ (0x03)
установлен в '3'. Он используется как первый и
второй байт многобайтового символа.
Пятый и шестой символы (0x04,0x05) установлены
в '2', что указывает на их использование как
второго байта многобайтового символа.
.PP
Версия GNU fileutils команды ls не может отображать
имена многобайтовых файлов без параметра -N ( --literal ).
Если вы используете эту версию, установите второе
слово переменной dspmbyte в "ls". В противном случае,
например, "ls-F -l" не сможет отображать имена
многобайтовых файлов.
.PP
Примечание:
.br
Эта переменная может использоваться только если
KANJI и DSPMBYTE были определены при сборке.
.RE
.TP 8
.B dunique \fR(+)
Если установлено, команда \fIpushd\fR удаляет
все экземпляры \fIname\fR из стека перед
добавлением его в стек.
.TP 8
.B echo
Если установлено, каждая команда с ее аргументами
выводится перед выполнением.
Для нестандартных команд все подстановки
выполняются перед выводом.
Стандартные команды выводятся перед подстановкой
команд и имен файлов,
так как эти подстановки выполняются избирательно.
Устанавливается командной строкой с флагом \fB\-x\fR.
.TP 8
.B echo_style \fR(+)
Стиль встроенной команды \fIecho\fR.
Может быть установлен в следующие значения:
.PP
.RS +8
.PD 0
.TP 8
bsd
Не выводить перевод строки, если первым аргументом
является `\-n`; значение по умолчанию для \fIcsh\fR.
.TP 8
sysv
Распознавать экранированные последовательности в
строках команды echo.
.TP 8
both
Распознавать как флаг `\-n`, так и экранированные
последовательности; значение по умолчанию
для \fItcsh\fR.
.TP 8
none
Не распознавать ни флаг, ни экранированные
последовательности.
.PD
.PP
По умолчанию установлено в значение, зависящее от
локальной системы.
Параметры BSD и System V описаны в страницах руководства
\fIecho\fR(1) для соответствующих
систем.
.RE
.TP 8
.B edit \fR(+)
Если установлено, используется редактор командной строки.
Установлено по умолчанию в интерактивных
оболочках.
.TP 8
.B editors \fR(+)
Список имен команд, которые сопоставляются с командой
редактора \fIrun-fg-editor\fR.
Если не установлено, используются переменные окружения
\fBEDITOR\fR (`ed` если не установлена) и
\fBVISUAL\fR (`vi` если не установлена).
.TP 8
.B ellipsis \fR(+)
Если установлено, последовательности `%c'/`%.' и `%C`
в строках запроса (см. переменную оболочки \fBprompt\fR)
указывают пропущенные каталоги многоточием (`...`)
вместо `/<skipped>`.
.TP 8
.B euid \fR(+)
Эффективный идентификатор пользователя.
.TP 8
.B euser \fR(+)
Первое совпадающее имя из записи passwd, соответствующее
эффективному идентификатору пользователя.
.TP 8
.B fignore \fR(+)
Список суффиксов имен файлов, которые игнорируются
при автозавершении.
.TP 8
.B filec
В \fItcsh\fR автозавершение всегда используется, и
эта переменная игнорируется по умолчанию. Если 
.B edit
не установлен, используется традиционное
завершение \fIcsh\fR.
Если установлено в \fIcsh\fR,
используется автозавершение имен файлов.
.TP 8
.B gid \fR(+)
Реальный идентификатор группы пользователя.
.TP 8
.B globdot \fR(+)
Если установлено, шаблоны с подстановочными
знаками будут совпадать с файлами и каталогами,
начинающимися с `.' за исключением `.' и `..'
.TP 8
.B globstar \fR(+)
Если установлено, шаблоны файлов `**' и `***'
будут совпадать с любой строкой символов, включая `/',
охватывая все существующие подкаталоги. (например,
`ls **.c` отобразит все файлы .c в текущем дереве каталогов).
Если использовать шаблон без дополнительных символов,
он будет соответствовать нулю или более подкаталогам
(например, `ls /usr/include/**/time.h` отобразит
любой файл с именем `time.h`
в дереве каталогов /usr/include;
тогда как `ls /usr/include/**time.h`
соответствует любому файлу в дереве
каталогов /usr/include, оканчивающемуся на `time.h`).
Чтобы избежать проблем с рекурсией, шаблон `**` не будет
переходить в символическую ссылку, содержащую каталог.
Чтобы переопределить это, используйте `***'.
.TP 8
.B group \fR(+)
Имя группы пользователя.
.TP 8
.B highlight
Если установлено, результат инкрементного поиска
(в \fIi-search-back\fR и \fIi-search-fwd\fR) и
область между меткой и курсором выделяются обратным видео.
.IP "" 8
Выделение требует более частой записи в терминал,
что вводит дополнительную нагрузку. Если вас
заботит производительность терминала, возможно,
вы захотите оставить эту переменную неустановленной.
.TP 8
.B histchars
Строковое значение, определяющее символы, используемые
в \fBHistory substitution\fR (см. выше). Первый символ значения
используется как символ для замены в истории, заменяя
символ по умолчанию `!`. Второй символ заменяет
символ `^` в быстрых заменах.
.TP 8
.B histdup \fR(+)
Управляет обработкой дубликатов в списке истории.
Если установлено в значение `all`, в список истории
добавляются только уникальные события.
Если установлено в значение `prev` и последнее
событие истории совпадает с текущей командой,
то текущая команда не добавляется в историю.
Если установлено в значение `erase`, и в списке
истории найдено такое же событие, старое событие
удаляется, а новое добавляется. Обратите внимание,
что параметры `prev` и `all` перенумеровывают
события истории, чтобы не было пропусков.
.TP 8
.B histfile \fR(+)
Местоположение по умолчанию, в которое команды
`history \-S` и `history \-L` ищут файл истории.
Если не установлено, используется \fI~/.history\fR.
Переменная \fBhistfile\fR полезна при использовании
одного домашнего каталога на разных машинах или при
сохранении отдельных историй на разных терминалах.
Так как только \fI~/.tcshrc\fR обычно обрабатывается
до \fI~/.history\fR, переменную \fBhistfile\fR следует
устанавливать в \fI~/.tcshrc\fR, а не в \fI~/.login\fR.
.TP 8
.B histlit \fR(+)
Если установлено, встроенные команды и команды редактора,
а также механизм \fBsavehist\fR используют буквальную
(неразвернутую) форму строк в списке истории. См. также
команду редактора \fItoggle-literal-history\fR.
.TP 8
.B history
Первое слово указывает количество событий истории для
сохранения. Необязательное второе слово (+) указывает
формат, в котором печатается история; если не указано,
используется `%h\et%T\et%R\en`. Описание форматов
см. ниже в разделе \fBprompt\fR; обратите внимание на
переменное значение `%R`. По умолчанию установлено
значение `100`.
.TP 8
.B home
Инициализируется домашним каталогом вызывающего.
Расширение имени файла `\fI~\fR` ссылается на эту
переменную.
.TP 8
.B ignoreeof
Если установлено в пустую строку или `0`, и устройство
ввода является терминалом, команда \fIend-of-file\fR
(обычно вызывается пользователем нажатием `^D` на пустой
строке) заставляет оболочку вывести сообщение
`Используйте "exit" для выхода из tcsh.`, вместо
завершения работы. Это предотвращает случайное завершение
оболочки. Исторически эта настройка завершалась после 26
последовательных EOF, чтобы избежать бесконечных циклов.
Если установлено в число \fIn\fR, оболочка игнорирует
\fIn - 1\fR последовательных \fIend-of-file\fRs и
завершает работу на \fIn\fR-м. (+) Если не установлено,
используется значение `1`, т.е. оболочка завершает работу
после одного нажатия `^D`.
.TP 8
.B implicitcd \fR(+)
Если установлено, оболочка обрабатывает введенное имя
каталога как команду для перехода в этот каталог.
Если установлено в \fIverbose\fR, переход в каталог
выводится на стандартный вывод. Это поведение подавляется
в неинтерактивных скриптах оболочки или для строк команд,
содержащих более одного слова. Переход в каталог имеет
приоритет над выполнением команды с таким же именем, но
выполняется после подстановок алиасов. Расширения тильды
и переменных работают, как и ожидалось.
.TP 8
.B inputmode \fR(+)
Если установлено в `insert` или `overwrite`, редактор
переключается в этот режим ввода в начале каждой строки.
.TP 8
.B killdup \fR(+)
Управляет обработкой дубликатов в кольце уничтоженных строк.
Если установлено в `all`, в кольцо уничтоженных строк
добавляются только уникальные строки. Если установлено
в `prev` и последняя уничтоженная строка совпадает с текущей
уничтоженной строкой, то текущая строка не добавляется в кольцо.
Если установлено в `erase`, и такая же строка найдена в кольце,
старая строка удаляется, а новая вставляется.
.TP 8
.B killring \fR(+)
Указывает количество уничтоженных строк, которые
сохраняются в памяти. По умолчанию установлено значение `30`.
Если не установлено или установлено значение меньше `2`,
оболочка будет сохранять только последнюю уничтоженную строку.
Строки добавляются в killring с помощью команд редактора,
которые удаляют (уничтожают) строки текста, например,
\fIbackward-delete-word\fR, \fIkill-line\fR и т.д.,
а также с помощью команды \fIcopy-region-as-kill\fR.
Команда редактора \fIyank\fR вставляет последнюю уничтоженную
строку в командную строку, а команда \fIyank-pop\fR
(см. \fBEditor commands\fR) позволяет вставлять ранее
уничтоженные строки.
.TP 8
.B listflags \fR(+)
Если установлено в `x`, `a` или `A`, или их комбинацию
(например, `xA`), они используются как флаги для \fIls\-F\fR,
заставляя его действовать как `ls \-xF`, `ls \-Fa`, `ls \-FA`
или их комбинацию (например, `ls \-FxA`): `a` отображает все
файлы (даже если они начинаются с `.`), `A` отображает все файлы,
кроме `.` и `..`, а `x` сортирует по строкам, а не по столбцам.
Если второе слово переменной \fBlistflags\fR установлено,
оно используется как путь к `ls(1)`.
.TP 8
.B listjobs \fR(+)
Если установлено, все задачи выводятся при их приостановке.
Если установлено в `long`, вывод осуществляется в длинном формате.
.TP 8
.B listlinks \fR(+)
Если установлено, встроенная команда \fIls\-F\fR отображает
тип файла, на который указывает каждая символическая ссылка.
.TP 8
.B listmax \fR(+)
Максимальное количество элементов, которое команда редактора
\fIlist-choices\fR выведет без запроса.
.TP 8
.B listmaxrows \fR(+)
Максимальное количество строк элементов, которое команда
редактора \fIlist-choices\fR выведет без запроса.
.TP 8
.B loginsh \fR(+)
Устанавливается оболочкой, если она является оболочкой
входа в систему. Установка или сброс этой переменной в
оболочке не имеет эффекта. См. также переменную \fBshlvl\fR.
.TP 8
.B logout \fR(+)
Устанавливается оболочкой в значение `normal` перед нормальным
завершением сеанса, в значение `automatic` перед автоматическим
завершением сеанса и в значение `hangup`, если оболочка была
завершена сигналом hangup (см. \fBSignal handling\fR).
См. также переменную оболочки \fBautologout\fR.
.TP 8
.B mail
Список файлов и каталогов, которые проверяются на наличие
новой почты, возможно с указанием интервала времени в начале.
Перед каждым запросом, если с момента последней проверки
прошло 10 минут, оболочка проверяет каждый файл и выводит
сообщение `У вас новое письмо.` (или, если в переменной
\fBmail\fR указано несколько файлов, выводит `У вас новое
письмо в \fIname\fR.`), если размер файла больше нуля и
время его модификации больше времени последнего доступа.
.PP
.RS +8
.PD
.PP
Если вы находитесь в оболочке входа, никакие почтовые файлы
не сообщаются, если они не были изменены после запуска оболочки,
чтобы избежать избыточных уведомлений. Большинство программ входа
сообщают вам, есть ли у вас почта, при входе в систему.
.PP
Если файл, указанный в переменной \fBmail\fR, является каталогом,
оболочка будет учитывать каждый файл внутри этого каталога как
отдельное сообщение и сообщать `У вас \fIn\fR новых писем.`
или `У вас \fIn\fR новых писем в \fIname\fR.` по мере необходимости.
Эта функция предназначена в основном для систем, хранящих почту
таким образом, как, например, почтовая система Andrew Mail System.
.PP
Если первое слово в переменной \fBmail\fR — это число, оно
воспринимается как другой интервал проверки почты в секундах.
.PP
В очень редких случаях оболочка может сообщить `У вас почта.`,
а не `У вас новое письмо.`
.RE
.TP 8
.B matchbeep \fR(+)
Если установлено в `never`, автозавершение никогда не издает
звуковой сигнал.
Если установлено в `nomatch`, звуковой сигнал издается
только при отсутствии совпадений.
Если установлено в `ambiguous`, звуковой сигнал издается,
если есть несколько совпадений.
Если установлено в `notunique`, звуковой сигнал издается,
если есть точное совпадение, но есть и другие более 
линные совпадения.
Если не установлено, используется значение `ambiguous`.
.TP 8
.B nobeep \fR(+)
Если установлено, звуковые сигналы полностью отключены.
См. также переменную \fBvisiblebell\fR.
.TP 8
.B noclobber
Если установлено, накладываются ограничения на
перенаправление вывода, чтобы избежать случайного
уничтожения файлов, и перенаправления `>>`
применяются только к существующим файлам,
как описано в разделе \fBInput/output\fR.
.TP 8
.B noding
Если установлено, отключается вывод сообщения
`DING!` в спецификаторах времени \fBprompt\fR
при смене часа.
.TP 8
.B noglob
Если установлено, \fBFilename substitution\fR и \fB
Подстановка стека каталогов\fR (см. выше) отключаются.
Это полезно в сценариях оболочки, которые не работают
с именами файлов, или после получения списка имен файлов,
когда дальнейшие расширения нежелательны.
.TP 8
.B nokanji \fR(+)
Если установлено, и оболочка поддерживает Kanji
(см. переменную \fBversion\fR), эта поддержка
отключается, чтобы можно было использовать мета-клавишу.
.TP 8
.B nonomatch
Если установлено, подстановка имен файлов или стека
каталогов (см. выше), которая не соответствует
существующим файлам, остается без изменений, а не
вызывает ошибку. Это все еще ошибка, если подстановка
некорректна, например, команда `echo [` все равно
вызовет ошибку.
.TP 8
.B nostat \fR(+)
Список каталогов (или шаблонов, соответствующих
каталогам; см. \fBFilename substitution\fR),
которые не должны проверяться с помощью \fIstat\fR(2)
во время операции завершения. Обычно используется для
исключения каталогов, проверка которых с помощью
\fIstat\fR(2) занимает слишком много времени,
например, \fI/afs\fR.
.TP 8
.B notify
Если установлено, оболочка асинхронно сообщает
о завершении задач. По умолчанию сообщения о
завершении задач выводятся перед выводом
следующего запроса.
.TP 8
.B oid \fR(+)
Идентификатор реальной организации пользователя.
(Только для Domain/OS)
.TP 8
.B owd \fR(+)
Старый рабочий каталог, эквивалентный символу `\-'
в командах \fIcd\fR и \fIpushd\fR.
См. также переменные оболочки \fBcwd\fR
и \fBdirstack\fR.
.TP 8
.B padhour
Если установлено, включает вывод ведущих нулей
для часов в 24- и 12-часовых форматах.
Например: 07:45:42 против 7:45:42.
.TP 8
.B parseoctal
Для совместимости с более старыми версиями
числовые переменные, начинающиеся с 0, не
интерпретируются как восьмеричные.
Установка этой переменной включает
правильный разбор восьмеричных чисел.
.TP 8
.B path
Список каталогов, в которых ищутся исполняемые команды.
Пустое слово указывает текущий каталог.
Если переменная \fBpath\fR не установлена,
будут выполняться только команды с полными путями.
\fBpath\fR устанавливается оболочкой при запуске
из переменной окружения \fBPATH\fR или, если переменная
\fBPATH\fR не существует, в системно-зависимое значение
по умолчанию,
например `(/usr/local/bin /usr/bsd /bin /usr/bin .)'.
Оболочка может поставить `.' первым, последним или
полностью исключить его из \fBpath\fR в зависимости
от того, как она была скомпилирована;
см. переменную оболочки \fBversion\fR.
Оболочка, которой не передан параметр
\fB\-c\fR или \fB\-t\fR, хэширует содержимое каталогов
в \fBpath\fR после чтения \fI~/.tcshrc\fR и каждый раз
при сбросе \fBpath\fR.
Если добавить новую команду в каталог, указанный в
\fBpath\fR, пока оболочка активна, может понадобиться
выполнить команду \fIrehash\fR, чтобы оболочка ее
обнаружила.
.TP 8
.B printexitvalue \fR(+)
Если установлено и интерактивная программа
завершается с ненулевым статусом, оболочка
выводит `Exit \fBstatus\fR'.
.TP 8
.B prompt
Строка, которая выводится перед чтением каждой
команды с терминала. \fBprompt\fR может включать
следующие последовательности форматирования (+),
которые заменяются соответствующей информацией:
.PP
.RS +8
.PD 0
.TP 4
%/
Текущий рабочий каталог.
.TP 4
%~
Текущий рабочий каталог, но с представлением
домашнего каталога в виде `~' и домашними каталогами
других пользователей в виде `~user' согласно
\fBFilename substitution\fR. Подстановка `~user'
выполняется только если оболочка уже использовала
`~\fIuser\fR' в пути в текущем сеансе.
.TP 4
%c[[0]\fIn\fR], %.[[0]\fIn\fR]
Последний компонент текущего рабочего каталога
или \fIn\fR последних компонентов, если указана
цифра \fIn\fR. Если \fIn\fR начинается с `0',
перед последними компонентами указывается количество
пропущенных компонентов в формате
`/<\fIskipped\fR>trailing'.
Если установлена переменная оболочки \fBellipsis\fR,
пропущенные компоненты отображаются многоточием,
и вся строка выглядит как `...trailing'.
Подстановка `~' выполняется так же, как и для `%~',
но компонент `~' игнорируется при подсчете последних
компонентов.
.TP 4
%C
Как %c, но без подстановки `~'.
.TP 4
%h, %!, !
Номер текущего события истории.
.TP 4
%M
Полное имя хоста.
.TP 4
%m
Имя хоста до первой `.'.
.TP 4
%S (%s)
Включить (выключить) режим выделения.
.TP 4
%B (%b)
Включить (выключить) полужирный режим.
.TP 4
%U (%u)
Включить (выключить) режим подчеркивания.
.TP 4
%t, %@
Время суток в 12-часовом формате AM/PM.
.TP 4
%T
Как `%t', но в 24-часовом формате
(см. переменную оболочки \fBampm\fR).
.TP 4
%p
Точное время суток в 12-часовом формате AM/PM,
с секундами.
.TP 4
%P
Как `%p', но в 24-часовом формате
(см. переменную оболочки \fBampm\fR).
.TP 4
\e\fIc\fR
\fIc\fR интерпретируется, как в \fIbindkey\fR.
.TP 4
^\fIc\fR
\fIc\fR интерпретируется, как в \fIbindkey\fR.
.TP 4
%%
Один символ `%'.
.TP 4
%n
Имя пользователя.
.TP 4
%N
Эффективное имя пользователя.
.TP 4
%j
Количество задач.
.TP 4
%d
День недели в формате `Day'.
.TP 4
%D
День в формате `dd'.
.TP 4
%w
Месяц в формате `Mon'.
.TP 4
%W
Месяц в формате `mm'.
.TP 4
%y
Год в формате `yy'.
.TP 4
%Y
Год в формате `yyyy'.
.TP 4
%l
tty оболочки.
.TP 4
%L
Очищает от конца запроса до конца экрана
или конца строки.
.TP 4
%$
Раскрывает имя переменной оболочки или окружения
сразу после символа `$'.
.TP 4
%#
`>' (или первый символ переменной Оболочки
\fBpromptchars\fR) для обычных пользователей,
`#' (или второй символ переменной \fBpromptchars\fR)
для суперпользователя.
.TP 4
%{\fIstring\fR%}
Включает \fIstring\fR как буквальную последовательность
экранирования.
Это должно использоваться только для изменения атрибутов
терминала и не должно перемещать курсор. Это не может быть
последней последовательностью в \fBprompt\fR.
.TP 4
%?
КОД ЗАВЕРШЕНИЯ команды, выполненной непосредственно
перед запросом.
.TP 4
%R
В \fBprompt2\fR — состояние парсера.
В \fBprompt3\fR — исправленная строка.
В \fBhistory\fR — строка истории.
.PD
.PP
`%B', `%S', `%U' и `%{\fIstring\fR%}' доступны только
в оболочках с поддержкой восьмибитной чистоты;
см. переменную \fBversion\fR.
.PP
Полужирные, выделенные и подчеркнутые последовательности
часто используются для обозначения оболочки
суперпользователя. Например,
.IP "" 4
> set prompt = "%m [%h] %B[%@]%b [%/] вы позвали? "
.br
tut [37] \fB[2:54pm]\fR [/usr/accts/sys] вы позвали? _
.PP
Если используются `%t', `%@', `%T', `%p' или `%P',
и переменная \fBnoding\fR не установлена,
то выводится `DING!' при смене часа
(т.е. при `:00' минутах) вместо фактического времени.
.PP
По умолчанию установлено значение `%# '
в интерактивных оболочках.
.RE
.TP 8
.B prompt2 \fR(+)
Строка, используемая для запроса в циклах
\fIwhile\fR и \fIforeach\fR, а также после строк,
заканчивающихся на `\e'.
Можно использовать те же последовательности
форматирования, что и в \fBprompt\fR (см. выше);
обратите внимание на переменное значение `%R'.
По умолчанию установлено значение `%R? '
в интерактивных оболочках.
.TP 8
.B prompt3 \fR(+)
Строка, используемая для запроса при подтверждении
автоматической коррекции орфографии.
Можно использовать те же последовательности
форматирования, что и в \fBprompt\fR (см. выше);
обратите внимание на переменное значение `%R'.
По умолчанию установлено значение
`CORRECT>%R (y|n|e|a)? ' в интерактивных оболочках.
.TP 8
.B promptchars \fR(+)
Если установлено (в строку из двух символов),
последовательность форматирования `%#' в
переменной оболочки \fBprompt\fR заменяется
на первый символ для обычных пользователей
и второй символ для суперпользователя.
.TP 8
.B pushdtohome \fR(+)
Если установлено, команда \fIpushd\fR без
аргументов выполняет `pushd ~',
как команда \fIcd\fR.
.TP 8
.B pushdsilent \fR(+)
Если установлено, команды \fIpushd\fR
и \fIpopd\fR не выводят стек каталогов.
.TP 8
.B recexact \fR(+)
Если установлено, автозавершение выполняется
по точному совпадению, даже если возможно
более длинное совпадение.
.TP 8
.B recognize_only_executables \fR(+)
Если установлено, при выводе списка команд
отображаются только файлы в пути, которые
являются исполняемыми. Это медленно.
.TP 8
.B rmstar \fR(+)
Если установлено, пользователь запрашивается
перед выполнением команды `rm *'.
.TP 8
.B rprompt \fR(+)
Строка, которая выводится на правой стороне
экрана (после ввода команды) при отображении
запроса на левой стороне.
Она распознает те же символы форматирования,
что и переменная \fBprompt\fR.
Она автоматически исчезает и появляется по
мере необходимости, чтобы гарантировать,
что ввод команд не перекрывается, и появляется
только в том случае, если запрос, ввод команд
и сама строка поместятся на первой строке.
Если переменная \fBedit\fR не установлена,
тогда \fBrprompt\fR будет выводиться после
запроса и перед вводом команды.
.TP 8
.B savedirs \fR(+)
Если установлено, оболочка выполняет `dirs \-S'
перед выходом.
Если первое слово установлено в число,
сохраняется не более этого количества записей
стека каталогов.
.TP 8
.B savehist
Если установлено, оболочка выполняет команду
`history \-S` перед завершением работы.
Если первое слово установлено как число,
сохраняется не более этого количества строк.
(Число должно быть меньше или равно количеству
записей в \fBhistory\fR;
если установлено больше, чем количество настроек
\fBhistory\fR, сохраняются только записи
\fBhistory\fR)
Если второе слово установлено как `merge`,
список истории объединяется с существующим
файлом истории вместо его замены (если такой
файл существует) и сортируется по меткам времени,
причем сохраняются самые последние события.
Если второе слово переменной
\fBsavehist\fR — `merge`, а третье — `lock`,
то обновление файла истории будет синхронизировано
с другими сессиями оболочки, которые могут также
пытаться обновить историю в одно и то же время. (+)
.TP 8
.B sched \fR(+)
Формат, в котором встроенная команда \fIsched\fR
выводит запланированные события; если не указан,
используется `%h\et%T\et%R\en`.
Последовательности форматов описаны выше в разделе
\fBprompt\fR; обратите внимание на
переменное значение `%R`.
.TP 8
.B shell
Файл, в котором находится оболочка.
Используется в форкинговых оболочках
для интерпретации файлов, у которых
установлены биты выполнения, но которые
не могут быть выполнены системой.
(См. описание \fBBuiltin and non-builtin command execution\fR.) Инициализируется в системно-зависимом
домашнем каталоге оболочки.
.TP 8
.B shlvl \fR(+)
Количество вложенных оболочек.
Сбрасывается в 1 в оболочках входа.
См. также переменную \fBloginsh\fR.
.TP 8
.B status
Код завершения последней команды или подстановки
с обратными кавычками, либо код завершения любой
команды в конвейере передается переменной \fBstatus\fR.
(Это также поведение по умолчанию в \fBcsh\fR.)
Это поведение не соответствует тому, что требует POSIX
(возвращать код завершения только последней команды).
Чтобы соответствовать поведению POSIX, нужно сбросить
переменную \fBanyerror\fR.
.RS +8
.PP
Если переменная \fBanyerror\fR сброшена, код завершения
конвейера определяется только по последней команде в
конвейере, и код завершения подстановки с обратными
кавычками \fIне\fR передается переменной \fBstatus\fR.
.PP
Если команда завершена с ошибкой, к статусу
добавляется 0200. Неудачные встроенные команды
возвращают код завершения `1`, все остальные
встроенные команды возвращают статус `0`.
.RE
.TP 8
.B symlinks \fR(+)
Может быть установлена на несколько значений для
управления разрешением символических ссылок (`symlink`):
.RS +8
.PP
Если установлено как `chase`, то при каждом изменении
текущего каталога на каталог, содержащий символическую
ссылку, она расширяется до реального имени каталога,
на который указывает ссылка. Это не работает для
домашнего каталога пользователя; это ошибка.
.PP
Если установлено как `ignore`, оболочка пытается
построить текущий каталог относительно текущего
каталога до пересечения ссылки.
Это означает, что выполнение \fIcd\fR через
символическую ссылку и затем выполнение `cd ..`
возвращает в исходный каталог. Это влияет только
на встроенные команды и автодополнение имен файлов.
.PP
Если установлено как `expand`, оболочка пытается
исправить символические ссылки, фактически расширяя
аргументы, которые выглядят как пути.
Это влияет на любую команду, а не только на встроенные.
К сожалению, это не работает для трудно распознаваемых
имен файлов, например, встроенных в параметры команд.
Расширение можно предотвратить, используя кавычки.
Хотя эта настройка обычно наиболее удобна, она иногда
вводит в заблуждение и сбивает с толку, когда не удается
распознать аргумент, который должен быть расширен.
Компромиссным решением является использование `ignore`
и использование команды редактора \fInormalize-path\fR
(по умолчанию привязана к ^X-n) при необходимости.
.PP
Примеры:
.IP "" 4
> cd /tmp
.br
> mkdir from from/src to
.br
> ln \-s from/src to/dst
.PP
Вот поведение с переменной \fBsymlinks\fR, сброшенной:
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ..; echo $cwd
.br
/tmp/from
.PP
Поведение с \fBsymlinks\fR, установленной в `chase`:
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/from/src
.br
> cd ..; echo $cwd
.br
/tmp/from
.PP
Поведение с \fBsymlinks\fR, установленной в `ignore`:
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ..; echo $cwd
.br
/tmp/to
.PP
И поведение с \fBsymlinks\fR, установленной в `expand`:
.IP "" 4
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ..; echo $cwd
.br
/tmp/to
.br
> cd /tmp/to/dst; echo $cwd
.br
/tmp/to/dst
.br
> cd ".."; echo $cwd
.br
/tmp/from
.br
> /bin/echo ..
.br
/tmp/to
.br
> /bin/echo ".."
.br
\&..
.PP
Обратите внимание, что расширение `expand`
1) работает так же, как `ignore` для встроенных
команд, таких как \fIcd\fR,
2) предотвращается с помощью кавычек, и
3) происходит до передачи имен файлов командам,
не являющимся встроенными.
.RE
.TP 8
.B tcsh \fR(+)
Версия оболочки в формате `R.VV.PP`,
где `R` — это номер основного релиза,
`VV` — текущая версия
и `PP` — номер патча.
.TP 8
.B term
Тип терминала. Обычно устанавливается в
\fI~/.login\fR, как описано в разделе
\fBStartup and shutdown\fR.
.TP 8
.B time
Если установлено как число, то встроенная
команда \fItime\fR (см. q.v.) выполняется
автоматически после каждой команды, которая
занимает более этого количества секунд процессора.
Если есть второе слово, оно используется в качестве
строки формата для вывода встроенной команды
\fItime\fR. (u) В строке формата можно использовать
следующие последовательности:
.PP
.RS +8
.PD 0
.TP 4
%U
Время, проведенное процессом в пользовательском
режиме, в секундах процессора.
.TP 4
%S
Время, проведенное процессом в режиме ядра,
в секундах процессора.
.TP 4
%E
Прошедшее (время на стене) время в секундах.
.TP 4
%P
Процент использования ЦПУ, вычисленный как
(%U + %S) / %E.
.TP 4
%W
Количество раз, когда процесс был выгружен
из памяти.
.TP 4
%X
Среднее количество используемого общего
текстового пространства в Кбайтах.
.TP 4
%D
Среднее количество используемого неразделяемого
пространства данных/стека в Кбайтах.
.TP 4
%K
Общее используемое пространство (%X + %D) в Кбайтах.
.TP 4
%M
Максимальный объем памяти, использованный
процессом в любой момент, в Кбайтах.
.TP 4
%F
Количество серьезных ошибок страниц (страница,
которая должна быть загружена с диска).
.TP 4
%R
Количество незначительных ошибок страниц.
.TP 4
%I
Количество операций ввода.
.TP 4
%O
Количество операций вывода.
.TP 4
%r
Количество принятых сообщений сокета.
.TP 4
%s
Количество отправленных сообщений сокета.
.TP 4
%k
Количество полученных сигналов.
.TP 4
%w
Количество добровольных переключений
контекста (ожиданий).
.TP 4
%c
Количество недобровольных переключений контекста.
.PD
.PP
Только первые четыре последовательности
поддерживаются на системах без функций
ограничения ресурсов BSD.
Формат времени по умолчанию:
`%Uu %Ss %E %P %X+%Dk %I+%Oio %Fpf+%Ww` для систем,
поддерживающих отчет об использовании ресурсов,
и `%Uu %Ss %E %P` для систем, которые этого не делают.
.PP
В системе DYNIX/ptx от Sequent, %X, %D, %K, %r и %s
недоступны, но доступны следующие дополнительные
последовательности:
.PP
.PD 0
.TP 4
%Y
Количество выполненных системных вызовов.
.TP 4
%Z
Количество страниц, заполненных нулями
по требованию.
.TP 4
%i
Количество увеличений размера резидентного
набора процесса ядром.
.TP 4
%d
Количество уменьшений размера резидентного
набора процесса ядром.
.TP 4
%l
Количество выполненных системных
вызовов на чтение.
.TP 4
%m
Количество выполненных системных
вызовов на запись.
.TP 4
%p
Количество чтений с небуферизованных устройств.
.TP 4
%q
Количество записей на небуферизованные устройства.
.PD
.PP
и формат времени по умолчанию:
`%Uu %Ss %E %P %I+%Oio %Fpf+%Ww`.
Обратите внимание, что процент
использования ЦПУ может быть выше
100% на многопроцессорных системах.
.RE
.TP 8
.B tperiod \fR(+)
Период, в минутах, между выполнениями
специального псевдонима \fIperiodic\fR.
.TP 8
.B tty \fR(+)
Имя терминала, или пустая строка,
если не подключен к терминалу.
.TP 8
.B uid \fR(+)
Реальный идентификатор пользователя.
.TP 8
.B user
Имя пользователя, под которым выполнен вход.
.TP 8
.B verbose
Если установлено, печатает слова каждой
команды после подстановки из истории
(если она есть).
Устанавливается параметром командной
строки \fB\-v\fR.
.TP 8
.B version \fR(+)
Штамп версии. Содержит номер версии
оболочки (см. \fBtcsh\fR), происхождение,
дату выпуска, поставщика, операционную
систему и машину
(см. \fBVENDOR\fR, \fBOSTYPE\fR и \fBMACHTYPE\fR),
а также через запятую список параметров, установленных
при компиляции.
Параметры, установленные по умолчанию в
дистрибутиве, отмечены.
.PP
.RS +8
.PD 0
.TP 6
8b
Оболочка поддерживает 8-битные символы;
установлено по умолчанию
.TP 6
7b
Оболочка не поддерживает 8-битные символы
.TP 6
wide
Оболочка поддерживает многобайтовую кодировку
(например, UTF-8)
.TP 6
nls
Используется NLS системы; по умолчанию
для систем с NLS
.TP 6
lf
Входные оболочки выполняют
\fI/etc/csh.login\fR до вместо после
\fI/etc/csh.cshrc\fR и \fI~/.login\fR
до вместо после \fI~/.tcshrc\fR и
\fI~/.history\fR.
.TP 6
dl
`.' помещается последним в \fBpath\fR
для безопасности; установлено по умолчанию
.TP 6
nd
`.' исключен из \fBpath\fR для безопасности
.TP 6
vi
Редактирование в стиле \fIvi\fR(1) используется
по умолчанию, а не в стиле \fIemacs\fR(1)
.TP 6
dtr
При выходе из системы оболочка опускает DTR
.TP 6
bye
\fIbye\fR является синонимом для \fIlogout\fR,
а \fIlog\fR является альтернативным именем
для \fIwatchlog\fR
.TP 6
al
\fBautologout\fR включен; установлено по умолчанию
.TP 6
kan
Используется канжи, если это уместно согласно
настройкам локали, если только не установлена
переменная оболочки \fBnokanji\fR
.TP 6
sm
Используется системная библиотека \fImalloc\fR(3)
.TP 6
hb
Эмулируется конвенция `#!<program> <args>' при
выполнении сценариев оболочки
.TP 6
ng
Доступна встроенная команда \fInewgrp\fR
.TP 6
rh
Оболочка пытается установить переменную окружения
\fBREMOTEHOST\fR
.TP 6
afs
Оболочка проверяет ваш пароль на сервере Kerberos,
если локальная аутентификация не удалась.
Переменные оболочки \fBafsuser\fR или окружения
\fBAFSUSER\fR переопределяют ваше локальное имя
пользователя, если они установлены.
.PD
.PP
Администратор может добавить дополнительные строки,
чтобы указать различия в локальной версии.
.RE
.TP 8
.B vimode \fR(+)
.RS +8
Если не установлено, поведение некоторых привязок
клавиш изменяется в более подобный стиль
\fBemacs\fR(1): границы слов определяются на
основе \fBwordchars\fR по сравнению с другими
символами.
.PP
Если установлено, различные привязки клавиш
изменяют поведение, приближая его к стилю \fBvi\fR(1):
границы слов определяются на основе \fBwordchars\fR,
пробелов и других символов;
поведение курсора зависит от текущего режима vi
(командный, удаление, вставка, замена).
.PP
Эта переменная сбрасывается при выполнении команды
\fIbindkey\fR \fB-e\fR и
устанавливается командой \fIbindkey\fR \fB-v\fR.
.B vimode
может быть явно установлен или сброшен пользователем
после выполнения этих операций \fIbindkey\fR,
если требуется.
.RE
.TP 8
.B visiblebell \fR(+)
Если установлено, вместо звукового сигнала
используется мигание экрана.
См. также \fBnobeep\fR.
.TP 8
.B watch \fR(+)
Список пар пользователь/терминал для отслеживания
входов и выходов. Если указан `any` для пользователя,
отслеживаются все терминалы для указанного пользователя
и наоборот. Установка \fBwatch\fR в `(any any)'
отслеживает всех пользователей и терминалы.
Например,
.RS +8
.IP "" 4
set watch = (george ttyd1 any console $user any)
.PP
сообщает о действиях пользователя `george' на ttyd1,
любого пользователя на консоли и
о себе (или о злоумышленнике) на любом терминале.
.PP
Входы и выходы проверяются каждые 10 минут по умолчанию,
но первое слово в \fBwatch\fR можно установить в число,
чтобы задавать интервал проверки в минутах.
Например,
.IP "" 4
set watch = (1 any any)
.PP
сообщает о любом входе/выходе каждую минуту.
Для нетерпеливых команда \fIlog\fR
встроенной функции инициирует отчет \fBwatch\fR
в любое время. Все текущие входы
сообщаются (как при использовании встроенной
функции \fIlog\fR), когда \fBwatch\fR установлен впервые.
.PP
Переменная оболочки \fBwho\fR контролирует формат
отчетов \fBwatch\fR.
.RE
.TP 8
.B who \fR(+)
Строка формата для сообщений \fBwatch\fR.
Следующие последовательности
заменяются на соответствующую информацию:
.PP
.RS +8
.PD 0
.TP 4
%n
Имя пользователя, вошедшего или вышедшего.
.TP 4
%a
Наблюдаемое действие, т.е., `вошел', `вышел'
или `заменил \fIolduser\fR на'.
.TP 4
%l
Терминал (tty), на котором пользователь вошел или вышел.
.TP 4
%M
Полное имя удаленного хоста, или `local',
если вход/выход был с локального хоста.
.TP 4
%m
Имя удаленного хоста до первого символа `.'.
Полное имя отображается, если это IP-адрес
или дисплей X Window System.
.PD
.PP
%M и %m доступны только на системах,
где удаленное имя хоста сохраняется в
\fI/etc/utmp\fR.
Если не установлено, используется
`%n has %a %l from %m.', или `%n has %a %l.'
в системах, которые не сохраняют удаленное имя хоста.
.RE
.TP 8
.B wordchars \fR(+)
Список неалфавитных символов, которые считаются
частью слова для команд редактора \fIforward-word\fR,
\fIbackward-word\fR и других. Если не установлено,
значение по умолчанию определяется на основе состояния
\fBvimode\fR: если \fBvimode\fR не установлен,
используется `*?_\-.[]~=' по умолчанию;
если \fBvimode\fR установлен, используется `_' по умолчанию.
.SH ОКРУЖЕНИЕ
.TP 8
.B AFSUSER \fR(+)
Эквивалент переменной оболочки \fBafsuser\fR.
.TP 8
.B COLUMNS
Число колонок в терминале. См. \fBTerminal management\fR.
.TP 8
.B DISPLAY
Используется системой X Window (см. \fIX\fR(1)).
Если установлено, оболочка не устанавливает
\fBautologout\fR (см. там же).
.TP 8
.B EDITOR
Путь к редактору по умолчанию.
Используется командой редактора \fIrun-fg-editor\fR,
если переменная
\fBeditors\fR не установлена.
См. также переменную окружения \fBVISUAL\fR.
.TP 8
.B GROUP \fR(+)
Эквивалент переменной оболочки \fBgroup\fR.
.TP 8
.B HOME
Эквивалент переменной оболочки \fBhome\fR.
.TP 8
.B HOST \fR(+)
Инициализируется именем машины, на которой
запущена оболочка, как это определяется
системным вызовом \fIgethostname\fR(2).
.TP 8
.B HOSTTYPE \fR(+)
Инициализируется типом машины, на которой
запущена оболочка, как это определяется на
этапе компиляции. Эта переменная устарела
и будет удалена в будущей версии.
.TP 8
.B HPATH \fR(+)
Список каталогов, разделенных двоеточиями,
в которых команда редактора \fIrun-help\fR
ищет документацию по командам.
.TP 8
.B LANG
Задает предпочтительную языковую среду.
См. \fBNative Language System support\fR.
.TP 8
.B LC_CTYPE
Если установлено, изменяется только обработка
символов типа ctype.
См. \fBNative Language System support\fR.
.TP 8
.B LINES
Число строк в терминале.
См. \fBTerminal management\fR.
.TP 8
.B LS_COLORS
Формат этой переменной напоминает формат
файла \fBtermcap(5)\fR;
список выражений, разделенных двоеточием,
вида "\fIxx=строка\fR", где "\fIxx\fR" — это имя
переменной из двух символов.
Переменные с их значениями по умолчанию:
.PP
.RS +8
.RS +4
.PD 0
.TP 12
no	0
Текст без специальных обозначений (не имя файла)
.TP 12
fi	0
Обычный файл
.TP 12
di	01;34
Каталог
.TP 12
ln	01;36
Символическая ссылка
.TP 12
pi	33
Именованный канал (FIFO)
.TP 12
so	01;35
Сокет
.TP 12
do	01;35
Дверь
.TP 12
bd	01;33
Блочное устройство
.TP 12
cd	01;32
Символьное устройство
.TP 12
ex	01;32
Исполняемый файл
.TP 12
mi	(нет)
Отсутствующий файл (по умолчанию fi)
.TP 12
or	(нет)
Оставленная символическая ссылка (по умолчанию ln)
.TP 12
lc	^[[
Левый код
.TP 12
rc	m
Правый код
.TP 12
ec	(нет)
Конечный код (заменяет lc+no+rc)
.PD
.RE
.PP
Вам нужно включить только те переменные, которые вы
хотите изменить по сравнению с значениями по умолчанию.
.PP
Имена файлов также могут быть окрашены на основе
расширения имени файла.
Это указывается в переменной \fBLS_COLORS\fR с
использованием синтаксиса
\fB"ext=string"\fR. Например, используя коды
ISO 6429, чтобы окрасить все файлы на языке C
в синий цвет, вы укажете \fB".c=34"\fR.
Это окрасит все файлы, оканчивающиеся на \fB.c\fR,
в синий цвет (34).
.PP
Символы управления могут быть записаны либо в
C-стиле с экранированием, либо в стиле stty
с ^-нотацией. Нотация C-стиля добавляет
\fB^[\fR для Escape, \fB_\fR для обычного пробела,
и \fB?\fR для Delete. Кроме того, символ
\fB^[\fR escape может быть использован для
переопределения стандартной интерпретации
\fB^[\fR, \fB^\fR, \fB:\fR и \fB=\fR.
.PP
Каждый файл будет записан как
\fB<lc>\fR \fB<color-code>\fR
\fB<rc>\fR \fB<filename>\fR
\fB<ec>\fR. Если код \fB<ec>\fR
не определен, вместо этого будет
использована последовательность
\fB<lc>\fR \fB<no>
\fB<rc>\fR. Это, как правило, более удобно
для использования, но менее универсально.
Левые, правые и конечные коды предоставляются,
чтобы вам не приходилось набирать общие части
снова и снова, а также для поддержки
нестандартных терминалов; вам, вероятно,
не нужно изменять их, если ваш терминал
не использует цветовые последовательности
ISO 6429, а другую систему.
.PP
Если ваш терминал использует цветовые коды
ISO 6429, вы можете составить типы кодов
(т.е. все, кроме кодов \fBlc\fR, \fBrc\fR,
и \fBec\fR) из числовых команд, разделенных
точками с запятой. Наиболее распространенные команды:
.PP
.RS +8
.PD 0
.TP 4
0
восстановить стандартный цвет
.TP 4
1
для более ярких цветов
.TP 4
4
для подчеркнутого текста
.TP 4
5
для мигающего текста
.TP 4
30
для черного переднего плана
.TP 4
31
для красного переднего плана
.TP 4
32
для зеленого переднего плана
.TP 4
33
для желтого (или коричневого) переднего плана
.TP 4
34
для синего переднего плана
.TP 4
35
для фиолетового переднего плана
.TP 4
36
для голубого переднего плана
.TP 4
37
для белого (или серого) переднего плана
.TP 4
40
для черного фона
.TP 4
41
для красного фона
.TP 4
42
для зеленого фона
.TP 4
43
для желтого (или коричневого) фона
.TP 4
44
для синего фона
.TP 4
45
для фиолетового фона
.TP 4
46
для голубого фона
.TP 4
47
для белого (или серого) фона
.PD
.RE
.PP
Не все команды будут работать на всех
системах или устройствах отображения.
.PP
Некоторые терминальные программы не
распознают корректно стандартный конечный код.
Если после выполнения команды вывода каталога
весь текст оказывается окрашенным, попробуйте
изменить коды \fBno\fR и \fBfi\fR с 0 на
числовые коды ваших стандартных цветов
переднего и заднего планов.
.RE
.TP 8
.B MACHTYPE \fR(+)
Тип машины (класс микропроцессора или
модель машины), определяемый на этапе
компиляции.
.TP 8
.B NOREBIND \fR(+)
Если установлено, печатные символы не
переназначаются на команду
\fIself-insert-command\fR.
См. \fBNative Language System support\fR.
.TP 8
.B OSTYPE \fR(+)
Операционная система, определяемая
на этапе компиляции.
.TP 8
.B PATH
Список каталоговий, разделенных двоеточиями,
в которых ищутся исполняемые файлы.
Эквивалентно переменной оболочки \fBpath\fR,
но в другом формате.
.TP 8
.B PWD \fR(+)
Эквивалентно переменной оболочки \fBcwd\fR,
но не синхронизируется с ней;
обновляется только после фактического
изменения каталога.
.TP 8
.B REMOTEHOST \fR(+)
Удаленный хост, с которого пользователь вошел
в систему, если это так, и если оболочка может
это определить. Устанавливается только в том
случае, если оболочка была скомпилирована
соответствующим образом;
см. переменную оболочки \fBversion\fR.
.TP 8
.B SHLVL \fR(+)
Эквивалентно переменной оболочки \fBshlvl\fR.
.TP 8
.B SYSTYPE \fR(+)
Текущий тип системы. (Только для Domain/OS)
.TP 8
.B TERM
Эквивалентно переменной оболочки \fBterm\fR.
.TP 8
.B TERMCAP
Строка возможностей терминала.
См. \fBTerminal management\fR.
.TP 8
.B USER
Эквивалентно переменной оболочки \fBuser\fR.
.TP 8
.B VENDOR \fR(+)
Производитель, определяемый на этапе компиляции.
.TP 8
.B VISUAL
Путь к текстовому редактору на полный
экран по умолчанию. Используется командой
редактора \fIrun-fg-editor\fR, если
переменная оболочки \fBeditors\fR не установлена.
См. также переменную окружения \fBEDITOR\fR.
.SH ФАЙЛЫ
.PD 0
.TP 16
.I /etc/csh.cshrc
Читается первым каждой оболочкой.
ConvexOS, Stellix и Intel используют
\fI/etc/cshrc\fR, а NeXTs используют
\fI/etc/cshrc.std\fR.
A/UX, AMIX, Cray и IRIX не имеют
эквивалента в \fIcsh\fR(1),
но всё равно читают этот файл в \fItcsh\fR.
Solaris 2.x также его не имеет,
но \fItcsh\fR читает \fI/etc/.cshrc\fR. (+)
.TP 16
.I /etc/csh.login
Читается оболочками для входа после
\fI/etc/csh.cshrc\fR. ConvexOS, Stellix
и Intel используют \fI/etc/login\fR,
NeXTs используют \fI/etc/login.std\fR,
Solaris 2.x использует \fI/etc/.login\fR,
а A/UX, AMIX, Cray и IRIX используют
\fI/etc/cshrc\fR.
.TP 16
.I ~/.tcshrc \fR(+)
Читается каждой оболочкой после
\fI/etc/csh.cshrc\fR или его эквивалента.
.TP 16
.I ~/.cshrc
Читается каждой оболочкой, если
\fI~/.tcshrc\fR не существует,
после \fI/etc/csh.cshrc\fR или его эквивалента.
Это руководство использует \fI~/.tcshrc\fR для
обозначения \fI~/.tcshrc\fR или,
если \fI~/.tcshrc\fR не найден, \fI~/.cshrc\fR.
.TP 16
.I ~/.history
Читается входными оболочками после
\fI~/.tcshrc\fR если установлен
параметр \fBsavehist\fR, но
см. также \fBhistfile\fR.
.TP 16
.I ~/.login
Читается входными оболочками после
\fI~/.tcshrc\fR или \fI~/.history\fR.
Оболочка может быть скомпилирована для
чтения \fI~/.login\fR перед, а не после
\fI~/.tcshrc\fR и \fI~/.history\fR;
см. переменную оболочки \fBversion\fR.
.TP 16
.I ~/.cshdirs \fR(+)
Читается входными оболочками после
\fI~/.login\fR если установлена Параметр
\fBsavedirs\fR, но см. также \fBdirsfile\fR.
.TP 16
.I /etc/csh.logout
Читается входными оболочками при выходе.
ConvexOS, Stellix и Intel используют
\fI/etc/logout\fR и NeXTs используют
\fI/etc/logout.std\fR. A/UX, AMIX, Cray
и IRIX не имеют эквивалента в \fIcsh\fR(1),
но читают этот файл в \fItcsh\fR в любом случае.
Solaris 2.x также его не имеет, но \fItcsh\fR
читает \fI/etc/.logout\fR. (+)
.TP 16
.I ~/.logout
Читается входными оболочками при выходе
после \fI/etc/csh.logout\fR или его эквивалента.
.TP 16
.I /bin/sh
Используется для интерпретации скриптов
оболочки, которые не начинаются с #.
.TP 16
.I /tmp/sh*
Временный файл для <<.
.TP 16
.I /etc/passwd
Источник для замены домашнего каталога
при подстановках ~name.
.PD
.PP
Порядок, в котором читаются стартовые файлы,
может отличаться, если оболочка была так
скомпилирована; см. \fBStartup and shutdown\fR
и переменную оболочки \fBversion\fR.
.SH "НОВЫЕ ФУНКЦИИ (+)"
Это руководство описывает \fItcsh\fR как
единую сущность, но опытные пользователи
\fIcsh\fR(1) захотят обратить особое внимание
на новые функции \fItcsh\fR.
.PP
Редактор командной строки, поддерживающий
привязки клавиш в стиле \fIemacs\fR(1)
или \fIvi\fR(1).
См. \fBThe command-line editor\fR и
\fBEditor commands\fR.
.PP
Программируемое, интерактивное автодополнение
и список слов. См. \fBCompletion and listing\fR
и встроенные команды \fIcomplete\fR и
\fIuncomplete\fR.
.PP
\fBSpelling correction\fR (q.v.) файлов,
команд и переменных.
.PP
\fBEditor commands\fR (q.v.), выполняющие
другие полезные функции во время ввода команд,
включая поиск документации (\fIrun-help\fR),
быстрый перезапуск редактора (\fIrun-fg-editor\fR)
и разрешение команд (\fIwhich-command\fR).
.PP
Улучшенный механизм истории. События в списке
истории имеют отметки времени.
См. также команду \fIhistory\fR и связанные
с ней переменные оболочки, ранее
недокументированный символ #' для указания
событий и новые модификаторы
в разделе \fBHistory substitution\fR,
команды редактора \fI*-history\fR,
\fIhistory-search-*\fR, \fIi-search-*\fR,
\fIvi-search-*\fR и \fItoggle-literal-history\fR
и переменную оболочки \fBhistlit\fR.
.PP
Улучшенный разбор каталоговий и управление
стеком каталоговий.
См. команды \fIcd\fR, \fIpushd\fR,
\fIpopd\fR и \fIdirs\fR и связанные
с ними переменные оболочки, описание
\fBDirectory stack substitution\fR,
переменные оболочки \fBdirstack\fR,
\fBowd\fR и \fBsymlinks\fR и команды
редактора \fInormalize-command\fR и
\fInormalize-path\fR.
.PP
Отрицание в шаблонах глобального поиска.
См. \fBFilename substitution\fR.
.PP
Новые \fBFile inquiry operators\fR (q.v.)
и встроенная команда \fIfiletest\fR,
которая их использует.
.PP
Разнообразие \fBAutomatic, periodic and timed events\fR (q.v.), включая
запланированные события, специальные алиасы,
автоматический выход из системы и блокировку
терминала, измерение времени выполнения команд
и отслеживание входов и выходов пользователей.
.PP
Поддержка системы Native Language
(см. \fBNative Language System support\fR),
функции вариантов ОС
(см. \fBOS variant support\fR и переменную
оболочки \fBecho_style\fR)
и системно-зависимые местоположения файлов
(см. \fBFILES\fR).
.PP
Расширенные возможности управления терминалом.
См. \fBTerminal management\fR.
.PP
Новые встроенные команды, включая \fIbuiltins\fR,
\fIhup\fR, \fIls\-F\fR, \fInewgrp\fR,
\fIprintenv\fR, \fIwhich\fR и \fIwhere\fR (q.v.).
.PP
Новые переменные, которые предоставляют
полезную информацию оболочке.
См. переменные оболочки \fBgid\fR,
\fBloginsh\fR, \fBoid\fR, \fBshlvl\fR,
\fBtcsh\fR, \fBtty\fR, \fBuid\fR и
\fBversion\fR, а также переменные окружения
\fBHOST\fR, \fBREMOTEHOST\fR, \fBVENDOR\fR,
\fBOSTYPE\fR и \fBMACHTYPE\fR.
.PP
Новый синтаксис для включения полезной
информации в строку приглашения
(см. \fBprompt\fR),
и специальные приглашения для циклов и
исправления орфографии
(см. \fBprompt2\fR и \fBprompt3\fR).
.PP
Переменные только для чтения.
См. \fBVariable substitution\fR.
.SH ОШИБКИ
Когда возобновляется приостановленная
команда, оболочка выводит каталог,
в котором она была запущена, если он
отличается от текущего каталога.
Это может ввести в заблуждение
(т.е. быть неверным), поскольку задание
могло изменить каталоги внутри себя.
.PP
Встроенные функции оболочки не могут быть
приостановлены/возобновлены.
Последовательности команд в форме `a ; b ; c'
также не обрабатываются корректно при попытке
приостановки. Если вы приостановите `b',
оболочка немедленно выполнит `c'.
Это особенно заметно, если это расширение
происходит из \fIalias\fR. Достаточно
поместить последовательность команд в ()
для принудительного выполнения в
под-оболочке, т.е. `( a ; b ; c )'.
.PP
Управление выводом на tty после запуска
процессов является примитивным; возможно,
это вдохновит кого-то на разработку хорошего
интерфейса виртуального терминала.
В интерфейсе виртуального терминала можно
было бы сделать гораздо более интересные
вещи с контролем вывода.
.PP
Замена через алиасы чаще всего используется
для неуклюжей имитации процедур оболочки;
следует предоставить настоящие процедуры
оболочки вместо алиасов.
.PP
Структуры управления должны анализироваться,
а не распознаваться как встроенные команды.
Это позволило бы размещать команды управления
где угодно, сочетать их с `|', и использовать
с `&' и `;' метасинтаксисом.
.PP
\fIforeach\fR не игнорирует here-документы
при поиске своего \fIконца\fR.
.PP
Должна быть возможность использовать
модификаторы `:' для вывода командных замещений.
.PP
Обновление экрана для строк, длина которых
превышает ширину экрана, очень плохо работает,
если терминал не может переместить курсор вверх
(т.е. тип терминала `dumb').
.PP
\fBHPATH\fR и \fBNOREBIND\fR не должны быть
переменными окружения.
.PP
Глоб-паттерны, которые не используют `?', `*'
или `[]' или которые используют `{}' или `~',
не отрицаются корректно.
.PP
Однокомандная форма \fIif\fR выполняет
перенаправление вывода даже если
выражение ложно и команда не выполняется.
.PP
\fIls\-F\fR включает символы идентификации
файлов при сортировке имен файлов и плохо
обрабатывает управляющие символы в именах
файлов. Он не может быть прерван.
.PP
Замещение команд поддерживает несколько
команд и условий, но не циклы или
обратные \fIgoto\fR.
.PP
Сообщайте об ошибках на https://bugs.astron.com/,
предпочтительно с исправлениями. Если вы хотите
помочь в поддержке и тестировании tcsh, добавьте
себя в список рассылки на
https://mailman.astron.com/.
.SH "T В TCSH"
В 1964 году компания DEC выпустила PDP-6.
PDP-10 была позднейшей пере-реализацией.
Она была переименована в DECsystem-10 примерно
в 1970 году, когда DEC выпустила вторую модель,
KI10.
.PP
TENEX был создан в Bolt, Beranek & Newman
(Кембридж, Массачусетс, исследовательский центр)
в 1972 году как экспериментальная операционная
система виртуальной памяти с постраничной подкачкой.
Они разработали новый загрузчик для DEC PDP-10
и создали ОС для работы с ним. Она стала
чрезвычайно успешной в академических кругах.
.PP
В 1975 году компания DEC выпустила новую модель
PDP-10, KL10; они намеревались иметь только версию
TENEX, которую они лицензировали у BBN, для новой
машины. Они назвали свою версию TOPS-20
(их написание с заглавными буквами является
зарегистрированным товарным знаком).
Многие пользователи TOPS-10 (`Операционная система
для PDP-10') возражали; таким образом, DEC пришлось
поддерживать две несовместимые системы на одном и
том же оборудовании -- но на PDP-11 их было 6!
.PP
TENEX и TOPS-20 до версии 3 имели автодополнение
команд через библиотеку подпрограмм на уровне
пользовательского кода, называемую ULTCMD.
С версией 3 DEC переместила всю эту функциональность
и многое другое в монитор (ядро для пользователей Unix),
к которому можно было получить доступ через COMND% JSYS
(`Jump to SYStem' инструкция, механизм системного вызова
супервизора [вы также видите мои корни в IBM?]).
.PP
Создатель tcsh был впечатлен этой функцией и несколькими
другими особенностями TENEX и TOPS-20, и создал версию
csh, которая их имитировала.
.SH ОГРАНИЧЕНИЯ
Система ограничивает списки аргументов до ARG_MAX символов.
.PP
Количество аргументов для команды,
которая включает расширение имен файлов,
ограничено 1/6 от числа символов,
допустимых в списке аргументов.
.PP
Замещения команд могут подставить
не больше символов, чем допустимо
в списке аргументов.
.PP
Для обнаружения зацикливания оболочка
ограничивает количество \fIalias\fR
замещений на одной строке до 20.
.SH "СМ. ТАКЖЕ"
csh(1), emacs(1), ls(1), newgrp(1), sh(1),
setpath(1), stty(1), su(1), tset(1), vi(1),
x(1), access(2), execve(2), fork(2), killpg(2),
pipe(2), setrlimit(2), sigvec(2), stat(2),
umask(2), vfork(2), wait(2), malloc(3),
setlocale(3), tty(4), a.out(5), termcap(5),
environ(7), termio(7), Введение в C Shell.
.SH ВЕРСИЯ
Это руководство документирует
tcsh 6.22.04 (Astron) 2021-04-26.
.SH АВТОРЫ
.PD 0
.TP 2
William Joy
Оригинальный автор \fIcsh\fR(1)
.TP 2
J.E. Kulp, IIASA, Лаксенбург, Австрия
Функции управления заданиями и стек каталоговий
.TP 2
Ken Greer, HP Labs, 1981
Автодополнение имен файлов
.TP 2
Mike Ellis, Fairchild, 1983
Распознавание/автодополнение имен команд
.TP 2
Paul Placeway, Ohio State CIS Dept., 1983-1993
Редактор командной строки, процедуры для работы
с приглашением, новый синтаксис глоб-паттернов
и многочисленные исправления и оптимизации
.TP 2
Karl Kleinpaste, CCI 1983-4
Специальные алиасы, извлечение из стека
каталоговий, отслеживание входов/выходов,
запланированные события и идея нового
формата приглашения
.TP 2
Rayan Zachariassen, University of Toronto, 1984
Встроенные команды \fIls\-F\fR и \fIwhich\fR и
многочисленные исправления, модификации
и оптимизации
.TP 2
Chris Kingsley, Caltech
Процедуры быстрого выделения памяти
.TP 2
Chris Grevstad, TRW, 1987
Интеграция \fIcsh\fR 4.3BSD в \fItcsh\fR
.TP 2
Christos S. Zoulas, Cornell U. EE Dept., 1987-94
Порты для HPUX, SVR2 и SVR3, версия getwd.c
для SysV, поддержка SHORT_STRINGS и
новая версия sh.glob.c
.TP 2
James J Dempsey, BBN, и Paul Placeway, OSU, 1988
Порт A/UX
.TP 2
Daniel Long, NNSC, 1988
\fBwordchars\fR
.TP 2
Patrick Wolfe, Kuck and Associates, Inc., 1988
Очистка режима \fIvi\fR
.TP 2
David C Lawrence, Rensselaer Polytechnic Institute, 1989
\fBautolist\fR и вывод при неоднозначном автодополнении
.TP 2
Alec Wolman, DEC, 1989
Новые строки в приглашении
.TP 2
Matt Landau, BBN, 1989
\fI~/.tcshrc\fR
.TP 2
Ray Moody, Purdue Physics, 1989
Расширение истории с помощью пробела
.TP 2
Mordechai ????, Intel, 1989
Исправления и дополнения для printprompt()
.TP 2
Kazuhiro Honda, Dept. of Computer Science,
Keio University, 1989
Автоматическая проверка орфографии
и \fBprompt3\fR
.TP 2
Per Hedeland, Ellemtel, Sweden, 1990-
Различные исправления ошибок, улучшения
и обновления руководства
.TP 2
Hans J. Albertsson (Sun Sweden)
\fBampm\fR, \fIsettc\fR и \fItelltc\fR
.TP 2
Michael Bloom
Исправления обработки прерываний
.TP 2
Michael Fine, Digital Equipment Corp
Поддержка расширенных клавиш
.TP 2
Eric Schnoebelen, Convex, 1990
Поддержка Convex, многочисленные
исправления ошибок \fIcsh\fR,
сохранение и восстановление стека каталоговий
.TP 2
Ron Flax, Apple, 1990
Порт A/UX 2.0 (перепортирован)
.TP 2
Dan Oscarsson, LTH Sweden, 1990
Поддержка NLS и эмуляция поддержки
NLS для не-NLS систем, исправления
.TP 2
Johan Widen, SICS Sweden, 1990
\fBshlvl\fR, поддержка Mach,
\fIcorrect-line\fR, вывод 8-битных символов
.TP 2
Matt Day, Sanyo Icon, 1990
Поддержка POSIX termio,
исправления для SysV limit
.TP 2
Jaap Vermeulen, Sequent, 1990-91
Исправления режима Vi, расширение команд,
исправления изменения окна, порт для Symmetry
.TP 2
Martin Boyer, Institut de recherche d'Hydro-Quebec, 1991
Параметры звукового сигнала для \fBautolist\fR,
модифицированный поиск по истории для поиска
всей строки от начала до курсора.
.TP 2
Scott Krotz, Motorola, 1991
Порт Minix
.TP 2
David Dawes, Sydney U. Australia, Physics Dept., 1991
Исправления для управления заданиями в SVR4
.TP 2
Jose Sousa, Interactive Systems Corp., 1991
Дополнительные исправления режима \fIvi\fR
и команда удаления \fIvi\fR
.TP 2
Marc Horowitz, MIT, 1991
Исправления для ANSIfication, новый код
хеширования exec, исправления для imake,
\fIwhere\fR
.TP 2
Bruce Sterling Woodcock, sterling@netcom.com, 1991-1995
Порт для ETA и Pyramid, исправления Makefile и lint,
добавление \fBignoreeof\fR=n и различные другие
изменения для переносимости и исправления ошибок
.TP 2
Jeff Fink, 1992
\fIcomplete-word-fwd\fR и
\fIcomplete-word-back\fR
.TP 2
Harry C. Pulley, 1992
Порт для Coherent
.TP 2
Andy Phillips, Mullard Space Science Lab U.K., 1992
Порт VMS-POSIX
.TP 2
Beto Appleton, IBM Corp., 1992
Исправления для управления группами процессов,
исправления ошибок \fIcsh\fR,
POSIX тесты файлов, POSIX SIGHUP
.TP 2
Scott Bolte, Cray Computer Corp., 1992
Порт CSOS
.TP 2
Kaveh R. Ghazi, Rutgers University, 1992
Порты и исправления для Tek, m88k,
Titan и Masscomp.
Добавлена поддержка autoconf.
.TP 2
Mark Linderman, Cornell University, 1992
Порт OS/2
.TP 2
Mika Liljeberg, liljeber@kruuna.Helsinki.FI, 1992
Порт Linux
.TP 2
Tim P. Starrin, NASA Langley
Research Center Operations, 1993
Переменные только для чтения
.TP 2
Dave Schweisguth, Yale University, 1993-4
Новое руководство и tcsh.man2html
.TP 2
Larry Schwimmer, Stanford University, 1993
Патчи для AFS и HESIOD
.TP 2
Luke Mewburn, RMIT University, 1994-6
Улучшенная печать каталоговий в приглашении,
добавлены \fBellipsis\fR и \fBrprompt\fR.
.TP 2
Edward Hutchins, Silicon Graphics Inc., 1996
Добавлено implicit cd.
.TP 2
Martin Kraemer, 1997
Порт для машины Siemens Nixdorf EBCDIC
.TP 2
Amol Deshpande, Microsoft, 1997
Порт для WIN32 (Windows/95 и Windows/NT);
написан код библиотеки и каталога сообщений
для взаимодействия с Windows.
.TP 2
Taga Nayuta, 1998
Добавления для цветного ls.
.PD
.PP
.SH "БЛАГОДАРНОСТИ"
Bryan Dunlap, Clayton Elwell, Karl Kleinpaste,
Bob Manson, Steve Romig, Diana Smetters,
Bob Sutterfield, Mark Verber, Elizabeth Zwicky и всем
остальным людям из Ohio State за предложения и поддержку
.PP
Всем пользователям сети за терпение,
сообщения об ошибках и предложения по добавлению
новых возможностей в каждую версию
.PP
Richard M. Alderson III за написание раздела `T в tcsh'
