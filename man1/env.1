.\" Авторское право (c) 1980, 1990, 1993
.\"	 Ректоры Калифорнийского университета. Все права защищены.
.\"
.\" Этот код создан на основе программного обеспечения, переданного
.\" в Беркли Институтом инженеров по электротехнике и электронике, Inc.
.\" Распространение и использование в исходных и бинарных формах, с изменениями или без них,
.\" разрешаются при соблюдении следующих условий:
.\" 1. Распространение исходного кода должно сохранять приведенное выше уведомление о копирайте,
.\"    этот список условий и следующий отказ от ответственности.
.\" 2. Распространение в бинарной форме должно воспроизводить приведенное выше уведомление о копирайте,
.\"    этот список условий и следующий отказ от ответственности в
.\"    документации и/или других материалах, предоставляемых вместе с распространением.
.\" 3. Ни название университета, ни имена его участников
.\"    не могут использоваться для продвижения производных продуктов
.\"    без явного предварительного письменного разрешения.
.\"
.\" ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЕНО РЕГЕНТАМИ И УЧАСТНИКАМИ «КАК ЕСТЬ», И
.\" ЛЮБЫЕ ПРЯМЫЕ ИЛИ КОСВЕННЫЕ ГАРАНТИИ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ,
.\" ГАРАНТИЯМИ ТОВАРНОЙ ПРИГОДНОСТИ И СООТВЕТСТВИЯ КОНКРЕТНОЙ ЦЕЛИ,
.\" ОТКАЗЫВАЮТСЯ. В НИКАКОМ СЛУЧАЕ РЕГЕНТЫ ИЛИ УЧАСТНИКИ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ
.\" ЗА ЛЮБЫЕ ПРЯМЫЕ, КОСВЕННЫЕ, СЛУЧАЙНЫЕ, СПЕЦИАЛЬНЫЕ, ПОКАЗАТЕЛЬНЫЕ ИЛИ ПОСЛЕДУЮЩИЕ
.\" УЩЕРБЫ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ, ПРИОБРЕТЕНИЕМ ЗАМЕЩАЮЩИХ ТОВАРОВ
.\" ИЛИ УСЛУГ; УТРАТОЙ ПРАВА ПОЛЬЗОВАНИЯ, ДАННЫХ ИЛИ ПРИБЫЛИ; ЛИБО ПРЕРЫВАНИЕМ ДЕЯТЕЛЬНОСТИ)
.\" НЕЗАВИСИМО ОТ ТОГО, НА КАКОЙ ТЕОРИИ ОТВЕТСТВЕННОСТИ, ДОГОВОРНОЙ, СТРОГОЙ
.\" ОТВЕТСТВЕННОСТИ ИЛИ ДЕЛИКТНОЙ (ВКЛЮЧАЯ НЕБРЕЖНОСТЬ ИЛИ ИНОЕ)
.\" ОСНОВЫВАЕТСЯ ЛИСПОЛЬЗОВАНИЕ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ, ДАЖЕ ЕСЛИ БЫЛО СООБЩЕНО О
.\" ВОЗМОЖНОСТИ ТАКОГО УЩЕРБА.
.\"
.\" От @(#)printenv.1	8.1 (Беркли) 6/6/93
.\" От FreeBSD: src/usr.bin/printenv/printenv.1,v 1.17 2002/11/26 17:33:35 ru Exp
.\"
.Dd 3 марта 2021
.Dt ENV 1
.Os
.Sh НАЗВАНИЕ
.Nm env
.Nd установить окружение и выполнить команду, или вывести окружение
.Sh СИНТАКСИС
.Nm
.Op Fl 0iv
.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
.Op Fl u Ar name
.Op Ar name Ns = Ns Ar value ...
.Nm
.Op Fl iv
.Op Fl L Ns | Ns Fl U Ar user Ns Op / Ns Ar class
.Op Fl P Ar altpath
.Op Fl S Ar string
.Op Fl u Ar name
.Op Ar name Ns = Ns Ar value ...
.Ar utility  Op Ar argument ...
.Sh ОПИСАНИЕ
Утилита
.Nm
выполняет другую
.Ar utility 
после изменения окружения, как указано в командной строке.
Каждый параметр
.Ar name Ns = Ns Ar value 
указывает установку переменной окружения
.Ar name ,
со значением
.Ar value  .
Все такие переменные окружения устанавливаются до того, как
будет выполнена
.Ar utility .
.Pp
параметры следующие:
.Bl -tag -width indent
.It Fl 0
Заканчивать каждую строку вывода символом NUL, а не переводом строки.
.It Fl i
Выполнять
.Ar utility	,
только с теми переменными окружения, которые указаны в параметрах
.Ar name Ns = Ns Ar value .
Окружение, унаследованное
.Nm ,
полностью игнорируется.
.\"	-L | -U
.It Fl L | Fl U Ar user Ns Op / Ns Ar class
Добавить определения переменных окружения из
.Xr login.conf 5
для указанного пользователя и класса входа в окружение после
обработки опций
.Fl i
или
.Fl u ,
но перед обработкой параметров
.Ar name Ns = Ns Ar value .
Если используется опция
.Fl L ,
читается только системный файл
.Pa /etc/login.conf.db ;
если используется
.Fl U ,
читается также файл пользователя
.Pa ~/.login_conf .
user может быть указан по имени или uid.
Если задано имя пользователя
.Sq Li \&- ,
то поиск пользователя не будет выполняться, класс входа будет по
умолчанию
.Sq Li default
если не указан явно, и замены в значениях не будут выполняться.
.\"	-P
.It Fl P Ar altpath
Искать
.Ar utility	,
в наборе каталогов, указанных в
.Ar altpath ,
вместо использования значения переменной окружения
.Ev PATH .
.\"	-S
.It Fl S Ar string
Разделить переданную
.Ar string
на несколько строк и обработать каждую из полученных строк
как отдельные аргументы для утилиты
.Nm .
Опция
.Fl S
распознает некоторые специальные последовательности символов и
также поддерживает подстановку переменных окружения, как описано
ниже.
.\"	-u
.It Fl u Ar name
Если переменная окружения
.Ar name
присутствует в окружении, удалить ее до обработки
оставшихся параметров.
Это похоже на команду
.Ic unset
в оболочке
.Xr sh 1 .
Значение для
.Ar name
не должно включать символ
.Ql = .
.\"	-v
.It Fl v
Выводить подробную информацию о каждом этапе обработки утилиты
.Nm .
Дополнительная информация будет выведена, если
.Fl v
указан несколько раз.
.El
.Pp
Вышеуказанные параметры распознаются только при их указании
до любого параметра
.Ar name Ns = Ns Ar value .
.Pp
Если
.Ar utility
не указана,
.Nm
выводит имена и значения переменных в окружении.
Каждая пара имя/значение разделяется новой строкой, если не
указана опция
.Fl 0 ,
в противном случае пары имя/значение разделяются символом NUL.
Нельзя использовать опцию
.Fl 0
вместе с параметром
.Ar utility .
.\"
.Ss Подробности обработки -S (split-string)
Обработка параметры
.Fl S
разделит переданную
.Ar string
на отдельные аргументы на основе любого пробела или символа табуляции,
найденного в
.Ar string .
Каждый из этих новых аргументов будет обработан так, как будто он был
указан в качестве отдельного аргумента в исходной команде
.Nm .
.Pp
Пробелы и табуляции могут быть встроены в один из этих новых аргументов с помощью
одинарных
.Pq Dq Li '
или двойных
.Pq Ql \&"
кавычек, или символа обратной косой черты
.Pq Ql \e .
Одинарные кавычки экранируют все символы, кроме одинарных кавычек, до
соответствующей одинарной кавычки.
Двойные кавычки экранируют все символы, кроме двойных кавычек, до
соответствующей двойной кавычки.
Это ошибка, если конец
.Ar string
достигается до соответствующего символа кавычки.
.Pp
Если опция
.Fl S
создаст новый аргумент, который начинается с символа
.Ql # ,
то этот аргумент и оставшаяся часть
.Ar string
будут проигнорированы.
Последовательность
.Ql \e#
может быть использована, если требуется, чтобы новый аргумент начинался
с символа
.Ql # ,
без пропуска оставшейся части
.Ar string .
.Pp
При обработке значения
.Ar string
опция
.Fl S
будет рассматривать определенные комбинации символов как управляющие
последовательности, представляющие некоторые действия.
Символьные управляющие последовательности указаны в нотации обратной косой черты.
Символы и их значения следующие:
.Pp
.Bl -tag -width indent -offset indent -compact
.It Cm \ec
Игнорировать оставшиеся символы в
.Ar string .
Это не должно появляться внутри строки в двойных кавычках.
.It Cm \ef
Заменить на символ <form-feed>.
.It Cm \en
Заменить на символ <new-line>.
.It Cm \er
Заменить на символ <carriage return>.
.It Cm \et
Заменить на символ <tab>.
.It Cm \ev
Заменить на символ <vertical tab>.
.It Cm \e#
Заменить на символ
.Ql # .
Это может быть полезно, когда вам нужен символ
.Ql #
в качестве первого символа в одном из аргументов, созданных
при разделении
.Ar string .
.It Cm \e$
Заменить на символ
.Ql $ .
.It Cm \e_
Если найдено внутри строки в двойных кавычках, заменить на
один пробел.
Если найдено за пределами строки в кавычках, то это будет
разделителем между новыми аргументами в исходной
.Ar string .
.It Cm \e"
Заменить на символ <двойная кавычка>.
.It Cm \e\'
Заменить на символ <одинарная кавычка>.
.It Cm \e\e
Заменить на символ обратной косой черты.
.El
.Pp
Последовательности для символов <одинарная кавычка> и обратной косой черты
являются единственными последовательностями,
распознаваемыми внутри строки в одинарных кавычках.
Остальные последовательности не имеют особого значения внутри строки
в одинарных кавычках.
Все управляющие последовательности распознаются внутри строки в двойных кавычках.
Это ошибка, если одиночный символ
.Ql \e
сопровождается символом, отличным от приведенных выше.
.Pp
Обработка параметры
.Fl S
также поддерживает подстановку значений из переменных окружения.
Для этого имя переменной окружения должно находиться внутри
.Ql ${} ,
например:
.Li ${SOMEVAR} .
Обычный синтаксис оболочки
.Li $SOMEVAR
не поддерживается.
Все подставленные значения будут значениями переменных окружения,
которые существовали при первоначальном запуске утилиты
.Nm .
Эти значения не будут проверяться на наличие управляющих последовательностей,
как описано выше.
Любые установки
.Ar name Ns = Ns Ar value
не повлияют на значения, используемые при подстановке в обработке
.Fl S .
.Pp
Кроме того, обработка
.Fl S
не может ссылаться на значение специальных параметров,
определенных в большинстве оболочек.
Например,
.Fl S
не может распознавать специальные параметры, такие как:
.Ql $* ,
.Ql $@ ,
.Ql $# ,
.Ql $?
или
.Ql $$
если они встречаются внутри строки
.Ar string .
.\"
.Ss Использование в скриптах оболочки
Утилита
.Nm
часто используется в качестве интерпретатора
в первой строке интерпретируемых скриптов, как описано в
.Xr execve 2 .
.Pp
Обратите внимание, что способ разбора ядром
.Ql #!
(первая строка) интерпретируемого скрипта изменился начиная с
.Fx 6.0 .
До этого ядро
.Fx
разделяло эту первую строку на отдельные аргументы на основе
любого пробела (символы пробела или табуляции), найденного в строке.
Так, если скрипт под названием
.Pa /usr/local/bin/someport
имел первую строку:
.Pp
.Dl "#!/usr/local/bin/php -n -q -dsafe_mode=0"
.Pp
то программа
.Pa /usr/local/bin/php
запускалась с аргументами:
.Bd -literal -offset indent
arg[0] = '/usr/local/bin/php'
arg[1] = '-n'
arg[2] = '-q'
arg[3] = '-dsafe_mode=0'
arg[4] = '/usr/local/bin/someport'
.Ed
.Pp
плюс любые аргументы, указанные пользователем при выполнении
.Pa someport .
Однако эта обработка нескольких опций в строке
.Ql #!
не соответствует тому, как любая другая операционная система анализирует
первую строку интерпретируемого скрипта.
Поэтому после изменения, внесенного в релиз
.Fx 6.0 ,
этот скрипт будет приводить к запуску
.Pa /usr/local/bin/php
со следующими аргументами:
.Bd -literal -offset indent
arg[0] = '/usr/local/bin/php'
arg[1] = '-n -q -dsafe_mode=0'
arg[2] = '/usr/local/bin/someport'
.Ed
.Pp
плюс любые аргументы, указанные пользователем.
Это привело к значительному изменению поведения некоторых скриптов.
В случае вышеуказанного скрипта, чтобы он работал так же под
.Fx 6.0 ,
как и в более ранних версиях, первую строку следует
изменить на:
.Pp
.Dl "#!/usr/bin/env -S /usr/local/bin/php -n -q -dsafe_mode=0"
.Pp
Утилита
.Nm
будет запущена с всей строкой в качестве одного
аргумента:
.Pp
.Dl "arg[1] = '-S /usr/local/bin/php -n -q -dsafe_mode=0'"
.Pp
и затем обработка параметры
.Fl S
разделит эту строку на отдельные аргументы перед выполнением
.Pa /usr/local/bin/php .
.\"
.Sh ОКРУЖЕНИЕ
Утилита
.Nm
использует переменную окружения
.Ev PATH
для поиска запрошенной
.Ar utility ,
если имя не содержит символов
.Ql / ,
если только не была указана опция
.Fl P .
.Sh КОД ЗАВЕРШЕНИЯ
.Pp
Приложение завершается с кодом 0 в случае успеха, и с кодом >0, если произошла ошибка.
Код завершения 126 указывает, что
.Ar utility
была найдена, но не могла быть выполнена.
Код завершения 127 указывает, что
.Ar utility
не могла быть найдена.
.Sh ПРИМЕРЫ
Поскольку утилита
.Nm
часто используется в первой строке интерпретируемого скрипта,
следующие примеры показывают, насколько полезной может быть
утилита
.Nm
в скриптах.
.Pp
Обработка ядром интерпретируемого скрипта не позволяет скрипту
напрямую ссылаться на другой скрипт как на своего интерпретатора.
Как обходной путь основное различие между
.Pp
.Dl "#!/usr/local/bin/foo"
и
.Dl "#!/usr/bin/env /usr/local/bin/foo"
.Pp
заключается в том, что последний вариант работает, даже если
.Pa /usr/local/bin/foo
сам является интерпретируемым скриптом.
.Pp
Вероятно, наиболее распространенное использование утилиты
.Nm
заключается в нахождении правильного интерпретатора для скрипта,
если интерпретатор может находиться в разных каталогах на разных системах.
Следующий пример найдет интерпретатор
.Ql perl
путем поиска по каталогам, указанным в
.Ev PATH .
.Pp
.Dl "#!/usr/bin/env perl"
.Pp
Ограничением этого примера является то, что он предполагает, что значение переменной
.Ev PATH
установлено таким образом, чтобы найти нужный интерпретатор.
Опция
.Fl P
может быть использована для обеспечения поиска по определенному списку каталогов
в поиске
.Ar utility .
Обратите внимание, что для корректной работы этого примера также требуется опция
.Fl S .
.Pp
.Dl "#!/usr/bin/env -S -P/usr/local/bin:/usr/bin perl"
.Pp
Вышеупомянутый пример найдет
.Ql perl
только если он находится в каталогах
.Pa /usr/local/bin
или
.Pa /usr/bin .
Это можно объединить с текущим значением переменной
.Ev PATH ,
чтобы обеспечить большую гибкость.
Обратите внимание, что пробелы не требуются между опциями
.Fl S
и
.Fl P :
.Pp
.Dl "#!/usr/bin/env -S-P/usr/local/bin:/usr/bin:${PATH} perl"
.Sh СОВМЕСТИМОСТЬ
Утилита
.Nm
принимает опцию
.Fl
в качестве синонима для
.Fl i .
.Sh СМ. ТАКЖЕ
.Xr printenv 1 ,
.Xr sh 1 ,
.Xr execvp 3 ,
.Xr login.conf 5 ,
.Xr environ 7
.Sh СТАНДАРТЫ
Утилита
.Nm
соответствует стандарту
.St -p1003.1-2001 .
параметры
.Fl 0 , L , P , S , U , u
и
.Fl v
являются нестандартными расширениями, поддерживаемыми
.Fx ,
но могут быть недоступны в других операционных системах.
.Sh ИСТОРИЯ
Команда
.Nm
появилась в
.Bx 4.4 .
параметры
.Fl P , S
и
.Fl v
были добавлены в
.Fx 6.0 .
параметры
.Fl 0 , L
и
.Fl U
были добавлены в
.Fx 13.0 .
.Sh ОШИБКИ
Утилита
.Nm
не обрабатывает значения
.Ar utility ,
в которых в имени есть знак равенства
.Pq Ql = ,
по понятным причинам.
.Pp
Утилита
.Nm
не учитывает многобайтовые символы при
обработке параметры
.Fl S ,
что может привести к некорректным результатам в некоторых локалях.
