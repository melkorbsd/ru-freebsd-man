.\"	$NetBSD: make.1,v 1.366 2023/05/10 18:22:33 sjg Exp $
.\"
.\" Copyright (c) 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\" 3. Neither the name of the University nor the names of its contributors
.\"    may be used to endorse or promote products derived from this software
.\"    without specific prior written permission.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
.\" SUCH DAMAGE.
.\"
.\"	from: @(#)make.1	8.4 (Berkeley) 3/19/94
.\"
.Dd 10 мая 2023
.Dt MAKE 1
.Os
.Sh ИМЯ
.Nm make
.Nd поддержка зависимостей программ
.Sh СИНТАКСИС
.Nm
.Op Fl BeikNnqrSstWwX
.Op Fl C Ar directory
.Op Fl D Ar variable
.Op Fl d Ar flags
.Op Fl f Ar makefile
.Op Fl I Ar directory
.Op Fl J Ar private
.Op Fl j Ar max_jobs
.Op Fl m Ar directory
.Op Fl T Ar file
.Op Fl V Ar variable
.Op Fl v Ar variable
.Op Ar variable\| Ns Cm \&= Ns Ar value
.Op Ar target No ...
.Sh ОПИСАНИЕ
.Nm
это программа, предназначенная для упрощения сопровождения
других программ. Её ввод — это список спецификаций файлов,
от которых зависят программы и другие файлы.
Если не указана опция
.Fl f Ar makefile ,
.Nm
пытается открыть
.Sq Pa makefile
затем
.Sq Pa Makefile
для поиска спецификаций.
Если файл
.Sq Pa .depend
существует, он читается, см.
.Xr mkdep 1 .
.Pp
Эта страница руководства предназначена только
как справочный документ. Для более подробного описания
.Nm
и make-файлов, пожалуйста, обратитесь к
.%T "PMake \- Учебник"
(от 1993 года).
.Pp
.Nm
добавляет содержимое переменной окружения
.Ev MAKEFLAGS
к аргументам командной строки перед их разбором.
.Pp
Опции следующие:
.Bl -tag -width Ds
.It Fl B
Попытайтесь быть совместимыми с предыдущими версиями,
выполняя одну оболочку на команду и выполняя источники
строки зависимостей последовательно.
.It Fl C Ar directory
Переходите в
.Ar directory
перед чтением make-файлов или выполнением чего-либо ещё.
Если указано несколько опций
.Fl C ,
каждая из них интерпретируется относительно предыдущей:
.Fl C Pa / Fl C Pa etc
эквивалентно
.Fl C Pa /etc .
.It Fl D Ar variable
Определите
.Ar variable
как 1, в глобальной области.
.It Fl d Oo Cm \- Oc Ns Ar flags
Включите отладку и укажите, какие части
.Nm
должны выводить отладочную информацию.
Если флаги не предшествуют
.Ql \- ,
они добавляются в переменную окружения
.Ev MAKEFLAGS
и передаются любым дочерним процессам make.
По умолчанию отладочная информация выводится на
стандартный поток ошибок, но это можно изменить,
используя
.Cm F
отладочный флаг.
Отладочный вывод всегда небуферизован; кроме того,
если отладкат включена, но вывод не направлен на
стандартный вывод, стандартный вывод буферизуется
построчно. Доступные
.Ar flags
включают:
.Bl -tag -width Ds
.It Cm A
Выводить всю возможную отладочную информацию;
эквивалентно указанию всех отладочных флагов.
.It Cm a
Выводить отладочную информацию о поиске
и кэшировании архивов.
.It Cm C
Выводить отладочную информацию о текущем
рабочем каталоге.
.It Cm c
Выводить отладочную информацию об оценке условий.
.It Cm d
Выводить отладочную информацию о поиске
и кэшировании каталогов.
.It Cm e
Выводить отладочную информацию о неудачных командах и целях.
.It Cm F Ns Oo Cm \&+ Oc Ns Ar filename
Укажите, куда выводить отладочную информацию.
Этот флаг должен быть последним, так как он потребляет
оставшуюся часть аргумента. Если символ сразу после
.Cm F
это
.Ql \&+ ,
файл открывается в режиме добавления;
иначе файл перезаписывается.
Если имя файла
.Ql stdout
или
.Ql stderr ,
отладочная информация выводится на стандартный вывод
или стандартный поток ошибок соответственно (и опция
.Ql \&+
не имеет эффекта). В противном случае вывод записывается
в указанный файл. Если имя файла заканчивается на
.Ql .%d ,
.Ql %d
заменяется на pid.
.It Cm f
Выводить отладочную информацию об оценке циклов.
.It Cm g1
Вывести входной граф до выполнения чего-либо.
.It Cm g2
Вывести входной граф после выполнения всех действий
или перед выходом из-за ошибки.
.It Cm g3
Вывести входной граф перед выходом из-за ошибки.
.It Cm h
Выводить отладочную информацию о работе с хэш-таблицами.
.It Cm j
Выводить отладочную информацию о выполнении
нескольких оболочек.
.It Cm L
Включить проверки lint.
Это вызывает ошибки для назначений переменных,
которые не анализируются правильно, в момент
назначения, чтобы были доступны файл и номер строки.
.It Cm l
Выводить команды в make-файлах независимо от того,
предшествуют ли им
.Ql @
или другие
.Dq тихие
флаги.
Также известно как
.Dq громкое
поведение.
.It Cm M
Выводить отладочную информацию о решениях
.Dq meta
режима для целей.
.It Cm m
Выводить отладочную информацию о создании целей,
включая даты изменения.
.It Cm n
Не удалять временные командные скрипты, созданные
при выполнении команд. Эти временные скрипты создаются
в каталоге, указанном переменной окружения
.Ev TMPDIR ,
или в
.Pa /tmp ,
если
.Ev TMPDIR
не установлена или установлена в пустую строку.
Временные скрипты создаются с помощью
.Xr mkstemp 3 ,
и имеют имена формата
.Pa makeXXXXXX .
.Em ПРИМЕЧАНИЕ :
Это может создать множество файлов в
.Ev TMPDIR
или
.Pa /tmp ,
поэтому используйте осторожно.
.It Cm p
Выводить отладочную информацию о разборе make-файлов.
.It Cm s
Выводить отладочную информацию о правилах
трансформации суффиксов.
.It Cm t
Выводить отладочную информацию о поддержке
списка целей.
.It Cm V
Принудительно заставить опцию
.Fl V
выводить необработанные значения переменных,
игнорируя поведение по умолчанию, установленное через
.Va .MAKE.EXPAND_VARIABLES .
.It Cm v
Выводить отладочную информацию о присваивании
и расширении переменных.
.It Cm x
Выполнять команды оболочки с
.Fl x ,
чтобы фактические команды выводились
по мере их выполнения.
.El
.It Fl e
Позволить переменным окружения переопределять
глобальные переменные в make-файлах.
.It Fl f Ar makefile
Укажите make-файл для чтения вместо
.Pa makefile
или
.Pa Makefile
по умолчанию.
Если
.Ar makefile
равен
.Ql \&- ,
читается стандартный ввод.
Можно указать несколько make-файлов, они будут
прочитаны в порядке их указания.
.It Fl I Ar directory
Укажите каталог для поиска make-файлов и включённых
make-файлов. Каталог системных make-файлов
(или каталоги, см. опцию
.Fl m )
автоматически включается как часть этого списка.
.It Fl i
Игнорировать ненулевой выходной код команд оболочки
в make-файле. Эквивалентно указанию
.Ql \&-
перед каждой строкой команды в make-файле.
.It Fl J Ar private
Эта опция
.Em не
должна быть указана пользователем.
.Pp
Когда используется опция
.Fl j
в рекурсивной сборке, эта опция передаётся от одного
make к дочерним make, чтобы все процессы make в сборке
могли кооперироваться и избегать перегрузки системы.
.It Fl j Ar max_jobs
Укажите максимальное количество задач, которое
.Nm
может одновременно выполнять. Значение
.Ar max_jobs
сохраняется в
.Va .MAKE.JOBS .
Отключает режим совместимости, если только не указана опция
.Fl B .
Когда режим совместимости отключен, все команды, связанные
с целью, выполняются в одном вызове оболочки, в отличие от
традиционного вызова оболочки для каждой строки.
Это может сломать традиционные сценарии, которые изменяют
каталоги для каждой команды и ожидают начать со свежей
среды для следующей строки. Более эффективно исправить
сценарии, чем включать режим совместимости.
.Pp
Пул токенов задач с
.Ar max_jobs
используется для контроля общего количества выполняемых
задач. Каждый экземпляр
.Nm
будет ожидать токен из пула перед запуском новой задачи.
.It Fl k
Продолжить обработку после обнаружения ошибок, но только
для тех целей, которые не зависят от цели, создание
которой вызвало ошибку.
.It Fl m Ar directory
Укажите каталог для поиска
.Pa sys.mk
и make-файлов, включённых с помощью оператора
include в стиле
.Li \&< Ns Ar file Ns Li \&> .
Опция
.Fl m
может быть использована несколько раз для формирования
пути поиска. Этот путь заменяет путь включений системы
по умолчанию
.Pa /usr/share/mk .
Кроме того, путь включений системы добавляется к пути
поиска для
.Li \*q Ns Ar file Ns Li \*q -стиля
включений (см. опцию
.Fl I ).
Путь включений системы может быть получен
с помощью переменной
.Va .SYSPATH .
.Pp
Если имя каталога в аргументе
.Fl m
(или в переменной окружения
.Ev MAKESYSPATH )
начинается со строки
.Ql \&.../ ,
.Nm
ищет указанный файл или каталог, названный в оставшейся
части аргумента. Поиск начинается с текущего каталога
и затем продолжается вверх по иерархии до корня файловой
системы. Если поиск успешен, найденный каталог заменяет
.Ql \&.../
в аргументе
.Fl m .
Эта функция позволяет
.Nm
легко искать в текущем исходном дереве пользовательские файлы
.Pa sys.mk
(например, используя
.Ql \&.../mk/sys.mk
в качестве аргумента).
.It Fl n
Показать команды, которые будут выполнены, но не выполнять их,
если только цель не зависит от специального источника
.Va .MAKE
(см. ниже) или команда не начинается с
.Sq Cm + .
.It Fl N
Показать команды, которые были бы выполнены,
но не выполнять ни одной из них;
полезно для отладки верхнеуровневых make-файлов
без перехода в подкаталоги.
.It Fl q
Не выполнять команды,
а завершить выполнение с кодом 0, если указанные цели
актуальны, и 1 в противном случае.
.It Fl r
Не использовать встроенные правила, указанные
в системном make-файле.
.It Fl S
Остановить обработку при обнаружении ошибки.
Это поведение по умолчанию и противоположность опции
.Fl k .
.It Fl s
Не выводить команды по мере их выполнения.
Эквивалентно указанию
.Sq Ic @
перед каждой строкой команды в make-файле.
.It Fl T Ar tracefile
При использовании с флагом
.Fl j ,
добавить запись трассировки в
.Ar tracefile
для каждой задачи, которая начата и завершена.
.It Fl t
Вместо того, чтобы пересоздавать цель, как указано
в make-файле, создайте её или обновите время её
изменения, чтобы сделать её актуальной.
.It Fl V Ar variable
Вывести значение
.Ar variable .
Не строить цели.
Можно указать несколько экземпляров этой опции;
переменные выводятся по одной на строку, с пустой
строкой для каждой нулевой или неопределённой переменной.
Значение выводится из глобальной области после чтения
всех make-файлов.
.Pp
По умолчанию показываются необработанные содержимое
переменной (которое может включать дополнительные
нерасширенные ссылки на переменные).
Если
.Ar variable
содержит
.Ql \&$ ,
оно не интерпретируется как имя переменной, а как
выражение. Его значение разворачивается перед выводом.
Значение также разворачивается перед выводом, если
.Va .MAKE.EXPAND_VARIABLES
установлено в true, и если опция
.Fl dV
не была использована для переопределения этого поведения.
.Pp
Обратите внимание, что переменные, локальные для циклов
и целей, а также значения, временно присвоенные глобальным
переменным во время обработки make-файла, недоступны через
эту опцию. Режим отладки
.Fl dv
может быть использован для их просмотра, что, однако,
приведет к созданию значительного количества лишнего вывода.
.It Fl v Ar variable
Как и
.Fl V ,
но все выводимые переменные всегда разворачиваются до
их полного значения. Последний экземпляр опций
.Fl V
или
.Fl v
определяет, разворачиваются ли все переменные или нет.
.It Fl W
Относиться к любым предупреждениям во время разбора
make-файлов как к ошибкам.
.It Fl w
Выводить сообщения о входе и выходе из каталогов до
и после обработки.
.It Fl X
Не экспортировать переменные, переданные в командной
строке, в окружение индивидуально. Переменные,
переданные в командной строке, всё равно экспортируются
через переменную окружения
.Ev MAKEFLAGS .
Эта опция может быть полезной на системах, где имеется
малое ограничение на размер аргументов команды.
.It Ar variable\| Ns Cm \&= Ns Ar value
Присвоить значение переменной
.Ar variable
значение
.Ar value .
Обычно все значения, переданные в командной строке,
также экспортируются в подчинённые make-процессы через
окружение. Флаг
.Fl X
отключает это поведение. Присвоение переменных должно
следовать за опциями для совместимости с POSIX, но
строгого порядка не требуется.
.El
.Pp
В make-файле есть несколько различных типов строк:
спецификации зависимостей, команды оболочки, присвоения
переменных, операторы include, условные директивы,
циклы for, другие директивы и комментарии.
.Pp
Строки могут продолжаться с одной строки на другую,
если заканчиваются обратной косой чертой
.Pq Ql \e .
Пробельные символы в начале следующей строки и символ
новой строки сжимаются в один пробел.
.Sh СПЕЦИФИКАЦИИ ЗАВИСИМОСТЕЙ ФАЙЛОВ
Строки зависимостей состоят из одной или нескольких
целей, оператора и нуля или более источников. Это
создаёт отношение, при котором цели
.Dq зависят
от источников и обычно создаются из них.
Цель считается устаревшей, если она не существует
или если время её изменения меньше, чем у любого
из её источников. Устаревшая цель пересоздаётся,
но не раньше, чем все источники были проверены и
пересозданы при необходимости. Можно использовать
три оператора:
.Bl -tag -width flag
.It Ic \&:
Многие строки зависимостей могут называть эту цель,
но только одна может иметь прилагаемые команды
оболочки. Все источники, указанные во всех строках
зависимостей, рассматриваются вместе, и при
необходимости выполняются прилагаемые команды
оболочки для создания или пересоздания цели. Если
.Nm
прерывается, цель удаляется.
.It Ic \&!
То же самое, но цель всегда пересоздаётся,
независимо от того, устарела она или нет.
.It Ic \&::
Любая строка зависимостей может иметь прилагаемые
команды оболочки, но каждая обрабатывается независимо:
её источники рассматриваются, и прилагаемые команды
оболочки выполняются, если цель устарела относительно
(только) этих источников. Таким образом, в зависимости
от обстоятельств могут выполняться разные группы
прилагаемых команд оболочки. Более того, в отличие от
.Ic \&: ,
для строк зависимостей без источников прилагаемые
команды оболочки всегда выполняются.
Также, в отличие от
.Ic \&: ,
цель не удаляется, если
.Nm
прерывается.
.El
.Pp
Все строки зависимостей, упоминающие конкретную цель,
должны использовать один и тот же оператор.
.Pp
Цели и источники могут содержать значения
подстановочных символов оболочки
.Ql \&? ,
.Ql * ,
.Ql [] ,
и
.Ql {} .
Значения
.Ql \&? ,
.Ql * ,
и
.Ql []
могут использоваться только как часть последнего
компонента цели или источника и совпадают только с
существующими файлами. Значение
.Ql {}
не обязательно должно использоваться для описания
существующих файлов. Расширение выполняется в порядке
каталогов, а не в алфавитном порядке, как в оболочке.
.Sh КОМАНДЫ ОБОЛОЧКИ
Каждая цель может иметь связанные с ней одну или
несколько строк команд оболочки, обычно используемых
для создания цели. Каждая строка в этом сценарии
.Em должна
начинаться с табуляции.
(По историческим причинам, пробелы не принимаются.)
Хотя цели могут встречаться во многих строках
зависимостей, если это необходимо, по умолчанию
только одно из этих правил может сопровождаться
сценарием создания. Однако, если используется оператор
.Sq Ic \&:: ,
все правила могут включать сценарии, и соответствующие
сценарии выполняются в порядке их обнаружения.
.Pp
Каждая строка рассматривается как отдельная команда
оболочки, если только конец строки не экранирован
обратной косой чертой
.Ql \e ,
в этом случае эта строка и следующая объединяются.
Если первые символы команды являются любой
комбинацией символов
.Sq Ic @ ,
.Sq Ic + ,
или
.Sq Ic \- ,
команда обрабатывается по-особенному.
.Bl -tag -offset indent -width indent
.It Ic @
позволяет не отображать команду перед её выполнением.
.It Ic +
позволяет выполнить команду даже при использовании опции
.Fl n .
Это похоже на эффект специального источника
.Va .MAKE ,
за исключением того, что эффект может быть ограничен
одной строкой сценария.
.It Ic \-
в режиме совместимости игнорирует любой ненулевой
статус выхода строки команды.
.El
.Pp
Когда
.Nm
запущен в режиме задач с опцией
.Fl j Ar max_jobs ,
весь сценарий для цели передаётся одному экземпляру
оболочки. В режиме совместимости (не в режиме задач)
каждая команда выполняется в отдельном процессе.
Если команда содержит любые метасимволы оболочки
.Pq Ql #=|^(){};&<>*?[]:$`\e\en ,
она передаётся оболочке; в противном случае
.Nm
попытается выполнить её напрямую.
Если строка начинается с символа
.Sq Ic \-
и в оболочке включён режим ErrCtl,
неудача строки команды игнорируется, как в режиме
совместимости. В противном случае символ
.Sq Ic \-
влияет на всю задачу;
сценарий прерывается на первой строке команды,
которая завершилась неудачей,
но цель не считается неудачной.
.Pp
Make-файлы следует писать так, чтобы режим работы
.Nm
не менял их поведение. Например, любая команда,
использующая
.Dq cd
или
.Dq chdir
без намерения изменять каталог для последующих команд,
должна быть заключена в круглые скобки,
чтобы выполняться в дочернем процессе оболочки.
Чтобы принудительно использовать одну оболочку,
экранируйте переносы строк, чтобы сделать весь
сценарий одной командой.
Например:
.Bd -literal -offset indent
avoid-chdir-side-effects:
	@echo "Сборка $@ в $$(pwd)"
	@(cd ${.CURDIR} && ${MAKE} $@)
	@echo "Назад в $$(pwd)"

ensure-one-shell-regardless-of-mode:
	@echo "Сборка $@ в $$(pwd)"; \e
	(cd ${.CURDIR} && ${MAKE} $@); \e
	echo "Назад в $$(pwd)"
.Ed
.Pp
Поскольку
.Nm
изменяет текущий рабочий каталог на
.Sq Va .OBJDIR
перед выполнением любых целей, каждый дочерний
процесс начинается с этого каталога как с текущего
рабочего каталога.
.Sh ПРИСВОЕНИЯ ПЕРЕМЕННЫХ
Переменные в make ведут себя почти так же,
как макросы в препроцессоре C.
.Pp
Присвоения переменных имеют форму
.Sq Ar NAME Ar op Ar value ,
где:
.Bl -tag -offset Ds -width Ds
.It Ar NAME
это имя переменной, состоящее по традиции
из заглавных букв,
.It Ar op
это один из операторов присвоения переменных,
описанных ниже, и
.It Ar value
интерпретируется в соответствии с оператором
присвоения переменных.
.El
.Pp
Пробелы вокруг
.Ar NAME ,
.Ar op
и
.Ar value
игнорируются.
.Ss Операторы присвоения переменных Пять операторов,
которые присваивают значения переменным:
.Bl -tag -width Ds
.It Ic \&=
Присваивает переменной значение.
Любое предыдущее значение перезаписывается.
.It Ic \&+=
Добавляет значение к текущему значению переменной,
разделяя их одним пробелом.
.It Ic \&?=
Присваивает значение переменной,
если она ещё не определена.
.It Ic \&:=
Расширяет значение, а затем присваивает его переменной.
.Pp
.Em ПРИМЕЧАНИЕ :
Ссылки на неопределённые переменные
.Em не
расширяются.
Это может вызвать проблемы при использовании
модификаторов переменных.
.It Ic \&!=
Расширяет значение и передаёт его в оболочку для
выполнения, затем присваивает вывод из стандартного
вывода дочернего процесса переменной. Все символы
новой строки в результате заменяются пробелами.
.El
.Ss Расширение переменных
В большинстве контекстов,
где переменные разворачиваются,
.Ql \&$$
разворачивается в один знак доллара.
В других контекстах (большинство модификаторов
переменных, строковые литералы в условиях),
.Ql \&\e$
разворачивается в один знак доллара.
.Pp
Ссылки на переменные имеют форму
.Cm \&${ Ns Ar name Ns Oo Ns Cm \&: Ns Ar modifiers Oc Ns Cm \&}
или
.Cm \&$( Ns Ar name Ns Oo Ns Cm \&: Ns Ar modifiers Oc Ns Cm \&) .
Если имя переменной состоит только из одного символа
и выражение не содержит модификаторов, окружающие
фигурные скобки или круглые скобки не требуются.
Эта более короткая форма не рекомендуется.
.Pp
Если имя переменной содержит знак доллара, сначала
разворачивается само имя. Это позволяет использовать
почти произвольные имена переменных, однако имена,
содержащие доллар, фигурные скобки, круглые скобки
или пробелы, лучше избегать.
.Pp
Если результат разворачивания вложенного выражения
переменной содержит знак доллара
.Pq Ql \&$ ,
результат подлежит дальнейшему расширению.
.Pp
Подстановка переменных происходит в четыре разных
времени, в зависимости от того, где используется
переменная.
.Bl -enum
.It
Переменные в строках зависимостей разворачиваются
при чтении строки.
.It
Переменные в условиях разворачиваются по отдельности,
но только настолько, насколько это необходимо для
определения результата условия.
.It
Переменные в командах оболочки разворачиваются при
выполнении команды оболочки.
.It
.Иc .for
переменные индекса цикла разворачиваются при каждой
итерации цикла. Обратите внимание, что другие
переменные не разворачиваются при составлении тела
цикла, поэтому следующий пример кода:
.Bd -literal -offset indent
\&.for i in 1 2 3
a+=     ${i}
j=      ${i}
b+=     ${j}
\&.endfor

all:
	@echo ${a}
	@echo ${b}
.Ed
.Pp
выведет:
.Bd -literal -offset indent
1 2 3
3 3 3
.Ed
.Pp
После выполнения цикла:
.Bl -tag -offset indent -width indent
.It Va a
содержит
.Ql ${:U1} ${:U2} ${:U3} ,
которое разворачивается в
.Ql 1 2 3 .
.It Va j
содержит
.Ql ${:U3} ,
которое разворачивается в
.Ql 3 .
.It Va b
содержит
.Ql ${j} ${j} ${j} ,
которое разворачивается в
.Ql ${:U3} ${:U3} ${:U3}
и далее в
.Ql 3 3 3 .
.El
.El
.Ss Классы переменных
Существует четыре разных класса переменных
(в порядке увеличения приоритета):
.Bl -tag -width Ds
.It Переменные окружения
Переменные, определённые как часть
.Nm Ns 's
окружения.
.It Глобальные переменные
Переменные, определённые в make-файле или во
включённых make-файлах.
.It Переменные командной строки
Переменные, определённые как часть командной строки.
.It Локальные переменные
Переменные, определённые для конкретной цели.
.El
.Pp
Локальные переменные можно задавать в строке
зависимостей, если
.Va .MAKE.TARGET_LOCAL_VARIABLES
установлена в
.Ql false .
Остальная часть строки
(которая уже содержит расширенные глобальные
переменные) будет значением переменной.
Например:
.Bd -literal -offset indent
COMPILER_WRAPPERS= ccache distcc icecc

${OBJS}: .MAKE.META.CMP_FILTER=${COMPILER_WRAPPERS:S,^,N,}
.Ed
.Pp
Только цели
.Ql ${OBJS}
затрагиваются этим фильтром (в
.Dq meta
режиме), и
включение/выключение любого из оболочечных обёрток
компилятора не делает все эти цели устаревшими.
.Pp
.Em ПРИМЕЧАНИЕ :
локальные присваивания переменных ведут себя иначе,
поскольку:
.Bl -tag -width Ds -offset indent
.It Ic \&+=
Добавляет значение только к предыдущему локальному
присваиванию для той же цели и переменной.
.It Ic \&:=
Избыточно по отношению к глобальным переменным,
которые уже были расширены.
.El
.Pp
Семь встроенных локальных переменных:
.Bl -tag -width ".Va .ARCHIVE" -offset indent
.It Va .ALLSRC
Список всех источников для этой цели;
также известен как
.Sq Va \&> .
.It Va .ARCHIVE
Имя файла архива; также известно как
.Sq Va \&! .
.It Va .IMPSRC
В правилах трансформации суффиксов, имя/путь к источнику,
из которого цель должна быть трансформирована
(так называемый
.Дq подразумеваемый
источник); также известно как
.Sq Va \&< .
Не определяется в явных правилах.
.It Va .MEMBER
Имя члена архива; также известно как
.Sq Va % .
.It Va .OODATE
Список источников для этой цели, которые были признаны
устаревшими; также известен как
.Sq Va \&? .
.It Va .PREFIX
Имя цели с удалённым суффиксом (если он объявлен в
.Иc .SUFFIXES );
также известно как
.Sq Va * .
.It Va .TARGET
Имя цели; также известно как
.Sq Va @ .
Для совместимости с другими make это псевдоним для
.Va .ARCHIVE
в правилах для членов архива.
.El
.Pp
Более короткие формы
.Po
.Sq Va \&> ,
.Sq Va \&! ,
.Sq Va \&< ,
.Sq Va \&% ,
.Sq Va \&? ,
.Sq Va \&* ,
и
.Sq Va \&@
.Pc
разрешены для обратной
совместимости с историческими make-файлами и
устаревшими POSIX make, но не рекомендуются.
.Pp
Варианты этих переменных, за которыми
непосредственно следуют
.Ql D
или
.Ql F ,
например
.Ql $(@D) ,
являются устаревшими формами, эквивалентными
использованию модификаторов
.Ql :H
и
.Ql :T .
Эти формы принимаются для совместимости с
.At V
make-файлами и POSIX, но не рекомендуются.
.Pp
Четыре локальные переменные могут использоваться
в источниках в строках зависимостей, поскольку
они разворачиваются до правильного значения для
каждой цели в строке.
Эти переменные:
.Sq Va .TARGET ,
.Sq Va .PREFIX ,
.Sq Va .ARCHIVE ,
и
.Sq Va .MEMBER .
.Ss Дополнительные встроенные переменные
Кроме того,
.Nm
устанавливает или знает о следующих переменных:
.Bl -tag
.\" NB: Этот список отсортирован без учёта регистра, игнорируя пунктуацию.
.\" NB: Для поиска всех встроенных переменных в исходном коде make,
.\" NB: ищите Var_*, Global_*, SetVarObjdir, GetBooleanExpr,
.\" NB: и реализацию Var_SetWithFlags.
.\" NB: Последняя синхронизация на 2023-01-01.
.It Va .ALLTARGETS
Список всех целей, встреченных в make-файлах.
Если оценивать во время разбора make-файлов,
перечисляются только те цели, которые встречены
на данный момент.
.It Va .CURDIR
Путь к каталогу, где был запущен
.Nm .
Обратитесь к описанию
.Sq Va PWD
для получения дополнительных сведений.
.It Va .ERROR_CMD
Используется при обработке ошибок, см.
.Va MAKE_PRINT_VAR_ON_ERROR .
.It Va .ERROR_CWD
Используется при обработке ошибок, см.
.Va MAKE_PRINT_VAR_ON_ERROR .
.It Va .ERROR_META_FILE
Используется при обработке ошибок в
.Дq meta
режиме, см.
.Va MAKE_PRINT_VAR_ON_ERROR .
.It Va .ERROR_TARGET
Используется при обработке ошибок, см.
.Va MAKE_PRINT_VAR_ON_ERROR .
.It Va .INCLUDEDFROMDIR
Каталог, из которого был включён данный make-файл.
.It Va .INCLUDEDFROMFILE
Имя файла make-файла, который был включён.
.\" .INCLUDES специально не документирован, так как устарел.
.\" .LIBS специально не документирован, так как устарел.
.It Va MACHINE
Имя аппаратной платформы, см.
.Xr uname 1 .
.It Va MACHINE_ARCH
Имя архитектуры процессора, см.
.Xr uname 1 .
.It Va MAKE
Имя, с которым было запущено
.Nm
.Пq Va argv[0] .
.It Va .MAKE
То же самое, что и
.Va MAKE ,
для совместимости.
Предпочтительно использовать переменную окружения
.Ev MAKE
поскольку она более совместима с другими версиями
make и не может быть спутана со специальной целью
с таким же именем.
.It Va .MAKE.ALWAYS_PASS_JOB_QUEUE
Определяет, следует ли передавать дескрипторы пула
токенов задач даже если цель не помечена
.Иc .MAKE .
Значение по умолчанию:
.Ql Pa yes
для обратной совместимости с
.Fx 9.0
и более ранними версиями.
.\" '.MAKE.cmd_filtered' специально не документирован,
.\" так как является внутренней деталью реализации.
.It Va .MAKE.DEPENDFILE
Имя make-файла (по умолчанию
.Sq Pa .depend ),
из которого читаются сгенерированные зависимости.
.It Va .MAKE.DIE_QUIETLY
Если установлено значение
.Ql true ,
не выводить информацию об ошибках в конце.
.It Va .MAKE.EXPAND_VARIABLES
Логическая переменная, которая управляет
поведением по умолчанию для опции
.Fl V .
Если true, значения переменных, выводимые с помощью
.Fl V ,
полностью разворачиваются; если false, показываются
необработанные содержимое переменных (которое может
включать дополнительные неразвёрнутые ссылки на переменные).
.It Va .MAKE.EXPORTED
Список переменных, экспортированных
.Nm .
.It Va MAKEFILE
Make-файл верхнего уровня, который в данный момент
читается, как указано в командной строке.
.It Va .MAKEFLAGS
Переменная окружения
.Sq Ev MAKEFLAGS
может содержать всё, что
может быть указано в командной строке
.Nm .
Всё, что указано в командной строке
.Nm ,
добавляется в переменную
.Va .MAKEFLAGS ,
которая затем добавляется в окружение для всех
программ, которые
.Nm
выполняет.
.It Va .MAKE.GID
Числовой идентификатор группы пользователя,
выполняющего
.Nm .
Переменная доступна только для чтения.
.It Va .MAKE.JOB.PREFIX
Если
.Nm
запущен с флагом
.Fl j ,
вывод для каждой цели помечается токеном
.Dl --- Ar target Li ---
первая часть которого может быть настроена
с помощью переменной
.Va .MAKE.JOB.PREFIX .
Если
.Va .MAKE.JOB.PREFIX
пуста, токен не выводится.
Например, установка
.Va .MAKE.JOB.PREFIX
в значение
.Ql ${.newline}---${.MAKE:T}[${.MAKE.PID}]
будет создавать такие токены, как
.Dl ---make[1234] Ar target Li --- ,
что облегчит отслеживание уровня достигнутого
параллелизма.
.It Va .MAKE.JOBS
Аргумент к опции
.Fl j .
.It Va .MAKE.LEVEL
Глубина рекурсии
.Nm .
Экземпляр
.Nm
верхнего уровня имеет уровень 0, и каждый дочерний
процесс make имеет уровень родителя плюс 1.
Это позволяет выполнять такие проверки, как:
.Li .if ${.MAKE.LEVEL} == 0
для защиты того, что должно оцениваться только в экземпляре
.Nm
верхнего уровня.
.It Va .MAKE.LEVEL.ENV
Имя переменной окружения, которая хранит уровень
вложенных вызовов
.Nm .
.It Va .MAKE.MAKEFILE_PREFERENCE
Упорядоченный список имён make-файлов
(по умолчанию
.Sq Pa makefile ,
.Sq Pa Makefile ),
которые
.Nm
ищет.
.It Va .MAKE.MAKEFILES
Список make-файлов, прочитанных
.Nm ,
что полезно для отслеживания зависимостей.
Каждый make-файл записывается только один раз,
независимо от количества раз, когда он был прочитан.
.It Va .MAKE.META.BAILIWICK
В
.Дq meta
режиме, предоставляет список префиксов,
соответствующих каталогам, контролируемым
.Nm .
Если отсутствует файл, сгенерированный за пределами
.Va .OBJDIR ,
но в пределах указанной области, текущая цель
считается устаревшей.
.It Va .MAKE.META.CMP_FILTER
В
.Дq meta
режиме, иногда (очень редко!) может быть полезно
фильтровать строки команд перед их сравнением.
Эта переменная может быть установлена на набор
модификаторов, которые применяются к каждой строке
старой и новой команды, которые различаются.
Если отфильтрованные команды по-прежнему
различаются, цель считается устаревшей.
.It Va .MAKE.META.CREATED
В
.Дq meta
режиме, эта переменная содержит список всех
обновлённых метафайлов. Если он не пуст, его
можно использовать для запуска обработки
.Va .MAKE.META.FILES .
.It Va .MAKE.META.FILES
В
.Дq meta
режиме, эта переменная содержит список всех
метафайлов, использованных (обновлённых или нет).
Этот список можно использовать для обработки метафайлов
и извлечения информации о зависимостях.
.It Va .MAKE.META.IGNORE_FILTER
Предоставляет список модификаторов переменных для
применения к каждому имени пути. Игнорирует, если
результат расширения — пустая строка.
.It Va .MAKE.META.IGNORE_PATHS
Предоставляет список префиксов путей, которые должны
быть проигнорированы, так как ожидается, что их
содержимое будет меняться со временем.
Список по умолчанию включает:
.Sq Pa /dev /etc /proc /tmp /var/run /var/tmp
.It Va .MAKE.META.IGNORE_PATTERNS
Предоставляет список шаблонов для сопоставления с
именами путей. Игнорируются все совпадающие пути.
.It Va .MAKE.META.PREFIX
Определяет сообщение, выводимое для каждого
обновлённого метафайла в
.Дq meta verbose
режиме.
Значение по умолчанию:
.Dl Building ${.TARGET:H:tA}/${.TARGET:T}
.It Va .MAKE.MODE
Обрабатывается после прочтения всех make-файлов.
Влияет на режим работы
.Nm .
Он может содержать следующие ключевые слова:
.Bl -tag -width indent
.It Cm compat
Как и
.Fl B ,
переводит
.Nm
в режим
.Дq compat .
.It Cm meta
Переводит
.Nm
в
.Дq meta
режим, в котором создаются метафайлы для каждой
цели для захвата команды, вывода и, если доступен
.Xr filemon 4 ,
системных вызовов, которые интересны
.Nm .
Захваченный вывод может быть полезен при диагностике ошибок.
.It Cm curdirOk= Ns Ar bf
По умолчанию
.Nm
не создаёт
.Pa .meta
файлы в
.Sq Va .CURDIR .
Это можно переопределить, установив
.Ar bf
в значение, представляющее true.
.It Cm missing-meta= Ns Ar bf
Если
.Ar bf
равно true, отсутствие
.Pa .meta
файла делает цель устаревшей.
.It Cm missing-filemon= Ns Ar bf
Если
.Ar bf
равно true, отсутствие данных filemon делает цель устаревшей.
.It Cm nofilemon
Не использовать
.Xr filemon 4 .
.It Cm env
Для отладки может быть полезно включить окружение
в
.Pa .meta
файл.
.It Cm verbose
Если в
.Дq meta
режиме, выводить сообщение о цели, которая строится.
Это полезно, если сборка проходит без вывода.
Выводимое сообщение — это расширенное значение
.Va .MAKE.META.PREFIX .
.It Cm ignore-cmd
Некоторые make-файлы содержат команды, которые просто
не стабильны. Это ключевое слово позволяет игнорировать
их при определении, является ли цель устаревшей в
.Дq meta
режиме.
См. также
.Иc .NOMETA_CMP .
.It Cm silent= Ns Ar bf
Если
.Ar bf
равно true, при создании .meta файла, цель
.Иc .SILENT .
.It Cm randomize-targets
В режимах compat и parallel цели создаются не в обычном
порядке, а в случайном. Этот режим можно использовать
для выявления неявных зависимостей между файлами.
.El
.It Va MAKEOBJDIR
Используется для создания файлов в отдельном каталоге, см.
.Va .OBJDIR .
.It Va MAKE_OBJDIR_CHECK_WRITABLE
Используется для принуждения к использованию отдельного
каталога для создаваемых файлов, даже если этот каталог
не доступен для записи, см.
.Va .OBJDIR .
.It Va MAKEOBJDIRPREFIX
Используется для создания файлов в отдельном каталоге, см.
.Va .OBJDIR .
.It Va .MAKE.OS
Имя операционной системы, см.
.Xr uname 1 .
Переменная доступна только для чтения.
.It Va .MAKEOVERRIDES
Эта переменная используется для записи имён переменных,
присвоенных в командной строке, чтобы они могли быть
экспортированы как часть
.Sq Ev MAKEFLAGS .
Это поведение можно отключить, присвоив
пустое значение переменной
.Sq Va .MAKEOVERRIDES
в make-файле.
Дополнительные переменные можно экспортировать
из make-файла, добавив их имена в
.Sq Va .MAKEOVERRIDES .
Переменная
.Sq Ev MAKEFLAGS
реэкспортируется каждый раз, когда
.Sq Va .MAKEOVERRIDES
изменяется.
.It Va .MAKE.PATH_FILEMON
Если
.Nm
был собран с поддержкой
.Xr filemon 4 ,
эта переменная указывает путь к файловому устройству.
Это позволяет make-файлам проверять наличие этой поддержки.
.It Va .MAKE.PID
Идентификатор процесса
.Nm .
Переменная доступна только для чтения.
.It Va .MAKE.PPID
Идентификатор родительского процесса
.Nm .
Переменная доступна только для чтения.
.It Va MAKE_PRINT_VAR_ON_ERROR
Когда
.Nm
завершается из-за ошибки, он устанавливает
.Sq Va .ERROR_TARGET
на имя цели, которая потерпела неудачу,
.Sq Va .ERROR_CMD
на команды этой цели,
а в
.Дq meta
режиме также устанавливает
.Sq Va .ERROR_CWD
на значение
.Xr getcwd 3
и
.Sq Va .ERROR_META_FILE
на путь к метафайлу (если он существует), описывающему
неудачную цель. Затем он выводит своё имя и значение
.Sq Va .CURDIR ,
а также значения всех переменных, упомянутых в
.Sq Va MAKE_PRINT_VAR_ON_ERROR .
.It Va .MAKE.SAVE_DOLLARS
Если true,
.Ql $$ .
становятся
.Ql $ .
по обычным правилам развёртывания.
Значение по умолчанию — false, для обратной совместимости.
Установите в true для совместимости с другими версиями make.
Если установлено в false,
.Ql $$ 
становятся
.Ql $ 
по обычным правилам развёртывания.
.It Va .MAKE.TARGET_LOCAL_VARIABLES
Если установлено в
.Ql false ,
явные присвоения переменных в строках зависимостей
рассматриваются как обычные источники.
.It Va .MAKE.UID
Числовой идентификатор пользователя, выполняющего
.Nm .
Переменная доступна только для чтения.
.\" 'MAKE_VERSION' намеренно не документирована,
.\" так как она определена только в дистрибуции bmake,
.\" но не в родном make NetBSD.
.\" '.meta.%d.lcwd' намеренно не документирована,
.\" так как это внутренняя деталь реализации.
.\" '.meta.%d.ldir' намеренно не документирована,
.\" так как это внутренняя деталь реализации.
.\" 'MFLAGS' намеренно не документирована,
.\" так как она устарела.
.It Va .newline
Эта переменная просто содержит символ новой строки
в качестве своего значения. Переменная доступна только
для чтения. Это позволяет использовать модификатор
.Cm \&:@
для вставки новой строки между
итерациями цикла вместо пробела.
Например, в случае ошибки,
.Nm
выводит имена переменных и их значения с помощью:
.Dl ${MAKE_PRINT_VAR_ON_ERROR:@v@$v='${$v}'${.newline}@}
.It Va .OBJDIR
Путь к каталогу, где создаются цели.
Его значение определяется путем попытки
.Xr chdir 2
в следующие каталоги по порядку, и использования
первого совпадения:
.Bl -enum
.It
.Cm ${MAKEOBJDIRPREFIX} Ns Cm ${.CURDIR}
.Pp
(Только если
.Sq Ev MAKEOBJDIRPREFIX
установлено в окружении или в командной строке.)
.It
.Cm ${MAKEOBJDIR}
.Pp
(Только если
.Sq Ev MAKEOBJDIR
установлено в окружении или в командной строке.)
.It
.Cm ${.CURDIR} Ns Pa /obj. Ns Cm ${MACHINE}
.It
.Cm ${.CURDIR} Ns Pa /obj
.It
.Pa /usr/obj/ Ns Cm ${.CURDIR}
.It
.Cm ${.CURDIR}
.El
.Pp
Перед использованием значение переменной разворачивается,
поэтому можно использовать выражения, такие как
.Cm ${.CURDIR:S,^/usr/src,/var/obj,}.
Это особенно полезно с переменной
.Sq Ev MAKEOBJDIR .
.Pp
Переменную
.Sq Va .OBJDIR
можно изменить в make-файле с помощью специальной цели
.Sq Ic .OBJDIR .
Во всех случаях,
.Nm
переходит в указанный каталог, если он существует,
и устанавливает
.Sq Va .OBJDIR
и
.Sq Va PWD
в этот каталог перед выполнением целей.
.Pp
За исключением случая явной
цели
.Sq Ic .OBJDIR ,
.Nm
проверяет, что указанный каталог доступен для записи,
и игнорирует его, если это не так. Эту проверку можно
пропустить, установив переменную окружения
.Sq Ev MAKE_OBJDIR_CHECK_WRITABLE
в значение
.Dq no .
.It Va .PARSEDIR
Имя каталога текущего make-файла, который разбирается.
.It Va .PARSEFILE
Имя текущего make-файла, который разбирается.
Эта переменная и
.Sq Va .PARSEDIR
устанавливаются только во время разбора make-файлов.
Чтобы сохранить их текущие значения,
присвойте их другой переменной с использованием
присвоения с развёртыванием
.Sq Cm \&:= .
.It Va .PATH
Пробелом разделённый список каталогов, в которых
.Nm
ищет файлы.
Для обновления этого списка поиска
используйте специальную цель
.Sq Ic .PATH
вместо того, чтобы изменять переменную напрямую.
.It Va %POSIX
Устанавливается в POSIX-режиме, см. специальную
.Ql Va .POSIX
цель.
.\" XXX: Нет переменной make с именем 'PWD',
.\" XXX: make только читает и записывает переменную окружения 'PWD'.
.It Va PWD
Альтернативный путь к текущему каталогу.
.Nm
обычно устанавливает
.Sq Va .CURDIR
в канонический путь, полученный с помощью
.Xr getcwd 3 .
Однако, если переменная окружения
.Sq Ev PWD
установлена и указывает путь к текущему каталогу,
.Nm
устанавливает
.Sq Va .CURDIR
в значение переменной
.Sq Ev PWD .
Это поведение отключается, если установлено значение
.Sq Ev MAKEOBJDIRPREFIX
или
.Sq Ev MAKEOBJDIR
содержит преобразование переменной.
.Sq Va PWD
устанавливается в значение
.Sq Va .OBJDIR
для всех программ, которые выполняет
.Nm .
.It Va .SHELL
Путь к оболочке, используемой для выполнения скриптов
целей. Переменная доступна только для чтения.
.It Va .SUFFIXES
Список известных суффиксов.
Переменная доступна только для чтения.
.It Va .SYSPATH
Пробелом разделённый список каталогов, в которых
.Nm
ищет make-файлы, называемый путём включений системы.
Для обновления этого списка используйте специальную цель
.Sq Ic .SYSPATH
вместо изменения переменной,
которая доступна только для чтения.
.It Va .TARGETS
Список целей, явно указанных в командной строке,
если таковые имеются.
.It Va VPATH
Разделённый двоеточием
.Пq Dq \&:
список каталогов, в которых
.Nm
ищет файлы.
Эта переменная поддерживается только для совместимости
с устаревшими программами make, используйте
.Sq Va .PATH
вместо неё.
.El
.Ss Модификаторы переменных
Общий формат развёртки переменной:
.Pp
.Sm off
.D1 Ic \&${ Ar variable\| Oo Ic \&: Ar modifier\| Oo Ic \&: No ... Oc Oc Ic \&}
.Sm on
.Pp
Каждый модификатор начинается с двоеточия.
Чтобы экранировать двоеточие, перед ним ставится
обратная косая черта
.Ql \e .
.Pp
Список косвенных модификаторов может быть указан
через переменную, как показано ниже:
.Pp
.Bd -literal -offset indent
.Ar modifier_variable\^ Li \&= Ar modifier Ns Oo Ic \&: Ns No ... Oc

.Sm off
.Ic \&${ Ar variable Ic \&:${ Ar modifier_variable Ic \&} Oo Ic \&: No ... Oc Ic \&}
.Sm on
.Ed
.Pp
В этом случае первый модификатор в
.Ar modifier_variable
не начинается с двоеточия,
так как это двоеточие уже присутствует в ссылающейся переменной.
Если любой из модификаторов в
.Ar modifier_variable
содержит знак доллара
.Pq Ql $ ,
их необходимо удвоить, чтобы избежать
преждевременного расширения.
.Pp
Некоторые модификаторы интерпретируют значение
выражения как одну строку, другие рассматривают
его как список слов, разделённых пробелами.
При разбиении строки на слова пробелы могут
экранироваться с помощью двойных кавычек,
одинарных кавычек и обратных косых черт,
как в оболочке. Кавычки и обратные косые
черты сохраняются в словах.
.Pp
Поддерживаемые модификаторы:
.Bl -tag -width EEE
.It Cm \&:E
Заменяет каждое слово его суффиксом.
.It Cm \&:H
Заменяет каждое слово именем его каталога (dirname).
.It Cm \&:M\| Ns Ar pattern
Выбирает только те слова, которые соответствуют
.Ar pattern .
Можно использовать стандартные
подстановочные символы оболочки
.Pf ( Ql * ,
.Ql \&? ,
и
.Ql \&[] ).
Подстановочные символы могут быть экранированы
обратной косой чертой
.Pq Ql \e .
Как следствие того, как значения разбиваются на
слова, сопоставляются и затем объединяются, конструкция
.Ql ${VAR:M*}
удаляет все начальные и конечные пробелы и нормализует
пробелы между словами до одного пробела.
.It Cm \&:N\| Ns Ar pattern
Это противоположность
.Sq Cm \&:M ,
выбирая все слова, которые
.Em не
соответствуют
.Ar pattern .
.It Cm \&:O
Упорядочивает слова в лексикографическом порядке.
.It Cm \&:On
Упорядочивает слова в числовом порядке.
Число, за которым следует одна из букв
.Ql k ,
.Ql M
или
.Ql G ,
умножается на соответствующий коэффициент,
который равен 1024 для
.Ql k ,
1048576 для
.Ql M ,
или 1073741824 для
.Ql G .
Принимаются как строчные, так и прописные буквы.
.It Cm \&:Or
Упорядочивает слова в обратном
лексикографическом порядке.
.It Cm \&:Orn
Упорядочивает слова в обратном числовом порядке.
.It Cm \&:Ox
Перемешивает слова.
Результаты будут разными при каждом обращении к
модифицированной переменной; используйте присвоение
с развёртыванием
.Sq Cm \&:=
чтобы предотвратить такое поведение.
Например:
.Bd -literal -offset indent
LIST=			uno due tre quattro
RANDOM_LIST=		${LIST:Ox}
STATIC_RANDOM_LIST:=	${LIST:Ox}

all:
	@echo "${RANDOM_LIST}"
	@echo "${RANDOM_LIST}"
	@echo "${STATIC_RANDOM_LIST}"
	@echo "${STATIC_RANDOM_LIST}"
.Ed
может вывести что-то вроде:
.Bd -literal -offset indent
quattro due tre uno
tre due quattro uno
due uno quattro tre
due uno quattro tre
.Ed
.It Cm \&:Q
Экранирует каждый метасимвол оболочки в значении,
чтобы его можно было безопасно передать в оболочку.
.It Cm \&:q
Экранирует каждый метасимвол оболочки в значении,
а также удваивает
.Sq $
символы, чтобы их можно было безопасно передавать
через рекурсивные вызовы
.Nm .
Это эквивалентно
.Sq Cm \&:S/\e\&$/&&/g:Q .
.It Cm \&:R
Заменяет каждое слово его именем без суффикса.
.It Cm \&:range Ns Oo Cm = Ns Ar count Oc
Значение является последовательностью целых чисел,
представляющей слова исходного значения или указанного
.Ar count .
.It Cm \&:gmtime Ns Oo Cm = Ns Ar timestamp Oc
Значение интерпретируется как строка формата для
.Xr strftime 3 ,
используя
.Xr gmtime 3 ,
формируя временную метку.
Если значение
.Ar timestamp
не указано или равно 0, используется текущее время.
.It Cm \&:hash
Вычисляет 32-битный хеш значения и кодирует его как
8 шестнадцатеричных цифр.
.It Cm \&:localtime Ns Oo Cm = Ns Ar timestamp Oc
Значение интерпретируется как строка формата для
.Xr strftime 3 ,
используя
.Xr localtime 3 ,
формируя временную метку.
Если значение
.Ar timestamp
не указано или равно 0, используется текущее время.
.It Cm \&:mtime Ns Oo Cm = Ns Ar timestamp Oc
Вызов
.Xr stat 2
для каждого слова как пути;
использует
.Ql st_mtime
в качестве нового значения.
Если
.Xr stat 2
завершается ошибкой; использует
.Ar timestamp
или текущее время.
Если значение
.Ar timestamp
установлено в
.Ql error ,
тогда ошибка
.Xr stat 2
приведёт к ошибке.
.It Cm \&:tA
Пытается преобразовать значение в абсолютный путь
с использованием
.Xr realpath 3 .
Если это не удаётся, значение остаётся неизменным.
.It Cm \&:tl
Преобразует значение в строчные буквы.
.It Cm \&:ts Ns Ar c
При объединении слов после модификатора, который
рассматривает значение как слова, слова обычно
разделяются пробелом. Этот модификатор изменяет
разделитель на символ
.Ar c .
Если
.Ar c
опущен, разделитель не используется.
Обычные экранирующие последовательности (включая
восьмеричные коды) работают, как ожидалось.
.It Cm \&:tu
Преобразует значение в прописные буквы.
.It Cm \&:tW
Заставляет последующие модификаторы рассматривать
значение как одно слово (возможно, содержащее
встроенные пробелы).
См. также
.Sq Cm \&:[*] .
.It Cm \&:tw
Заставляет значение рассматриваться как список слов.
См. также
.Sq Cm \&:[@] .
.Sm off
.It Cm \&:S\| No \&/ Ar old_string\| No \&/ Ar new_string\| No \&/ Op Cm 1gW
.Sm on
Изменяет первое вхождение
.Ar old_string
в каждом слове значения, заменяя его на
.Ar new_string .
Если
.Ql g
добавляется к последнему разделителю шаблона,
все вхождения в каждом слове заменяются.
Если
.Ql 1
добавляется к последнему разделителю шаблона,
только первое вхождение изменяется.
Если
.Ql W
добавляется к последнему разделителю шаблона,
значение рассматривается как одно слово.
Если
.Ar old_string
начинается с символа каретки
.Pq Ql ^ ,
.Ar old_string
закрепляется в начале каждого слова.
Если
.Ar old_string
заканчивается на знак доллара
.Pq Ql \&$ ,
он закрепляется в конце каждого слова.
Внутри
.Ar new_string ,
амперсанд
.Pq Ql &
заменяется на
.Ar old_string
(без закреплений
.Ql ^
или
.Ql \&$ ) .
Любой символ может быть использован в качестве
разделителя частей модификатора. Закрепления,
амперсанд и разделительные символы можно
экранировать обратной косой чертой
.Pq Ql \e .
.Pp
И
.Ar old_string ,
и
.Ar new_string
могут содержать вложенные выражения.
Чтобы предотвратить развёртывание знака доллара
в начале вложенного выражения, экранируйте его
с помощью обратной косой черты.
.Sm off
.It Cm \&:C\| No \&/ Ar pattern\| No \&/ Ar replacement\| No \&/ Op Cm 1gW
.Sm on
Модификатор
.Cm \&:C
работает так же, как и
.Cm \&:S ,
но старые и новые строки, вместо того чтобы быть
простыми строками, являются регулярным выражением
.Ar pattern
(см.
.Xr regex 3 )
и
.Xr ed 1 Ns \-стилем
.Ar replacement .
Обычно первое вхождение шаблона
.Ar pattern
в каждом слове значения заменяется на
.Ar replacement .
Модификатор
.Ql 1
заставляет замену применяться не более чем
к одному слову; модификатор
.Ql g
заставляет замену применяться ко всем вхождениям
шаблона
.Ar pattern
в слове или словах, в которых он найден; модификатор
.Ql W
заставляет значение рассматриваться как одно слово
(возможно, содержащее встроенные пробелы).
.Pp
Как и для модификатора
.Cm \&:S ,
шаблоны
.Ar pattern
и
.Ar replacement
подвергаются развёртыванию переменных до их обработки
как регулярных выражений.
.It Cm \&:T
Заменяет каждое слово на его последний
компонент пути (basename).
.It Cm \&:u
Удаляет соседние дублирующиеся слова (аналогично
.Xr uniq 1 ) .
.Sm off
.It Cm \&:\&?\| Ar true_string\| Cm \&: Ar false_string
.Sm on
Если имя переменной (а не её значение) при анализе как
.Cm .if
условного выражения оценивается как истинное,
возвращает значение
.Ar true_string ,
в противном случае возвращает
.Ar false_string .
Так как имя переменной используется как выражение,
модификатор \&:\&? должен быть первым после имени переменной
(которая, конечно, обычно содержит развёртки переменных).
Распространённая ошибка — попытка использовать выражения вроде
.Dl ${NUMBERS:M42:?match:no}
которые фактически проверяют определение переменной NUMBERS.
Чтобы определить, совпадают ли какие-либо слова с
.Дq 42 ,
нужно использовать что-то вроде:
.Dl ${"${NUMBERS:M42}" != \&"\&":?match:no} .
.It Cm :\| Ns Ar old_string\| Ns Cm = Ns Ar new_string
Это стиль замены в
.At V .
Он может быть последним модификатором,
так как двоеточие в
.Ar old_string
или
.Ar new_string
рассматривается как обычный символ,
а не как конец модификатора.
.Pp
Если
.Ar old_string
не содержит символ
.Ql % ,
и слово заканчивается на
.Ar old_string
или равно ему,
этот суффикс заменяется на
.Ar new_string .
.Pp
Иначе первый
.Ql %
в
.Ar old_string
соответствует, возможно, пустой подстроке произвольных
символов, и если весь шаблон найден в слове,
соответствующая часть заменяется на
.Ar new_string ,
а первый символ
.Ql %
в
.Ar new_string
(если имеется) заменяется на подстроку, соответствующую
.Ql % .
.Pp
И
.Ar old_string ,
и
.Ar new_string
могут содержать вложенные выражения. Чтобы предотвратить
развёртку знака доллара, начинающего вложенное выражение,
нужно экранировать его с помощью обратной косой черты.
.Sm off
.It Cm \&:@ Ar varname\| Cm @ Ar string\| Cm @
.Sm on
Это механизм развёртки циклов из среды разработки OSF (ODE) make.
В отличие от циклов
.Cm \&.for ,
развёртка происходит в момент ссылки. Для каждого слова
в значении, назначьте это слово переменной с именем
.Ar varname
и вычислите
.Ar string .
По соглашению ODE,
.Ar varname
должна начинаться и заканчиваться точкой, например:
.Dl ${LINKS:@.LINK.@${LN} ${TARGET} ${.LINK.}@}
.Pp
Однако переменная из одной буквы зачастую более читаема:
.Dl ${MAKE_PRINT_VAR_ON_ERROR:@v@$v='${$v}'${.newline}@}
.It Cm \&:_ Ns Oo Cm = Ns Ar var Oc
Сохраняет текущее значение переменной в
.Ql $_
или указанной переменной
.Ar var
для дальнейшей ссылки.
Пример использования:
.Bd -literal -offset indent
M_cmpv.units = 1 1000 1000000
M_cmpv = S,., ,g:_:range:@i@+ $${_:[-$$i]} \&\\
\\* $${M_cmpv.units:[$$i]}@:S,^,expr 0 ,1:sh

.Dv .if ${VERSION:${M_cmpv}} < ${3.1.12:L:${M_cmpv}}

.Ed
Здесь
.Ql $_
используется для сохранения результата модификатора
.Ql :S ,
который затем используется для обращения к индексам из
.Ql :range .
.It Cm \&:U\| Ns Ar newval
Если переменная не определена,
.Ar newval
становится значением.
Если переменная определена, возвращается текущее значение.
Эта функция полезна для настройки, например, целевых CFLAGS:
.Dl ${_${.TARGET:T}_CFLAGS:U${DEF_CFLAGS}}
Если значение требуется только в случае, если переменная
не определена, используйте:
.Dl ${VAR:D:Unewval}
.It Cm \&:D\| Ns Ar newval
Если переменная определена,
.Ar newval
становится значением.
.It Cm \&:L
Имя переменной становится значением.
.It Cm \&:P
Путь к узлу с таким же именем, как переменная,
становится значением. Если такой узел не существует
или его путь пуст, используется имя переменной.
Для работы этого модификатора имя (узел) должно хотя
бы однажды появиться в правой части зависимости.
.Sm off
.It Cm \&:\&! Ar cmd\| Cm \&!
.Sm on
Результат выполнения команды
.Ar cmd
становится значением.
.It Cm \&:sh
Значение выполняется как команда,
а результат становится новым значением.
.It Cm \&::= Ns Ar str
Переменной присваивается значение
.Ar str
после развёртывания.
Этот модификатор и его варианты полезны в редких
ситуациях, таких как необходимость задать переменную
в момент анализа команд цели. Эти модификаторы
присвоения всегда развёртываются в пустую строку.
.Pp
.Символы
.Sq Cm \&:: ,
помогают избежать ложных совпадений с
.At V
модификатором
.Ql \&:= ,
и поскольку развёртывание всегда происходит, форма
.Ql \&::=
кажется более подходящей.
.It Cm \&::?= Ns Ar str
Как для
.Cm \&::= ,
но только если переменная ещё не имеет значения.
.It Cm \&::+= Ns Ar str
Добавляет
.Ar str
к переменной.
.It Cm \&::!= Ns Ar cmd
Присваивает переменной результат выполнения команды
.Ar cmd .
.It Cm \&:\&[ Ns Ar range Ns Cm \&]
Выбирает одно или несколько слов из значения
или выполняет другие операции, связанные с тем, как
значение разбивается на слова.
.Pp
Пустое значение или значение, состоящее только из
пробелов, рассматривается как одно слово.
Для целей модификатора
.Символы
.Sq Cm \&:[] ,
слова индексируются как в прямом порядке
с использованием положительных целых чисел
(где индекс 1 представляет первое слово),
так и в обратном порядке с использованием
отрицательных чисел
(где индекс \-1 представляет последнее слово).
.Pp
Диапазон
.Ar range
подвергается развёртке переменных, а затем
интерпретируется следующим образом:
.Bl -tag -width index
.\" :[n]
.It Ar index
Выбирает одно слово из значения.
.\" :[start..end]
.It Ar start Ns Cm \&.. Ns Ar end
Выбирает все слова от
.Ar start
до
.Ar end ,
включительно.
Например,
.Sq Cm \&:[2..-1]
выбирает все слова от второго до последнего.
Если
.Ar start
больше, чем
.Ar end ,
слова выводятся в обратном порядке.
Например,
.Sq Cm \&:[-1..1]
выбирает все слова с конца до начала.
Если список уже отсортирован,
это фактически разворачивает список,
но эффективнее использовать
.Sq Cm \&:Or
вместо
.Sq Cm \&:O:[-1..1] .
.\" :[*]
.It Cm \&*
Заставляет последующие модификаторы рассматривать
значение как одно слово (возможно, содержащее
встроенные пробелы). Аналогично эффекту
.Li \&$*
в оболочке Bourne.
.\" :[0]
.It 0
Эквивалентно
.Символу
.Sq Cm \&:[*] .
.\" :[*]
.It Cm \&@
Заставляет последующие модификаторы рассматривать значение
как последовательность слов, разделённых пробелами.
Аналогично эффекту
.Li \&$@
в оболочке Bourne.
.\" :[#]
.It Cm \&#
Возвращает количество слов в значении.
.El \" :[range]
.El
.Sh ДИРЕКТИВЫ
.Nm
предоставляет директивы для включения make-файлов,
условных операторов и циклов for. Все эти директивы
идентифицируются строкой, начинающейся с одной точки
.Пq Ql \&.
символа, за которым следует ключевое слово директивы,
например
.Cm include
или
.Cm if .
.Ss Включение файлов
Файлы включаются с помощью
.Cm \&.include \&< Ns Ar file Ns Cm \&>
или
.Cm \&.include \&\*q Ns Ar file Ns Cm \&\*q .
Переменные внутри угловых скобок или двойных кавычек
разворачиваются для формирования имени файла.
Если используются угловые скобки, предполагается,
что включаемый make-файл находится в системном каталоге
make-файлов. Если используются двойные кавычки, каталог
включающего make-файла и любые каталоги,
указанные с помощью флага
.Fl I ,
просматриваются перед системным каталогом make-файлов.
.Pp
Для совместимости с другими версиями make
также поддерживается включение вида
.Sq Cm include Ar file No ...
(без ведущей точки).
.Pp
Если директива включения записана как
.Cm .-include
или как
.Cm .sinclude ,
ошибки при поиске и/или открытии включаемых
файлов игнорируются.
.Pp
Если директива включения записана как
.Cm .dinclude ,
игнорируются не только ошибки поиска и/или открытия
включаемых файлов, но также устаревшие зависимости
в файле включений игнорируются так же, как в
.Va .MAKE.DEPENDFILE .
.Ss Экспорт переменных
Директивы для экспорта и отмены экспорта
переменных следующие:
.Bl -tag -width Ds
.It Ic .export Ar variable No ...
Экспортирует указанную глобальную переменную.
Если список переменных не указан, экспортируются
все глобальные переменные, кроме внутренних
переменных (тех, которые начинаются с
.Ql \&. ).
Этот экспорт не зависит от флага
.Fl X ,
поэтому следует использовать его с осторожностью.
Для совместимости с другими версиями make
также поддерживается экспорт в виде
.Cm export Ar variable\| Ns Cm \&= Ns Ar value
(без ведущей точки).
.Pp
Добавление имени переменной в
.Va .MAKE.EXPORTED
эквивалентно экспорту переменной.
.It Ic .export-env Ar variable No ...
То же самое, что и
.Ql .export ,
но переменная не добавляется в
.Va .MAKE.EXPORTED .
Это позволяет экспортировать значение в окружение,
которое отличается от того, что используется
.Nm
внутренне.
.It Ic .export-literal Ar variable No ...
То же самое, что и
.Ql .export-env ,
но переменные внутри значения не разворачиваются.
.It Ic .unexport Ar variable No ...
Противоположно директиве
.Ql .export .
Указанная глобальная переменная
.Ar variable
удаляется из
.Va .MAKE.EXPORTED .
Если список переменных не указан, все глобальные
переменные отменяются, а
.Va .MAKE.EXPORTED
удаляется.
.It Ic .unexport-env
Отменяет экспорт всех ранее экспортированных глобальных
переменных и очищает окружение, унаследованное от
родительского процесса. Эта операция вызывает утечку
памяти оригинального окружения, поэтому её следует
использовать экономно. Имеет смысл выполнять проверку на
.Va .MAKE.LEVEL
с значением 0.
Также учтите, что все переменные, пришедшие из
родительского окружения, следует явно сохранить,
если это необходимо.
Например:
.Bd -literal -offset indent
.Li .if ${.MAKE.LEVEL} == 0
PATH := ${PATH}
.Li .unexport-env
.Li .export PATH
.Li .endif
.Pp
.Ed
Результатом будет окружение, содержащее только переменную
.Sq Ev PATH ,
которая является минимально полезным окружением.
.\" TODO: Проверьте ниже строку, переменные окружения не начинаются с '.'.
Фактически переменная
.Sq Va .MAKE.LEVEL
также будет добавлена в новое окружение.
.El
.Ss Сообщения
Директивы для вывода сообщений следующие:
.Bl -tag -width Ds
.It Ic .info Ar message
Сообщение выводится вместе с именем make-файла и номером строки.
.It Ic .warning Ar message
Сообщение с префиксом
.Sq Li warning:
выводится вместе с именем make-файла и номером строки.
.It Ic .error Ar message
Сообщение выводится вместе с именем make-файла и номером строки,
.Nm
завершается немедленно.
.El
.Ss Условные операторы
Директивы для условных операторов:
.ds maybenot Oo Ic \&! Oc Ns
.Bl -tag
.It Ic .if \*[maybenot] Ar expression Op Ar operator expression No ...
Проверяет значение выражения.
.It Ic .ifdef \*[maybenot] Ar variable Op Ar operator variable No ...
Проверяет, определена ли переменная.
.It Ic .ifndef \*[maybenot] Ar variable Op Ar operator variable No ...
Проверяет, не определена ли переменная.
.It Ic .ifmake \*[maybenot] Ar target Op Ar operator target No ...
Проверяет, запрашивается ли цель.
.It Ic .ifnmake \*[maybenot] Ar target Op Ar operator target No ...
Проверяет, не запрашивается ли цель.
.It Ic .else
Изменяет смысл предыдущего условного оператора на противоположный.
.It Ic .elif \*[maybenot] Ar expression Op Ar operator expression No ...
Комбинация
.Sq Ic .else
и
.Sq Ic .if .
.It Ic .elifdef \*[maybenot] Ar variable Op Ar operator variable No ...
Комбинация
.Sq Ic .else
и
.Sq Ic .ifdef .
.It Ic .elifndef \*[maybenot] Ar variable Op Ar operator variable No ...
Комбинация
.Sq Ic .else
и
.Sq Ic .ifndef .
.It Ic .elifmake \*[maybenot] Ar target Op Ar operator target No ...
Комбинация
.Sq Ic .else
и
.Sq Ic .ifmake .
.It Ic .elifnmake \*[maybenot] Ar target Op Ar operator target No ...
Комбинация
.Sq Ic .else
и
.Sq Ic .ifnmake .
.It Ic .endif
Завершает тело условного оператора.
.El
.Pp
Аргумент
.Ar operator
может быть любым из следующих:
.Bl -tag
.It Ic \&|\&|
Логическое ИЛИ.
.It Ic \&&&
Логическое И, приоритет выше, чем у
.Символа
.Sq Ic \&|\&| .
.El
.Pp
.Nm
оценивает условие только до тех пор, пока не определит
его значение. Скобки можно использовать для изменения
приоритета операторов. Логический оператор
.Символа
.Sq Ic \&!
может использоваться для логического отрицания всего
условного оператора. Его приоритет выше, чем у
.Символа
.Sq Ic \&&& .
.Pp
Значение
.Ar expression
может быть одним из следующих вызовов функций:
.Bl -tag
.Sm off
.It Ic defined Li \&( Ar varname Li \&)
.Символ
.Sm on
Оценивается как истина, если переменная
.Ar varname
определена.
.Sm off
.It Ic make Li \&( Ar target Li \&)
.Sm on
Оценивается как истина, если цель
была указана в командной строке
.Nm
или была объявлена как цель по умолчанию
(либо неявно, либо явно, см.
.Va .MAIN )
до строки, содержащей условный оператор.
.Sm off
.It Ic empty Li \&( Ar varname Oo Li : Ar modifiers Oc Li \&)
.Sm on
Оценивается как истина, если развёртка переменной,
после применения модификаторов, приводит к пустой строке.
.Sm off
.It Ic exists Li \&( Ar pathname Li \&)
.Sm on
Оценивается как истина, если указанный путь существует.
Если путь относительный, он ищется в системных каталогах поиска (см.
.Va .PATH ).
.Sm off
.It Ic target Li \&( Ar target Li \&)
.Sm on
Оценивается как истина, если цель была определена.
.Sm off
.It Ic commands Li \&( Ar target Li \&)
.Sm on
Оценивается как истина, если цель была определена
и у неё есть связанные команды.
.El
.Pp
Аргумент
.Ar expression
также может быть арифметическим или строковым сравнением.
Развёртка переменных происходит с обеих сторон сравнения.
Если обе стороны являются числовыми и ни одна из них не
заключена в кавычки, сравнение выполняется числовым образом,
в противном случае — лексикографически. Строка интерпретируется
как шестнадцатеричное целое число, если она начинается с
.Li 0x ,
в противном случае она считается десятичным числом
с плавающей запятой; восьмеричные числа не поддерживаются.
.Pp
Все сравнения могут использовать операторы
.Sq Ic \&==
и
.Sq Ic \&!= .
Числовые сравнения могут также использовать операторы
.Sq Ic \&< ,
.Sq Ic \&<= ,
.Sq Ic \&>
и
.Sq Ic \&>= .
.Pp
Если сравнение не имеет оператора сравнения и правой стороны,
выражение оценивается как истина, если оно непустое
и его числовое значение (если есть) не равно нулю.
.Pp
Когда
.Nm
оценивает одно из этих условных выражений и сталкивается с
(разделённым пробелами) словом, которое оно не распознаёт,
к нему применяется либо
функция
.Dq make ,
либо
.Dq defined ,
в зависимости от формы условного выражения.
Если форма
.Sq Ic .ifdef ,
.Sq Ic .ifndef
или
.Sq Ic .if ,
применяется функция
.Dq defined .
Аналогично, если форма
.Sq Ic .ifmake
или
.Sq Ic .ifnmake ,
применяется функция
.Dq make .
.Pp
Если условие оценивается как истинное, анализ make-файла
продолжается, как и прежде. Если оно оценивается как ложное,
последующие строки пропускаются. В обоих случаях это
продолжается до тех пор, пока не будет найдено соответствующее
.Sq Ic .else
или
.Sq Ic .endif .
.Ss Циклы for
Циклы for обычно используются для применения набора правил
к списку файлов. Синтаксис цикла for следующий:
.Pp
.Bl -tag -compact -width Ds
.It Ic \&.for Ar variable Oo Ar variable No ... Oc Ic in Ar expression
.It Aq Ar make-lines
.It Ic \&.endfor
.El
.Pp
Аргумент
.Ar expression
разворачивается и затем разбивается на слова. На каждой итерации
цикла одно слово берётся и присваивается каждой
.Ar variable ,
по порядку, и эти
.Ar variables
подставляются в
.Ar make-lines
в теле цикла for. Количество слов должно совпадать с количеством
переменных; то есть, если есть три итерационные переменные,
количество слов должно быть кратным трём.
.Pp
Если в теле цикла
.Cm \&.for
встречается директива
.Sq Ic .break ,
это приводит к досрочному завершению цикла, в противном случае
возникает ошибка синтаксиса.
.\" TODO: Описать ограничения с defined/empty.
.Ss Другие директивы
.Bl -tag -width Ds
.It Ic .undef Ar variable No ...
Отменяет определение указанных глобальных переменных.
Только глобальные переменные могут быть отменены.
.El
.Sh КОММЕНТАРИИ
Комментарии начинаются с символа решётки
.Pq Ql \&#
в любом месте, кроме строк с командами оболочки, и продолжаются
до конца строки, не экранированной обратной косой чертой.
.Sh ОСОБЫЕ ИСТОЧНИКИ (АТРИБУТЫ)
.Bl -tag -width .IGNOREx
.It Ic .EXEC
Цель никогда не считается устаревшей, но команды всё равно
всегда выполняются.
.It Ic .IGNORE
Игнорирует любые ошибки команд, связанных с этой целью,
так же, как если бы все они были предварены символом тире
.Пq Ql \- .
.\" .It Ic .INVISIBLE
.\" XXX
.\" .It Ic .JOIN
.\" XXX
.It Ic .MADE
Отмечает все источники этой цели как актуальные.
.It Ic .MAKE
Выполняет команды, связанные с этой целью,
даже если были указаны
.Fl n
или
.Fl t .
Обычно используется для обозначения рекурсивных
.Nm Ns 's .
.It Ic .META
Создаёт метафайл для цели, даже если она помечена как
.Ic .PHONY ,
.Ic .MAKE
или
.Ic .SPECIAL .
Использование вместе с
.Ic .MAKE
является наиболее вероятным случаем.
В
.Дq meta
режиме цель считается устаревшей, если метафайл отсутствует.
.It Ic .NOMETA
Не создаёт метафайл для цели.
Метафайлы также не создаются для целей с атрибутами
.Ic .PHONY ,
.Ic .MAKE
или
.Ic .SPECIAL .
.It Ic .NOMETA_CMP
Игнорирует различия в командах при определении, устарела ли цель.
Это полезно, если команда содержит значения, которые всегда
изменяются. Однако, если изменяется количество команд, цель всё
равно считается устаревшей. Аналогичный эффект применяется к
любой строке команды, использующей переменную
.Va .OODATE ,
которая может использоваться для этой цели, даже если она не
требуется или не желательна:
.Bd -literal -offset indent

skip-compare-for-some:
	@echo это сравнивается
	@echo это не сравнивается ${.OODATE:M.NOMETA_CMP}
	@echo это тоже сравнивается

.Ed
Модификатор
.Cm \&:M
подавляет любое развёртывание ненужной переменной.
.It Ic .NOPATH
Не ищет цель в каталогах, указанных в
.Va .PATH .
.It Ic .NOTMAIN
Обычно
.Nm
выбирает первую встреченную цель в качестве цели
по умолчанию для сборки, если не указана другая цель.
Этот источник предотвращает выбор данной цели.
.It Ic .OPTIONAL
Если цель помечена этим атрибутом и
.Nm
не может выяснить, как её создать, он игнорирует
этот факт и предполагает, что файл либо не нужен,
либо уже существует.
.It Ic .PHONY
Цель не соответствует реальному файлу;
она всегда считается устаревшей и не создаётся при
использовании опции
.Fl t .
Правила трансформации суффиксов не применяются к
.Ic .PHONY
целям.
.It Ic .PRECIOUS
Когда
.Nm
прерывается, он обычно удаляет любые частично
созданные цели. Этот источник предотвращает удаление цели.
.It Ic .RECURSIVE
Синоним для
.Ic .MAKE .
.It Ic .SILENT
Не выводит команды, связанные с этой целью, так же,
как если бы все они были предварены символом
.Пq Ql @ .
.It Ic .USE
Преобразует цель в макрос
.Nm .
Когда цель используется в качестве источника для другой
цели, последняя наследует команды, источники и атрибуты
(за исключением
.Ic .USE )
от источника.
Если у цели уже есть команды, команды
.Ic .USE
будут добавлены к ним.
.It Ic .USEBEFORE
Как
.Ic .USE ,
но вместо добавления в конец команд они добавляются в начало.
.It Ic .WAIT
Если
.Ic .WAIT
встречается в строке зависимости, источники, предшествующие ей,
должны быть собраны до того, как начнётся сборка последующих
источников в этой строке. Так как зависимости от файлов не
собираются, пока сам файл не может быть собран, это также
останавливает сборку зависимостей, если они не нужны для другой
ветви дерева зависимостей. Таким образом, при следующем содержимом:
.Bd -literal
x: a .WAIT b
	echo x
a:
	echo a
b: b1
	echo b
b1:
	echo b1

.Ed
вывод всегда будет
.Ql a ,
.Ql b1 ,
.Ql b ,
.Ql x .
.Pp
Порядок, установленный
.Ic .WAIT ,
имеет значение только в режиме параллельной сборки.
.El
.Sh ОСОБЫЕ ЦЕЛИ
Особые цели не могут включаться вместе с другими целями,
т.е. они должны быть единственными указанными целями.
.Bl -tag -width .BEGINx
.It Ic .BEGIN
Все строки команд, связанные с этой целью, выполняются до того,
как будет сделано что-либо ещё.
.It Ic .DEFAULT
Это своего рода
.Ic .USE
правило для любой цели (используемой только как источник),
которую
.Nm
не может создать никаким другим способом.
Только скрипт оболочки используется.
Переменная
.Va .IMPSRC
цели, унаследовавшей команды
.Ic .DEFAULT ,
устанавливается в собственное имя цели.
.It Ic .DELETE_ON_ERROR
Если эта цель присутствует в make-файле, она глобально
заставляет make удалять цели, чьи команды завершились с ошибкой.
(По умолчанию удаляются только те цели, чьи команды были
прерваны во время выполнения. Это историческое поведение.)
Этот параметр можно использовать для предотвращения оставления
полуготовых или повреждённых целей, которые могут испортить
будущие сборки.
.It Ic .END
Все строки команд, связанные с этой целью, выполняются после того,
как всё остальное было успешно выполнено.
.It Ic .ERROR
Все строки команд, связанные с этой целью,
выполняются при сбое другой цели. Переменная
.Va .ERROR_TARGET
устанавливается на имя цели, которая не была выполнена.
См. также
.Va MAKE_PRINT_VAR_ON_ERROR .
.It Ic .IGNORE
Помечает каждый из источников атрибутом
.Ic .IGNORE .
Если источники не указаны, это эквивалентно указанию опции
.Fl i .
.It Ic .INTERRUPT
Если
.Nm
прерывается, команды для этой цели выполняются.
.It Ic .MAIN
Если при вызове
.Nm
не указана ни одна цель, то строится эта цель.
.It Ic .MAKEFLAGS
Эта цель позволяет указывать флаги для
.Nm
во время чтения make-файлов.
Флаги передаются так, как будто они введены в командной
строке, хотя опция
.Fl f
не имеет эффекта.
.\" XXX: ПОКА НЕ РЕАЛИЗОВАНО!!!!
.\" .It Ic .NOTPARALLEL
.\" Названные цели выполняются в непараллельном режиме.
.\" Если цели не указаны,
.\" все цели выполняются в непараллельном режиме.
.It Ic .NOPATH
Применяет атрибут
.Ic .NOPATH
ко всем указанным источникам.
.It Ic .NOTPARALLEL
Отключает параллельный режим.
.It Ic .NO_PARALLEL
Синоним для
.Ic .NOTPARALLEL ,
для совместимости с другими версиями pmake.
.It Ic .NOREADONLY
Снимает атрибут «только для чтения» с глобальных
переменных, указанных как источники.
.It Ic .OBJDIR
Источник представляет собой новое значение для
.Sq Va .OBJDIR .
Если оно существует,
.Nm
меняет текущий рабочий каталог на этот путь и
обновляет значение
.Sq Va .OBJDIR .
.It Ic .ORDER
В параллельном режиме указанные цели собираются
по порядку. Этот порядок не добавляет цели в список
целей для сборки.
.Pp
Так как зависимости цели не строятся, пока сама
цель не может быть собрана, если
.Ql a
строится другой частью графа зависимостей,
следующее создаёт цикл зависимостей:
.Bd -literal
\&.ORDER: b a
b: a
.Ed
.Pp
.\" XXX: ПОКА НЕ РЕАЛИЗОВАНО!!!!
.\" .It Ic .PARALLEL
.\" Названные цели выполняются в параллельном режиме.
.\" Если цели не указаны,
.\" все цели выполняются в параллельном режиме.
.It Ic .PATH
Источники являются каталогами, которые нужно искать
для файлов, не найденных в текущем каталоге. Если источники
не указаны, все ранее указанные каталоги удаляются из пути
поиска. Если источником является специальная цель
.Ic .DOTLAST ,
текущий рабочий каталог ищется последним.
.It Ic .PATH. Ns Ar suffix
Как
.Ic .PATH ,
но применяется только к файлам с определённым суффиксом.
Суффикс должен быть ранее объявлен с помощью
.Ic .SUFFIXES .
.It Ic .PHONY
Применяет атрибут
.Ic .PHONY
к указанным источникам.
.It Ic .POSIX
Если это первая непустая строка в основном make-файле,
переменной
.Va %POSIX
присваивается значение
.Ql 1003.2
и файл make-файла
.Ql <posix.mk>
включается, если существует,
для обеспечения совместимости с POSIX.
Если
.Nm
запущен с опцией
.Fl r ,
только
.Ql posix.mk
влияет на правила по умолчанию.
.It Ic .PRECIOUS
Применяет атрибут
.Ic .PRECIOUS
к указанным источникам.
Если источники не указаны, атрибут
.Ic .PRECIOUS
применяется ко всем целям в make-файле.
.It Ic .READONLY
Устанавливает атрибут «только для чтения» для глобальных
переменных, указанных как источники.
.It Ic .SHELL
Устанавливает оболочку, которую
.Nm
использует для выполнения команд в режиме сборки.
Источники — это набор пар
.Ar поле\| Ns Cm \&= Ns Ar значение .
.Bl -tag -width ".Li hasErrCtls"
.It Li name
Это минимальная спецификация, используемая для выбора одной
из встроенных спецификаций оболочки;
.Li sh ,
.Li ksh ,
и
.Li csh .
.It Li path
Указывает абсолютный путь к оболочке.
.It Li hasErrCtl
Указывает, поддерживает ли оболочка выход при ошибке.
.It Li check
Команда для включения проверки ошибок.
.It Li ignore
Команда для отключения проверки ошибок.
.It Li echo
Команда для включения отображения команд,
выполняемых оболочкой.
.It Li quiet
Команда для отключения отображения команд.
.It Li filter
Вывод для фильтрации после выполнения команды
.Li quiet .
Обычно это та же команда, что и
.Li quiet .
.It Li errFlag
Флаг для передачи оболочке для включения проверки ошибок.
.It Li echoFlag
Флаг для передачи оболочке для включения отображения команд.
.It Li newline
Строка, передаваемая оболочке, которая выводит один символ
новой строки, когда используется вне каких-либо кавычек.
.El
Пример:
.Bd -literal
\&.SHELL: name=ksh path=/bin/ksh hasErrCtl=true \e
	check="set \-e" ignore="set +e" \e
	echo="set \-v" quiet="set +v" filter="set +v" \e
	echoFlag=v errFlag=e newline="'\en'"
.Ed
.It Ic .SILENT
Применяет атрибут
.Ic .SILENT
к указанным источникам.
Если источники не указаны, атрибут
.Ic .SILENT
применяется ко всем командам в файле.
.It Ic .STALE
Эта цель запускается, когда файл зависимостей содержит
устаревшие записи, и переменная
.Va .ALLSRC
устанавливается на имя этого файла зависимостей.
.It Ic .SUFFIXES
Каждый источник указывает суффикс для
.Nm .
Если источники не указаны, все ранее указанные суффиксы
удаляются. Это позволяет создавать правила трансформации
суффиксов.
.Pp
Пример:
.Bd -literal
\&.SUFFIXES: .c .o
\&.c.o:
	cc \-o ${.TARGET} \-c ${.IMPSRC}
.Ed
.It Ic .SYSPATH
Источники — это каталоги, которые добавляются в системный путь
.Nm
для поиска make-файлов.
Если источники не указаны, все ранее указанные каталоги
удаляются из системного пути.
.El
.Sh ОКРУЖЕНИЕ
.Nm
использует следующие переменные окружения, если они существуют:
.Ev MACHINE ,
.Ev MACHINE_ARCH ,
.Ev MAKE ,
.Ev MAKEFLAGS ,
.Ev MAKEOBJDIR ,
.Ev MAKEOBJDIRPREFIX ,
.Ev MAKESYSPATH ,
.Ev PWD ,
и
.Ev TMPDIR .
.Pp
.Ev MAKEOBJDIRPREFIX
и
.Ev MAKEOBJDIR
могут быть установлены только в окружении или командной строке
.Nm ,
а не как переменные make-файла;
см. описание переменной
.Sq Va .OBJDIR
для подробностей.
.Sh ФАЙЛЫ
.Bl -tag -width /usr/share/mk -compact
.It .depend
список зависимостей
.It makefile
первый файл по умолчанию, если make-файл
не указан в командной строке
.It Makefile
второй файл по умолчанию, если make-файл
не указан в командной строке
.It sys.mk
системный make-файл
.It /usr/share/mk
системный каталог make-файлов
.El
.Sh СОВМЕСТИМОСТЬ
Базовый синтаксис make совместим между различными версиями make;
однако специальные переменные, модификаторы переменных и
условные операторы не совместимы.
.Ss Старые версии
Неполный список изменений в старых версиях
.Nm :
.Pp
Способ подстановки переменных цикла .for изменился после
.Nx 5.0 ,
так что они теперь по-прежнему выглядят как развёртки переменных.
В частности, это останавливает их от того, чтобы рассматриваться
как синтаксис, и устраняет некоторые редкие проблемы при их
использовании в операторах .if.
.Pp
Способ планирования параллельных сборок изменился в
.Nx 4.0 ,
так что .ORDER и .WAIT применяются рекурсивно к зависимым узлам.
Алгоритмы могут снова измениться в будущем.
.Ss Другие диалекты make
Другие диалекты make (GNU make, SVR4 make, POSIX make и др.)
не поддерживают большинство возможностей
.Nm ,
описанных в этом руководстве.
Особенно:
.Bl -bullet -offset indent
.It
Директивы
.Ic .WAIT
и
.Ic .ORDER ,
а также большинство возможностей, связанных с параллелизацией.
(GNU make поддерживает параллелизацию, но не имеет возможностей
для её эффективного управления.)
.It
Директивы, включая циклы for и условные операторы, а также
большинство форм включения файлов.
(GNU make имеет собственный несовместимый и менее мощный
синтаксис для условных операторов.)
.\" Менее мощный означает, что в GNU make нет функций make(target), target(target) и commands(target).
.It
Все встроенные переменные, начинающиеся с точки.
.It
Большинство специальных источников и целей, начинающихся с точки,
за исключением
.Ic .PHONY ,
.Ic .PRECIOUS
и
.Ic .SUFFIXES .
.It
Модификаторы переменных, за исключением
.Ql :old=new
замены строк, которая не поддерживает сопоставление с шаблоном
.Ql % 
и исторически работает только для объявленных суффиксов.
.It
Переменная
.Ic $>
даже в её короткой форме; большинство make поддерживают
эту функциональность, но её имя варьируется.
.El
.Pp
Некоторые возможности более переносимы,
такие как присваивание с помощью
.Ic += ,
.Ic ?= ,
и
.Ic != .
Функциональность
.Va .PATH
основана на старой возможности
.Ic VPATH ,
найденной в GNU make и многих версиях SVR4 make; однако
исторически её поведение слишком неопределённое
(и слишком багованное), чтобы на неё полагаться.
.Pp
Переменные
.Ic $@
и
.Ic $<
являются более или менее универсально переносимыми, как и
.Ic $(MAKE)
переменная. Основное использование правил суффиксов
(только для файлов в текущем каталоге, не пытаясь связать
трансформации вместе и т.д.) также достаточно переносимо.
.Sh СМ. ТАКЖЕ
.Xr mkdep 1 ,
.Xr style.Makefile 5
.Sh ИСТОРИЯ
Команда
.Nm
появилась в
.At v7 .
Эта
.Nm
реализация основана на программе pmake Адама де Буэра,
которая была написана для Sprite в Беркли. Она была
разработана как параллельная распределённая программа make,
запускающая задачи на различных машинах с использованием
демона под названием
.Дq customs .
.Pp
Исторически целью/зависимостью
.Ic FRC
использовали для принудительного пересборки
(так как цель/зависимость не существует ...
пока кто-то не создаст файл
.Pa FRC ).
.Sh ОШИБКИ
Синтаксис
.Nm
сложен для анализа.
Например, для того, чтобы найти конец использования
переменной, нужно проанализировать каждый из модификаторов,
используя правильный терминатор для каждого поля.
Во многих местах
.Nm
просто подсчитывает {} и () для нахождения
конца развёртки переменной.
.Pp
Нет способа экранировать символ пробела в имени файла.
.Pp
В режиме параллельных задач, когда цель терпит неудачу;
.Nm
добавляет маркер ошибки в пул маркеров задач.
Это приводит к тому, что все другие экземпляры
.Nm
использующие этот пул маркеров, прекращают сборку и
выходят с кодом ошибки 6. Иногда попытка подавить
каскад ненужных ошибок может привести к кажущейся
необъяснимой ошибке
.Ql *** Error code 6
