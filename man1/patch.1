.\"-
.\" Copyright 1986, Ларри Уолл
.\"
.\" Распространение и использование в исходном коде и двоичной форме, с использованием или без использования
.\" модификаций, если следующие условия
.\" соблюдаются:
.\" 1. При распространении исходного кода должно сохраняться вышеуказанное уведомление
.\"    об авторских правах, этот список условий и следующий дисклеймер.
.\"
.\" ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ПРАВООБЛАДАТЕЛЯМИ И СОАВТОРАМИ ``КАК ЕСТЬ'', И 
.\" МЫ ОТКАЗЫВАЕМСЯ ОТ ЛЮБЫХ ПОДРАЗУМЕВАЕМЫХ ОБЯЗАТЕЛЬСТВ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ, 
.\" ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ И НЕПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННОЙ
.\" ЦЕЛИ. НИ В КОЕМ СЛУЧАЕ ПРАВООБЛАДАТЕЛИ ИЛИ СОВАТОРЫ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ
.\" ЗА ЛЮБЫЕ ПРЯМЫЕ, КОСВЕННЫЕ, СЛУЧАЙНЫЕ, ОСОБЫЕ, ПОКАЗАТЕЛЬНЫЕ ИЛИ ЛОГИЧЕСКИ ВЫТЕКАЮЩИЕ
.\" УБЫТКИ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ, ПРИОБРЕТЕНИЕ ЗАМЕНЯЮЩИХ ТОВАРОВ ИЛИ УСЛУГ;
.\" ПОТЕРЮ ВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ, ДАННЫХ ИЛИ ПРИБЫЛИ; ИЛИ ПРЕКРАЩЕНИЕ ДЕЯТЕЛЬНОСТИ)
.\" НЕЗАВИСИМО ОТ ПРИЧИНЕННОГО УЩЕРБА И НА ОСНОВАНИИ ЛЮБОЙ ТЕОРИИ ОТВЕТСТВЕННОСТИ, БУДЬ ТО В РАМКАХ КОНТРАКТА, 
.\" ПРЯМОЙ ОТВЕТСТВЕННОСТИ ИЛИ ДЕЛИКТА (ВКЛЮЧАЯ ХАЛАТНОСТЬ ИЛИ ИНОЕ), ВОЗНИКШЕГО КАКИМ-ЛИБО ОБРАЗОМ
.\" В РЕЗУЛЬТАТЕ ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ, ДАЖЕ ЕСЛИ ВЫ БЫЛИ ОСВЕДОМЛЕНЫ О ВОЗМОЖНОСТИ
.\" ТАКОГО УЩЕРБА.
.\"
.\" $OpenBSD: patch.1,v 1.27 2014/04/15 06:26:54 jmc Exp $
.Dd 3 ноября, 2019 год
.Dt PATCH 1
.Os
.Sh НАЗВАНИЕ
.Nm patch
.Nd apply a diff file to an original
.Sh СИНТАКСИС
.Nm
.Bk -words
.Op Fl bCcEeflNnRstuv
.Op Fl B Ar бэкап-префикс 
.Op Fl D Ar символ
.Op Fl d Ar директория
.Op Fl F Ar макс-фаззинг
.Op Fl i Ar патч-файл
.Op Fl o Ar исходящий-файл
.Op Fl p Ar подсчет-полос
.Op Fl r Ar имя-реджекта
.Op Fl V Cm t | nil | never | none
.Op Fl x Ar номер
.Op Fl z Ar бэкап-расширение
.Op Fl Fl posix
.Op Ar исходный файл Op Ar патч-файл
.Ek
.Nm
.Pf \*(Lt Ar патч-файл
.Sh ОПИСАНИЕ
.Nm
потребуется патч-файл, содержащий любую из четырех форм списка отличий,
созданного программой
.Xr diff 1
и применит эти различия к исходному файлу,
создав пропатченную версию.
Если
.Ar патч-файл
пропущен, или это дефис, патч будет считан со стандартного ввода.
.Pp
.Nm
попытается определить тип списка различий, если это не будет отменено опцией
.Fl c ,
.Fl e ,
.Fl n ,
или
.Fl u 
опцией.
Контекстные различия (старого образца, нового образца и унифицированные) и
обычные различия применяются непосредственно самой программой
.Nm , 
принимая во внимание, что различия в ed являются просто фидом для редатора
.Xr ed 1
пайпа via.
.Pp
Если
.Ar патч-файл
содержит более одного патча,
.Nm
постарается применить каждый из них так, как если бы они были взяты из отдельных патч-файлов.
Это означает, среди прочего, что предполагается, что имя патч-файла
должно быть определено для каждого списка различий, и что мусор перед
каждым списком различий будет проверяться на наличие таких примечательных вещей, как имена файлов 
и уровень ревизии (смотрите раздел, посвященный
.Sx Filename Determination
ниже).
.Pp
Возможны следующие опции:
.Bl -tag -width Ds
.It Xo
.Fl B Ar бэкап-префикс ,
.Fl Fl prefix Ar backup-prefix
.Xc
Приводит к тому, что следующий аргумент интерпретируется как префикс к
имени бэкап-файла.
Если этот аргумент указан, то любой аргумент для
.Fl z
будет проигнорирован.
.It Fl b , Fl Fl backup
Сохраняет бэкап-копию файла до того, как он будет изменен.
По умолчанию исходный файл сохраняется с расширением бэкапа
.Qq .orig
если только в файле уже нет пронумерованной резервной копии, в этом случае создается пронумерованная
резервная копия.
Это эквивалентно указанию
.Qo Fl V Cm existing Qc .
Сейчас эта опция используется по умолчанию, если только
.Fl -posix
не указан.
.It Fl C , Fl Fl check , Fl Fl dry-run
Проверяет, будет ли патч применен правильно, но ничего не изменяет.
.It Fl c , Fl Fl context
Заставляет
.Nm
интерпретировать патч-файл как контекстное различие.
.It Xo
.Fl D Ar символ ,
.Fl Fl ifdef Ar symbol
.Xc
Заставляет
.Nm
использовать конструкцию
.Qq #ifdef...#endif
чтобы отметить изменения.
Следующий аргумент будет использоваться в качестве отличительного символа.
Обратите внимание, что, в отличие от компилятора C, между
.Fl D
и аргументом должен быть пробел.
.It Xo
.Fl d Ar директория ,
.Fl Fl directory Ar directory
.Xc
Заставляет
.Nm
интерпретировать следующий аргумент как директорию
и изменить на него рабочую директорию, прежде чем делать что-либо еще.
.It Fl E , Fl Fl remove-empty-files
Заставляет
.Nm
удалить выходные файлы, которые остаются пустыми после применения исправлений.
Эта опция полезна при применении патчей, которые создают или удаляют файлы.
.It Fl e , Fl Fl ed
Заставляет
.Nm
интерпретировать патч-файл как
.Xr ed 1
скрипт.
.It Xo
.Fl F Ar макс-фаззинг ,
.Fl Fl fuzz Ar max-fuzz
.Xc
Устанавливает максимальный показатель фаззинга.
Этот параметр применяется только к различиям в контексте и заставляет
.Nm
игнорировать указанное количество строк при поиске мест для установки блока.
Обратите внимание, что больший показатель фаззинга увеличивает вероятность появления неисправного патча.
Показатель фаззинга по умолчанию равен 2, и он не может быть установлен больше, чем
количество строк контекста в разнице контекста, обычно 3.
.It Fl f , Fl Fl force
Заставляет
.Nm
предполагать, что пользователь точно знает, что он или она делает, и не
задавать никаких вопросов.
Это предполагает следующее:
пропускать патчи, для которых не удается найти файл для патча;
патч-файлы, даже если они имеют неправильную версию для
.Qq Prereq :
строка в патче;
и предположим, что патчи не реверсируются, даже если они выглядят так, как будто они есть.
Эта опция не запрещает комментарии; используйте
.Fl s
для этого.
.It Xo
.Fl i Ar патч-файл ,
.Fl Fl input Ar patchfile
.Xc
заставляет следующий аргумент интерпретироваться как имя входного файла
(т.е. патч-файла).
Этот параметр может быть задан несколько раз.
.It Fl l , Fl Fl ignore-whitespace
вызывает свободное сопоставление с образцом, на случай, если символы табуляции и пробела
во входном файле были заменены.
Любая последовательность пробелов в строке шаблона будет соответствовать любой последовательности
во входном файле.
Обычные символы по-прежнему должны точно совпадать.
Каждая строка контекста по-прежнему должна совпадать со строкой во входном файле.
.It Fl N , Fl Fl forward
Заставляет
.Nm
игнорировать патчи, которые, как он думает, отменены или уже применены.
Смотрите также
.Fl R .
.It Fl n , Fl Fl normal
Заставляет
.Nm
интерпретировать патч-файл как обычное различие.
.It Xo
.Fl o Ar исходящий-файл ,
.Fl Fl output Ar out-file
.Xc
Заставляет следующий аргумент интерпретироваться как имя выходного файла.
.It Xo
.Fl p Ar подсчет-полос ,
.Fl Fl strip Ar strip-count
.Xc
Задает имя пути подсчета полос,
который управляет обработкой путей, найденных в патч-файле,
на случай, если вы храните свои файлы в директории, отличной от директории человека, отправившего
патч.
подсчет полос определяет, сколько косых черт должно быть зачеркнуто в
начале имени пути.
(Все промежуточные имена директорий также удаляются.)
Например, предположим, что имя файла в патч-файле было
.Pa /u/howard/src/blurfl/blurfl.c :
.Pp
Настройка
.Fl p Ns Ar 0
указывает полный путь без изменений.
.Pp
.Fl p Ns Ar 1
дает
.Pp
.D1 Pa u/howard/src/blurfl/blurfl.c
.Pp
без начальной косой черты.
.Pp
.Fl p Ns Ar 4
дает
.Pp
.D1 Pa blurfl/blurfl.c
.Pp
Не уточняя
.Fl p
вообще, просто дает вам
.Pa blurfl.c ,
если только не все директории в начальном пути
.Pq Pa u/howard/src/blurfl
существуют, и этот путь относителен,
и в этом случае вы получаете полный путь без изменений.
Все, что у вас получится, будет найдено либо в текущей директории,
либо в директории, котрая указана
.Fl d
опцией.
.It Fl R , Fl Fl reverse
Сообщает
.Nm
что этот патч был создан с помощью того, что старые и новые файлы поменялись местами.
(Да, боюсь, такое иногда случается, такова уж природа 
человека.)
.Nm
попытается поменять местами каждый фрагмент, прежде чем применять его.
Отклоненные заявки будут выдаваться в измененном формате.
Опция
.Fl R
не будет работать с различиями скриптов ed, поскольку слишком мало
информации для реконструкции реерса операции.
.Pp
Если первый фрагмент патча выходит из строя,
.Nm
реверсирует фрагмент, чтобы посмотреть, можно ли его применить таким образом.
Если это возможно, вас спросят, хотите ли вы иметь
.Fl R
набор параметров
Если это невозможно, пластырь будет продолжать применяться в обычном режиме.
(Примечание: этот метод не может обнаружить реверсированный патч, если это обычное различие
и если первая команда - это append (т.е. это должно было быть delete), поскольку добавления всегда завершаются успешно из-за того, что нулевой контекст будет совпадать
где угодно.
К счастью, большинство исправлений добавляют или изменяют строки, а не удаляют их, поэтому большинство
реверсированных обычных разниц начинаются с удаления, которое завершается ошибкой, запускающей
эвристику.)
.It Xo
.Fl r Ar имя-реджекта ,
.Fl Fl reject-file Ar rej-name
.Xc
Заставляет следущий аргумент интерпретироваться как имя реджект-файла.
.It Xo
.Fl s , Fl Fl quiet ,
.Fl Fl silent
.Xc
Позоляет
.Nm
выполняться бесшумно, пока не произойдет ошибка.
.It Fl t , Fl Fl batch
Аналогичен
.Fl f ,
в том, что он подавляет вопросы, но делает некоторые другие предположения:
пропускать патчи, для которых не удается найти пач-файл (аналогично
.Fl f ) ;
пропускать патчи, для которых файл имеет неправильную версию для строки
.Qq Prereq :
в патче;
предполагать, что патчи реверсируются, если они выглядят так, как есть.
.It Fl u , Fl Fl unified
Заставляет
.Nm
интерпретировать файл патч-файл как унифицированная контекстное различие (unidiff).
.It Xo
.Fl V Cm t | nil | never | none ,
.Fl Fl version-control Cm t | nil | never | none
.Xc
Засталяет следующий аргумент интерпретироваться как метод создания
имен бэкап-файлов.
Тип создаваемых бэкапов также может быть задан в переменных среды
.Ev PATCH_VERSION_CONTROL
или
.Ev VERSION_CONTROL ,
которые переопределяются этой опцией.
Опция
.Fl B
переопределяет эту опцию, в результате чего префикс всегда используется для
создания имен бэкап-файлов.
Значения переменных среды
.Ev PATCH_VERSION_CONTROL
и
.Ev VERSION_CONTROL
и аргумент опции
.Fl V
аналогичны переменной управления версиями GNU Emacs
.Dq version-control ;
они также распознают синонимы, которые являются более описательными.
Допустимыми значениями являются (допускаются уникальные сокращения):
.Bl -tag -width Ds -offset indent
.It Cm t , numbered
Всегда создает пронумерованные бэкапы.
.It Cm nil , existing
Создавайте пронумерованные бэкапы, у которых они уже есть,
простые бэкапы остальных файлов.
.It Cm never , simple
Всегда создает простые бэкапы.
.It Cm none
Не создает бэкапы.
.El
.It Fl v , Fl Fl version
Заставляет файл 
.Nm
выводить свой заголовок версии и уровень патча
.It Xo
.Fl x Ar номер ,
.Fl Fl debug Ar number
.Xc
Устанавливает внутренние флаги отладки и представляет интерес только для
.Nm
патчеров.
.It Xo
.Fl z Ar бэкап-расширение ,
.Fl Fl suffix Ar backup-ext
.Xc
Заставляет следующий файл интерпретироваться как  расширение бэкапа, которое
которое будет использоваться вместо
.Qq .orig .
.It Fl Fl posix
Включает строгое соответствие
.St -p1003.1-2008 ,
в частности:
.Bl -enum
.It
Бэкап-файлы не содаются, если опция
.Fl b
не указана.
.It
Если не указано, то используемое имя файла является первым из существующих старых, новых и
индексных файлов.
.El
.El
.Ss Patch Application
.Nm
попытается пропустить любой начальный мусор, применит различия,
а затем пропустит любой конечный мусор.
Таким образом, вы можете отправить артикул или сообщение, содержащее список
различий, в файл
.Nm ,
и это должно сработать.
Если вся разница имеет постоянный отступ,
это будет принято во внимание.
.Pp
С контекстными различиями и, в меньшей степени, с обычными различиями,
.Nm
может определить, когда номера строк, указанные в патче, неверны,
и попытается найти правильное место для нанесения каждого фрагмента патча.
В качестве первого предположения используется номер строки, указанный для данного фрагмента, плюс или
минус любое смещение, использованное при применении предыдущего фрагмента.
Если это неправильное место,
.Nm
будет сканировать вперед и назад в поисках набора строк, соответствующих контексту,
указанному в фрагменте.
Сначала
.Nm
ищет место, где все строки контекста совпадают.
Если такое место не найдено, и это контекстное различие, а максимальный показатель фаззинга
установлен равным 1 или более, то выполняется повторное сканирование, игнорирующее первую и последнюю
строки контекста.
Если это не удается и максимальный показатель фаззинга установлен равным 2 или более,
первые две и последние две строки контекста игнорируются
и выполняется повторное сканирование.
.Pq The default maximum fuzz factor is 2 .
.Pp
Если
.Nm
не может найти место для установки этого фрагмента патча, он будет помещен
в реджект-файл, который обычно является именем выходного файла плюс
.Qq .rej .
(Обратите внимание, что отклоненный фрагмент будет отображаться в виде контекстного различия, независимо от того, был ли
входной патч контекстым различием или обычным различием.
Если бы входные данные были обычным различием, многие контексты были бы просто нулевыми.)
Номера строк для фрагментов в реджект-файле могут отличаться
от номеров строк патч-файле: они отражают приблизительное местоположение, в котором, по мнению патча,
находятся неудачные фрагменты в новом файле, а не в старом.
.Pp
По мере завершения каждого фрагмента вам будет сообщаться, был ли он выполнен успешно или
неудачно, и какая строка (в новом файле)
.Nm
считает, что фрагмент должен быть продолжен.
Если это значение отличается от номера строки, указанного в различии,
вам будет сообщено смещение.
Единичное большое смещение МОЖЕТ свидетельствовать о том, что фрагмент был установлен не в
том месте.
Вам также сообщат, был ли использован параметр фаззинга для определения соответствия, и в этом
случае у вас также должны возникнуть некоторые подозрения.
.Ss Filename Determination
Если в командной строке не указан исходный файл,
.Nm
попытается выяснить из начального мусора, как называется
редактируемый файл.
При проверке предполагаемого имени файла компоненты имени пути удаляются, 
как указано в опции
.Fl p
и проверяется существование файла и возможность его записи относительно
текущей рабочеей директории (или указанной в опции
.Fl d
директории).
.Pp
Если различие является контекстным или унифицированным,
.Nm
может определять старые и новые имена файлов по заголовку различия.
Для контекстных различий, файл
.Dq old
указан в строке, начинающейся с
.Qq ***
и файл
.Dq new
указывается в строке, начинающейся с
.Qq --- .
Для унифицированных различий, файл
.Dq old
указывается в строке, начинающейся с
.Qq ---
и файл
.Dq new
указывается в строке, начинающейся с
.Qq +++ .
Если строка
.Qq Index :
есть в начальном мусоре (независимо от типа различия),
.Nm
будет использовать имя файла из этой строки в качестве
.Dq index
файла.
.Pp
.Nm
выберет имя файла, выполнив следующие действия, используя первое
совпадение:
.Bl -enum
.It
Если
.Nm
Работает в строгом режиме
.St -p1003.1-2008 ,
используется первое из существующих в
.Dq old ,
.Dq new
и
.Dq index
файловых имен.
В противном случае
.Nm
проверяет имена файлов
.Dq old
и
.Dq new
или, для неконтекстных различий, имя файла
.Dq index ,
и выберите имя файла с наименьшим количеством компонентов пути,
самым коротким базовым именем и самой короткой общей длиной имени файла (в таком порядке).
.It
Если подходящего файла для исправления найдено не было, патч-файл является контекстным или
унифицированным различием, а старый файл имел нулевую длину,
создается и используется новое имя файла.
.It
Если имя файла по-прежнему не может быть определено,
.Nm
предложит пользователю ввести имя файла для использования.
.El
.Pp
Кроме того, если строка
.Qq Prereq:\ \&
содержится в начальном мусоре,
.Nm
возьмет первое слово из строки предварительных требований (обычно
это номер версии) и проверит входной файл, чтобы узнать, можно ли найти это слово.
Если нет, то
.Nm
запросит подтверждение, прежде чем продолжить.
.Pp
В результате всего этого вы должны иметь возможность сообщить, находясь в новостном
интерфейсе, следующее:
.Pp
.Dl | patch -d /usr/src/local/blurfl
.Pp
и пропатчить файл в директории blurfl непосредственно из артикула, содержащего
патч.
.Ss Backup Files
По умолчанию пропатченная версия устанавливается вместо исходной,
а резервная копия исходного файла сохраняется с тем же именем и расширением
.Qq .orig ,
или в соответствии с указаниями
.Fl B ,
.Fl V ,
или
.Fl z
опциями.
Расширение, используемое для бэкап-файлов, также может быть указано в переменной среды
.Ev SIMPLE_BACKUP_SUFFIX
который переопределяется указанными выше параметрами.
.Pp
Если бэкап-файл содержит символическую или жесткую ссылку на исходный файл,
.Nm
создает новое имя бэкап-файла, изменяя первую строчную букву
в последней части имени файла на заглавную.
Если в имени больше нет строчных букв,
из него удаляется первый символ.
Он повторяет этот процесс до
тех пор, пока не получит бэкап-файл, который еще не существует или не связан с исходным файлом.
.Pp
Вы также можете указать, куда вы хотите поместить выходные данные с помощью опции
.Fl o ; 
если этот файл уже существует, сначала создается его бэкап.
.Ss Notes For Patch Senders
Есть несколько вещей, которые вам следует иметь в виду, если вы собираетесь
рассылать патчи:
.Pp
Во-первых, вы можете избавить людей от многих проблем, сохранив файл
.Pa patchlevel.h
который пропатчен для повышения уровня патча, в качестве первого
изменения в отправляемом вами патч-файле.
Если вы добавите строку
.Qq Prereq :
вместе с патчем,то это не позволит им применять
патчи не по порядку без какого-либо предупреждения.
.Pp
Во-вторых, убедитесь, что вы правильно указали имена файлов, либо
в заголовке с контекстным различием, либо с помощью
.Qq Index :
строки.
Если вы  патчите что-то в субдиректории, обязательно сообщите патч
пользователю, чтобы он указал опцию
.Fl p
по мере необходимости.
.Pp
В-третьих, вы можете создать файл, отправив различие, которое сравнивает
пустой файл с файлом, который вы хотите создать.
Если файл, который вы хотите создать, уже существует в целевой директории 
на момент применения, то
.Nm
определит патч как потенциально реверсированный и предложит реверсировать патч.
.Pp
В-четвертых, следите за тем, чтобы не рассылать реверсированные патчи, поскольку это
заставляет людей задуматься, применяли ли они уже этот патч.
.Pp
В-пятых,  в то время как вам, возможно, удастся обойтись размещением 582 списков изменений в
одном файле, вероятно, разумнее сгруппировать связанные патчи в отдельные файлы на
случай, если что-то пойдет не так.
.Sh ENVIRONMENT
.Bl -tag -width "PATCH_VERSION_CONTROL" -compact
.It Ev POSIXLY_CORRECT
Если этот параметр установлен,
.Nm
ведет себя так, как будто опция
.Fl Fl posix
была указана.
.It Ev SIMPLE_BACKUP_SUFFIX
Расширение, используемое для имен бкап-файлов вместо
.Qq .orig .
.It Ev TMPDIR
Директория для размещения временных файлов; по умолчанию это 
.Pa /tmp .
.It Ev PATCH_VERSION_CONTROL
Выбирает, когда будут создаваться пронумерованные бэкапы файлов.
.It Ev VERSION_CONTROL
То же, что и
.Ev PATCH_VERSION_CONTROL .
.El
.Sh FILES
.Bl -tag -width "$TMPDIR/patch*" -compact
.It Pa $TMPDIR/patch*
.Nm
временные файлы
.It Pa /dev/tty
используются для чтения входных данных, когда
.Nm
запрашивает у пользователя
.El
.Sh СТАТУС ЗАВЕРШЕНИЯ
Утилита
.Nm
завершает работу с одним из следующих значений:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It 0
Успешное завершение.
.It 1
Одна или несколько строк были записаны в реджект-файл.
.It \*(Gt1
Произошла ошибка.
.El
.Pp
При циклическом применении патч-сета вам следует проверить этот
статус завершения, чтобы не применять более поздний патч к частично пропатченному файлу.
.Sh ДИАГНОСТИКА
Слишком много, чтобы перечислять их здесь, но в целом указывает, что
.Nm
couldn't parse your patch file.
не удалось распарсить ваш патч-файл.
.Pp
Сообщение
.Qq Hmm...
указывает, что в файле исправления есть необработанный текст и что
.Nm
пытается интуитивно определить, есть ли в этом тексте патч и, если да,
то что это за патч.
.Sh СМОТРИТЕ ТАКЖЕ
.Xr diff 1
.Sh СТАНДАРТЫ
Утилита
.Nm
совместима с
.St -p1003.1-2008
спецификацией,
за исключением случаев, описанных выше для
.Fl -posix
опции.
.Pp
Флаги
.Op Fl BCEFfstVvxz
и
.Op Fl -posix
являются расширениями этой спецификации.
.Sh АВТОРЫ
.An Larry Wall
со многими другими соавторами.
.Sh ПРЕДОСТЕРЕЖЕНИЕ
.Nm
не может определить, не указаны ли номера строк в скрипте редактирования, и может обнаружить
неверные номера строк в обычном различии только при обнаружении
.Qq change
или
.Qq delete
команды.
Контекстное различие с использованием параметра фаззинга 3 может привести к той же проблеме.
До тех пор, пока не будет добавлен подходящий интерактивный интерфейс, вам, вероятно, следует провести
контекстное различие в этих случаях, чтобы понять, имеют ли изменения смысл.
Конечно, компиляция без ошибок - довольно хороший признак того, что патч
сработал, но не всегда.
.Pp
.Nm
обычно выдает правильные результаты, даже если приходится делать много догадок.
Однако гарантированно корректные результаты будут получены только в том случае, если патч будет
применен точно к той же версии файла, на основе которой он был
сгенерирован.
.Sh БАГИ
Можно было бы поумнее относиться к частичным совпадениям, чрезмерно отклоняющимся смещениям и
измененному коду, но для этого потребовалась бы дополнительная проверка.
.Pp
Проверка патчей в режиме
.Pq Fl C
завершится неудачей, если вы попытаетесь последовательно проверить несколько патчей, основанных друг на
друге.
Весь код
.Nm
должен быть реструктурирован, чтобы сохранить временные файлы, чтобы он
мог справиться с этой ситуацией.
.Pp
Если код был продублирован (например, с помощью #ifdef OLDCODE ... #else ...
#endif),
.Nm
не способен пропатчить обе версии, и, если он вообще заработает, скорее всего,
пропатчит неправильную и сообщит вам, что загрузка прошла успешно.
.Pp
Если вы примените исправление, которое вы уже применяли,
.Nm
подумает, что это исправление в обратном порядке, и предложит его отменить.
Это может быть истолковано как фича.
