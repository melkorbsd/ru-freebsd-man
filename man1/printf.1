.\" Copyright (c) 1989, 1990, 1993
.\"	Ректоры Калифорнийского университета. Все права защищены.
.\"
.\" Этот код основан на программном обеспечении, предоставленном в Беркли
.\" Institute of Electrical and Electronics Engineers, Inc.
.\"
.\" Распространение и использование в исходном коде и двоичной форме, с использованием или без использования
.\" модификаций, если следующие условия
.\" соблюдаются:
.\" 1. При распространении исходного кода должно сохраняться вышеуказанное уведомление
.\"    об авторских правах, этот список условий и следующий дисклеймер.
.\" 2. При распространиении в двоичной форме должно воспроизводиться уведомление об авторских правах,
.\"    этот список условий и следующий ниже отказ от ответственности в
.\"    документации и/или других материалах, поставляемых с дистрибутивом.
.\" 3. Ни название университета, ни имена его участников не могут быть использованы для
.\"    поддержки или продвижения продуктов, созданных на основе данного программного обеспечения,
.\"    без специального предварительного письменного согласия.
.\"
.\" ДАННОЕ ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ ПРЕДОСТАВЛЯЕТСЯ ПРАВООБЛАДАТЕЛЯМИ И СОАВТОРАМИ ``КАК ЕСТЬ'', И 
.\" МЫ ОТКАЗЫВАЕМСЯ ОТ ЛЮБЫХ ПОДРАЗУМЕВАЕМЫХ ОБЯЗАТЕЛЬСТВ, ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ, 
.\" ПОДРАЗУМЕВАЕМЫЕ ГАРАНТИИ ТОВАРНОЙ ПРИГОДНОСТИ И НЕПРИГОДНОСТИ ДЛЯ ОПРЕДЕЛЕННОЙ
.\" ЦЕЛИ. НИ В КОЕМ СЛУЧАЕ ПРАВООБЛАДАТЕЛИ ИЛИ СОВАТОРЫ НЕ НЕСУТ ОТВЕТСТВЕННОСТИ
.\" ЗА ЛЮБЫЕ ПРЯМЫЕ, КОСВЕННЫЕ, СЛУЧАЙНЫЕ, ОСОБЫЕ, ПОКАЗАТЕЛЬНЫЕ ИЛИ ЛОГИЧЕСКИ ВЫТЕКАЮЩИЕ
.\" УБЫТКИ (ВКЛЮЧАЯ, НО НЕ ОГРАНИЧИВАЯСЬ ИМИ, ПРИОБРЕТЕНИЕ ЗАМЕНЯЮЩИХ ТОВАРОВ ИЛИ УСЛУГ;
.\" ПОТЕРЮ ВОЗМОЖНОСТИ ИСПОЛЬЗОВАНИЯ, ДАННЫХ ИЛИ ПРИБЫЛИ; ИЛИ ПРЕКРАЩЕНИЕ ДЕЯТЕЛЬНОСТИ)
.\" НЕЗАВИСИМО ОТ ПРИЧИНЕННОГО УЩЕРБА И НА ОСНОВАНИИ ЛЮБОЙ ТЕОРИИ ОТВЕТСТВЕННОСТИ, БУДЬ ТО В РАМКАХ КОНТРАКТА, 
.\" ПРЯМОЙ ОТВЕТСТВЕННОСТИ ИЛИ ДЕЛИКТА (ВКЛЮЧАЯ ХАЛАТНОСТЬ ИЛИ ИНОЕ), ВОЗНИКШЕГО КАКИМ-ЛИБО ОБРАЗОМ
.\" В РЕЗУЛЬТАТЕ ИСПОЛЬЗОВАНИЯ ДАННОГО ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ, ДАЖЕ ЕСЛИ ВЫ БЫЛИ ОСВЕДОМЛЕНЫ О ВОЗМОЖНОСТИ
.\" ТАКОГО УЩЕРБА.
.\"
.\"	@(#)printf.1	8.1 (Berkeley) 6/6/93
.\"
.Dd July 1, 2020
.Dt PRINTF 1
.Os
.Sh НАЗВАНИЕ
.Nm printf
.Nd formatted output
.Sh СИНТАКСИС
.Nm
.Ar формат Op Ar аргументы ...
.Sh ОПИСАНИЕ
Утилита
.Nm
форматирует и выводит свои аргументы, начиная со второго, под управлением
.Ar формат.
Аргумент
.Ar Формат
— это строка символов, которая содержит три типа объектов: обычные символы,
которые просто копируются в стандартный вывод, последовательности символов для экранирования,
которые преобразуются и копируются в стандартный вывод, и спецификации формата,
каждая из которых вызывает вывод следующего
.Ar аргумент.
.Pp
Аргументы
.Ar
после первого рассматриваются как строки, если соответствующий формат
либо
.Cm c, b
или
.Cm s;
в противном случае он вычисляется как константа C со следующими расширениями:
.Pp
.Bl -bullet -offset indent -compact
.It
Допускается использование ведущего знака плюс или минус.
.It
Если ведущий символ является одинарной или двойной кавычкой, значение является
кодом символа следующего символа.
.El
.Pp
Строка формата используется столько раз, сколько необходимо, чтобы удовлетворить
.Ar аргументы .
Любые дополнительные спецификации формата оцениваются как ноль или пустая 
строка.
.Pp
Последовательности экранирования символов находятся в нотации обратного слеша, как определено в
.St -ansiC ,
с расширениями.
Символы и их значения 
следующие:
.Pp
.Bl -tag -width Ds -offset indent -compact
.It Cm \ea
Записать символ <звонок>.
.It Cm \eb
Записать символ <забой>.
.It Cm \ef
Записать символ <перевод формата>.
.It Cm \en
Записать символ <новая строка>.
.It Cm \er
Записать символ <возврат каретки>.
.It Cm \et
Записать символ <табуляция>.
.It Cm \ev
Записать символ <вертикаль табуляция>.
.It Cm \e\'
Записать символ <одинарная кавычка>.
.It Cm \e\e
Записать символ <обратная косая черта>.
.It Cm \e Ns Ar число
Записывает байт, значение которого — 1-, 2- или 3-значное
октальное число
.Ar число .
Многобайтовые символы могут быть сконструированы с использованием нескольких
.Cm \e Ns Ar число
последовательностей.
.El
.Pp
Каждая спецификация формата начинается с символа процента
(``%'').
Оставшаяся часть спецификации формата включает в себя,
в следующем порядке:
.Bl -tag -width Ds
.It ""Ноль или более следующих флагов:"
.Bl -tag -width Ds
.It Cm #
Символ `#`,
указывающий, что значение должно быть напечатано в "альтернативной форме".
Для форматов
.Cm b , c , d , s
и
.Cm u
этот параметр не имеет эффекта.
Для формата
.Cm o
точность числа увеличивается, чтобы первый 
символ выходной строки был нулём.
Для форматов
.Cm x
.Pq Cm X,
если результат не равен нулю, к нему добавляется строка
.Li 0x
.Pq Li 0X.
Для форматов
.Cm a, A, e, E, f, F, g
и
.Cm G,
результат всегда будет содержать десятичную точку, даже если 
за точкой не следуют цифры (обычно десятичная точка появляется 
в результатах этих форматов, только если за точкой следует цифра).
Для форматов
.Cm g
и
.Cm G
конечные нули в результате не удаляются, 
как это обычно происходит;
.It Cm &-
Знак минуса `\-' указывает на
.Em Выравнивание по левому краю
выхода в указанном поле;
.It Cm \&+
Символ `+' указывает, что всегда должен быть 
знак, помещенный перед числом при использовании форматов со знаком.
.It Sq \&\ \&
Пробел указывает, что пробел должен быть оставлен перед положительным числом 
для формата со знаком. 
Символ `+' имеет приоритет над пробелом, если используются оба;
.It Cm \&0
Символ нуля `0' указывает, что должно использоваться
заполнение нулями, вместо заполнения пробелами.
Знак минуса `\-' имеет приоритет над `0', если используются оба;
.El
.It "Field Width:"
Опциональная последовательность цифр, указывающая
.Em ширина поля ;
если строка вывода содержит меньше байтов, чем ширина поля, она будет
дополнена пробелами слева (или справа, если индикатор выравнивания по левому краю
задан), чтобы достичь ширины поля (обратите внимание, что ведущий ноль
является флагом, но встроенный ноль является частью ширины поля);
.It Precision:
Опциональный период,
.Sq Cm \&.\& ,
за которым следует необязательная последовательность цифр, задающая
.Em точность
которая указывает количество цифр после десятичной точки 
для форматов
.Cm e
и
.Cm f
или максимальное количество байтов, которые будут выведены 
из строки; если последовательность цифр отсутствует, точность считается 
равной нулю;
.It Format:
Символ, который указывает тип используемого формата (один из
.Cm diouxXfFeEgGaAcsb ) .
Форматы в верхнем регистре отличаются от их аналогов в нижнем регистре только тем,
что результат выполнения первых полностью написаны в верхнем регистре.
Спецификаторы формата с плавающей точкой
.Pq Cm fFeEgGaA
могут быть предварены
.Cm L
чтобы запросить использование дополнительной точности, если возможно.
.El
.Pp
Ширина поля или точность могут быть
.Sq Cm \&*
вместо последовательности цифр.
В этом случае
.Ar аргумент
определяет ширину поля или точность.
.Pp
Символы формата и их значения:
.Bl -tag -width Fl
.It Cm diouXx
Аргумент
.Ar аргумент
выводится как знаковое десятичное число (d или i), беззнаковое восьмеричное, беззнаковое десятичное,
или беззнаковое шестнадцатеричное (X или x) соответственно.
.It Cm fF
Аргумент
.Ar аргумент
выводится в стиле `[-]ddd.ddd', где количество d после десятичной точки
соответствует спецификации точности для
аргумента.
Если точность отсутствует, задается 6 цифр; если точность
явно равна 0, цифры и десятичная точка не выводятся.
Значения *[If] и *[Na] выводятся как
.Ql inf
и
.Ql nan ,
соответственно.
.It Cm eE
Аргумент
.Ar аргумент
выводится в стиле
.Cm e
.Sm off
.Sq Op - Ar d.ddd No \(+- Ar dd
.Sm on
where there
где перед шестнадцатеричной точкой находится одна цифра, а количество цифр после неё соответствует
указанной точности для аргумента; когда точность не указана,
производится 6 цифр.
когда точность не указана, производится достаточное количество цифр для точного представления аргумента в формате двойной точности с плавающей запятой.
ЗЗначения \*[If] и \*[Na] выводятся как
.Ql inf
и
.Ql nan ,
соответственно.
.It Cm gG
Аргумент
.Ar аргумент
выводится  стиле
.Cm f
.Pq Cm F
или в стиле
.Cm e
.Pq Cm E
в зависимости от того, что обеспечивает полную точность с минимальным занимаемым пространством.
.It Cm aA
Аргумент
.Ar аргумент
выводится в стиле
.Sm off
.Sq Op - Ar h.hhh No \(+- Li p Ar d
.Sm on
где перед шестнадцатеричной точкой находится одна цифра, а количество цифр
после неё соответствует указанной точности для аргумента;
когда точность не указана, производится достаточное количество цифр для
точного представления аргумента в формате двойной точности с плавающей запятой.
Значения \*[If] и \*[Na] выводятся как
.Ql inf
и
.Ql nan ,
соответственно.
.It Cm c
Первый байт
.Ar аргумент
выводится.
.It Cm s
Байты из строки
.Ar аргумент
 выводятся до достижения конца или пока не будет достигнуто количество байт,
указанное в спецификации точности; однако, если
точность равна 0 или отсутствует, строка выводится полностью.
.It Cm b
Так же, как и для
.Cm s ,
но интерпретирует последовательности управляющих символов с обратным слешем в строке
.Ar аргумент .
 Разрешенные последовательности управляющих символов немного отличаются тем, что восьмеричные управляющие последовательности 
 записываются как 
.Cm \e0 Ns Ar num
вместо
.Cm \e Ns Ar num
и дополнительная последовательность управляющих символов 
.Cm \ec
рекращает дальнейший вывод из этого
.Nm
вызова.
.It Cm n$
Позволяет изменять порядок вывода в соответствии с
.Ar аргумент .
.It Cm \&%
Выводит `%'; аргумент не используется..
.El
.Pp
Символ десятичной точки
определяется в локали программы (категория
.Dv LC_NUMERIC ) .
.Pp
Ни в одном случае отсутствие или малый размер поля не приводит к обрезанию 
поля; поля; заполнение происходит только в случае, если указанная ширина поля 
превышает фактическую ширину.
.Pp
некоторые оболочки могут предоставлять встроенную команду
.Nm
которая похожа или идентична этой утилите. 
Смотрите
.Xr builtin 1
страницу руководства.
.Sh СТАТУС ЗАВЕРШЕНИЯ
.Ex -std
.Sh ПРИМЕРЫ
Вывести строку
.Qq hello :
.Bd -literal -offset indent
$ printf "%s\en" hello
hello
.Ed
.Pp
То же самое, что и выше, но обратите внимание, что строка формата не заключена в кавычки, и поэтому мы
не получаем ожидаемого поведения:
.Bd -literal -offset indent
$ printf %s\en hello
hellon$
.Ed
.Pp
вывести аргументы, принудительно указывая знак только для первого аргумента
.Bd -literal -offset indent
$ printf "%+d\en%d\en%d\en" 1 -2 13
+1
-2
13
.Ed
.Pp
То же самое, что и выше, но единая строка формата будет применена к трем
аргументам:
.Bd -literal -offset indent
$ printf "%+d\en" 1 -2 13
+1
-2
+13
.Ed
.Pp
Вывести число, используя только две цифры после десятичной точки:
.Bd -literal -offset indent
$ printf "%.2f\en" 31.7456
31.75
.Ed
.Sh СОВМЕСТИМОСТЬ
Традиционное поведение
.Bx
в системе FreeBSD, при котором аргументы числовых форматов, не начинающиеся
с цифры, преобразуются в ASCII-код
первого символа, не поддерживается.
.Sh СМОТРИТЕ ТАКЖЕ
.Xr builtin 1 ,
.Xr echo 1 ,
.Xr sh 1 ,
.Xr printf 3
.Sh СТАНДАРТЫ
Команда
.Nm
ожидаемо совместима с
.St -p1003.2
спецификацией.
.Sh ИСТОРИЯ
Команда
.Nm
появилась в
.Bx 4.3 Reno .
Она создана
по образцу стандартной библиотечной функции
.Xr printf 3 .
.Sh ПРЕДУПРЕЖДЕНИЕ
Константы символов в шестнадцатеричном формате ANSI намеренно не были предоставлены.
.Pp
Попытка напечатать тире ("-") в качестве первого символа заставляет
.Nm
интерпретировать тире как аргумент программы.
.Nm --
должен использоваться перед
.Ar формат .
.Pp
Если локаль содержит многобайтовые символы
(такие как UTF-8),
то формат
.Cm c
и
.Cm b
и
.Cm s
с указанием точности
могут работать не так, как ожидается.
.Sh БАГИ
Поскольку числа с плавающей точкой переводятся из ASCII
в формат с плавающей точкой и обратно, может произойти потеря точности.
(По умолчанию, число переводится в значение с двойной точностью по стандарту IEEE-754 перед тем,
как быть напечатанным.
Модификатор
.Cm L
может обеспечить дополнительную точность в зависимости от аппаратной платформы.)
.Pp
Последовательность символов \e000 является терминатором строки.
Когда она присутствует в аргументе для формата
.Cm b ,
аргумент будет обрезан на символе \e000.
.Pp
Многобайтовые символы не распознаются в строках формата (это становится проблемой 
только если
.Ql %
может появиться внутри многобайтового символа).
