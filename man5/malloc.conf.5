'\" t
.\"     Название: ДЖЕМАЛЛОК
.\"    Автор: Джейсон Эванс
.\" Генератор: DocBook XSL Stylesheets v1.79.1 <http://docbook.sf.net/>
.\"      Дата: 11/10/2019
.\"    Руководство: Руководство пользователя
.\"    Source: jemalloc 5.2.1-0-gea6b3e973b477b8061e0076bb257dbd7f3faa756
.\"  Язык: Английский
.\"
.TH "JEMALLOC" "3" "11/10/2019" "jemalloc 5.2.1-0-gea6b3e973b47" "Руководство пользователя"
.\" -----------------------------------------------------------------
.\" * Определите некоторые элементы переносимости
.\" -----------------------------------------------------------------
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.\" http://bugs.debian.org/507673
.\" http://lists.gnu.org/archive/html/groff/2009-02/msg00013.html
.\" ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
.ie \n(.g .ds Aq \(aq
.el .ds Aq '
.\" -----------------------------------------------------------------
.\" * установить форматирование по умолчанию
.\" -----------------------------------------------------------------
.\" отключить дефисное написание
.nh
.\" отключить выравнивание (подгонять текст только под левое поле)
.ad l
.\" -----------------------------------------------------------------
.\" *ОСНОВНОЕ СОДЕРЖАНИЕ НАЧИНАЕТСЯ ЗДЕСЬ*
.\" -----------------------------------------------------------------
.SH "ИМЯ"
jemalloc \- функции выделения памяти общего назначения
.SH "LIBRARY"
.PP
В данном руководстве описывается jemalloc 5\&.2\&.1\-0\-gea6b3e973b477b8061e0076bb257dbd7f3faa756\&. Дополнительную информацию можно найти на сайте
\m[blue]\fBjemalloc website\fR\m[]\&\s-2\u[1]\d\s+2\&.
.PP
Следующие опции конфигурации включены в libc\*(Aqs built\-in jemalloc:
\fB\-\-enable\-fill\fR,
\fB\-\-enable\-lazy\-lock\fR,
\fB\-\-enable\-stats\fR,
\fB\-\-enable\-utrace\fR,
\fB\-\-enable\-xmalloc\fR, и
\fB\-\-with\-malloc\-conf=abort_conf:false\fR\&. Дополнительно,
\fB\-\-enable\-debug\fR
включена в версиях FreeBSD для разработчиков (управляется параметром
\fBMK_MALLOC_PRODUCTION\fR
переменная make)\&.
.SH "SYNOPSIS"
.sp
.ft B
.nf
#include <stdlib\&.h>
#include <malloc_np\&.h>
.fi
.ft
.SS "Стандартный API"
.HP \w'void\ *malloc('u
.BI "void *malloc(size_t\ " "размер" ");"
.HP \w'void\ *calloc('u
.BI "void *calloc(size_t\ " "число" ", size_t\ " "размер" ");"
.HP \w'int\ posix_memalign('u
.BI "int posix_memalign(void\ **" "ptr" ", size_t\ " "выравнивание" ", size_t\ " "размер" ");"
.HP \w'void\ *aligned_alloc('u
.BI "void *aligned_alloc(size_t\ " "выравнивание" ", size_t\ " "размер" ");"
.HP \w'void\ *realloc('u
.BI "void *realloc(void\ *" "ptr" ", size_t\ " "size" ");"
.HP \w'void\ free('u
.BI "void free(void\ *" "ptr" ");"
.SS "Не\-стандартный API"
.HP \w'void\ *mallocx('u
.BI "void *mallocx(size_t\ " "размер" ", int\ " "флаги" ");"
.HP \w'void\ *rallocx('u
.BI "void *rallocx(void\ *" "ptr" ", size_t\ " "size" ", int\ " "flags" ");"
.HP \w'size_t\ xallocx('u
.BI "size_t xallocx(void\ *" "ptr" ", size_t\ " "size" ", size_t\ " "extra" ", int\ " "flags" ");"
.HP \w'size_t\ sallocx('u
.BI "size_t sallocx(void\ *" "ptr" ", int\ " "flags" ");"
.HP \w'void\ dallocx('u
.BI "void dallocx(void\ *" "ptr" ", int\ " "flags" ");"
.HP \w'void\ sdallocx('u
.BI "void sdallocx(void\ *" "ptr" ", size_t\ " "размер" ", int\ " "флаги" ");"
.HP \w'size_t\ nallocx('u
.BI "size_t nallocx(size_t\ " "размер" ", int\ " "флаги" ");"
.HP \w'int\ mallctl('u
.BI "int mallctl(const\ char\ *" "имя" ", void\ *" "oldp" ", size_t\ *" "oldlenp" ", void\ *" "newp" ", size_t\ *"newlen" ");"
.HP \w'int\ mallctlnametomib('u
.BI "int mallctlnametomib(const\ char\ *" "name" ", size_t\ *" "mibp" ", size_t\ *" "miblenp" ");"
.HP \w'int\ mallctlbymib('u
.BI "int mallctlbymib(const\ size_t\ *" "mib" ", size_t\ " "miblen" ", void\ *" "oldp" ", size_t\ *" "oldlenp" ", void\ *" "newp" ", size_t\ " "newlen" ");"
.HP \w'void\ malloc_stats_print('u
.BI "void malloc_stats_print(void\ " "(*write_cb)"\ (void\ *,\ const\ char\ *), void\ *" "cbopaque" ", const\ char\ *" "opts" ");"
.HP \w'size_t\ malloc_usable_size('u
.BI "size_t malloc_usable_size(const\ void\ *" "ptr" ");"
.HP \w'void\ (*malloc_message)('u
.BI "void (*malloc_message)(void\ *" "cbopaque" ", const\ char\ *" "s" ");"
.PP
const char *\fImalloc_conf\fR;
.SH "ОПИСАНИЕ"
.SS "Стандартный API"
.PP
Сайт
malloc()
функция выделяет
\fIsize\fR
байт неинициализированной памяти\&. Выделенное пространство выравнивается (после возможного согласования указателей) для хранения объекта любого типа\&.
.PP
Команда
calloc()
выделяет место для
\fInumber\fR
объектов, каждый
\fIsize\fR
байт в длину\&. Результат идентичен вызову
malloc()
с аргументом
\fInumber\fR
*
\fIsize\fR, за исключением того, что выделенная память явно инициализируется нулевым байтом\&.
.PP
Программа
posix_memalign()
выделяет
\fIsize\fR
байт памяти так, чтобы базовый адрес распределения\*(Aqs был кратен
\fIвыравнивание\fR, и возвращает выделение в значении, на которое указывает
\fIptr\fR\&. Запрашиваемый
\fIвыравнивание\fR
должно быть не меньше, чем
sizeof(\fBvoid *\fR)\&.
.PP
Сайт
aligned_alloc()
функция выделяет
\fIsize\fR
байт памяти таким образом, чтобы базовый адрес выделения\*(Aqs был кратен
\fIвыравнивание\fR\&. Запрашиваемый
\fIвыравнивание\fR
должно быть кратным 2\&. Поведение не определено, если
\fIразмер\fR
не является целочисленным кратным
\fIвыравнивание\fR\&.
.PP
Сайт
realloc()
изменяет размер ранее выделенной памяти, на которую ссылается
\fIptr\fR
на
\fIsize\fR
байт\&. Содержимое памяти остается неизменным до меньшего из нового и старого размеров\&. Если новый размер больше, то содержимое вновь выделенной части памяти не определено\&. В случае успеха память, на которую ссылается
\fIptr\fR
освобождается и возвращается указатель на вновь выделенную память\&. Обратите внимание, что
realloc()
может переместить выделение памяти, что приведет к другому возвращаемому значению, чем
\fIptr\fR\&. Если
\fIptr\fR
это
\fBNULL\fR, то
realloc()
ведет себя так же, как и
malloc()
для указанного размера\&.
.PP
Функция
освободить()
приводит к тому, что выделенная память, на которую ссылается
\fIptr\fR
становится доступной для будущих выделений\&. Если
\fIptr\fR
это
\fBNULL\fR, никаких действий не происходит\&.
.SS "Не\-стандартный API"
.PP
Сайт
mallocx(),
rallocx(),
xallocx(),
sallocx(),
dallocx(),
sdallocx() и
nallocx()
все функции имеют
\fIflags\fR
аргумент, который можно использовать для указания опций\&. Функции проверяют только те опции, которые имеют контекстное значение\&. Используйте побитовые операции или (|), чтобы указать один или несколько из следующих параметров:
.PP
\fBMALLOCX_LG_ALIGN(\fR\fB\fIla\fR\fR\fB)\fR
.RS 4
Выровняйте распределение памяти, чтобы она начиналась с адреса, кратного
(1 << \fIla\fR)\&. Этот макрос не проверяет, что
\fIla\fR
находится в допустимом диапазоне\&.
.RE
.PP
\fBMALLOCX_ALIGN(\fR\fB\fIa\fR\fR\fB)\fR
.RS 4
Выравнивание распределения памяти для начала по адресу, который кратен
\fIa\fR, где
\fIa\fR
является степенью двойки\&. Этот макрос не подтверждает, что
\fIa\fR
является мощностью 2\&.
.RE
.PP
\fBMALLOCX_ZERO\fR
.RS 4
Инициализируйте вновь выделенную память, чтобы она содержала нулевые байты\&. В случае растущего перераспределения реальный размер до перераспределения определяет границу между нетронутыми байтами и теми, которые инициализируются как содержащие нулевые байты\&. Если этот макрос отсутствует, вновь выделенная память не инициализируется\&.
.RE
.PP
\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
.RS 4
Использование потокового\-специфического кэша (tcache), указанного идентификатором
\fItc\fR, который должен быть получен с помощью функции
tcache\&.create
mallctl\&. Этот макрос не подтверждает, что
\fItc\fR
указывает действительный идентификатор\&.
.RE
.PP
\fBMALLOCX_TCACHE_NONE\fR
.RS 4
Не используйте потоковый\-специфический кэш (tcache)\&. Если только
\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
или
\fBMALLOCX_TCACHE_NONE\fR
указан, то автоматически управляемый tcache будет использоваться во многих обстоятельствах\&. Этот макрос не может быть использован в одном и том же
\fIflags\fR
аргументе, как
\fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR\&.
.RE
.PP
\fBMALLOCX_ARENA(\fR\fB\fIa\fR\fR\fB)\fR
.RS 4
Используйте арену, указанную индексом
\fIa\fR\&. Этот макрос не действует для регионов, которые были распределены через арену, отличную от указанной\&. Этот макрос не подтверждает, что
\fIa\fR
указывает индекс арены в допустимом диапазоне\&.
.RE
.PP
Макрос
mallocx()
выделяет не менее
\fIsize\fR
байт памяти и возвращает указатель на базовый адрес выделения\&. Поведение не определено, если
\fIsize\fR
это
\fB0\fR\&.
.PP
Программа
rallocx()
изменяет размер выделения по адресу
\fIptr\fR
по крайней мере, до
\fIsize\fR
байт, и возвращает указатель на базовый адрес полученного распределения, которое может переместиться из своего первоначального местоположения\&, а может и нет. Поведение не определено, если
\fIsize\fR
это
\fB0\fR\&.
.PP
Сайт
xallocx()
изменяет размер выделенной области на
\fIptr\fR
на месте, чтобы быть по крайней мере
\fIsize\fR
байт, и возвращает реальный размер выделения\&. Если
\fIextra\fR
не равно \fIsize\fR, то предпринимается попытка изменить размер выделения, чтобы оно было не менее
(\fIsize\fR + \fIextra\fR)
байт, хотя невозможность выделить лишний байт(ы) сама по себе не приведет к неудаче в изменении размера\&. Поведение не определено, если
\fIsize\fR
это
\fB0\fR, или если
(\fIsize\fR + \fIextra\fR > \fBSIZE_T_MAX\fR)\&.
.PP
Программа
sallocx()
возвращает реальный размер выделения по адресу
\fIptr\fR\&.
.PP
Функция
dallocx()
вызывает память, на которую ссылается
\fIptr\fR
становится доступной для будущих выделений\&.
.PP
Функция
sdallocx()
является расширением функции
dallocx()
с
\fIsize\fR
позволяющим вызывающей стороне передавать размер выделения как оптимизацию\&. Минимальным допустимым входным размером является исходный запрашиваемый размер выделения, а максимальным допустимым входным размером является соответствующее значение, возвращаемое функцией
nallocx()
или
sallocx()\&.
.PP
Адрес
nallocx()
не выделяет память, но выполняет те же вычисления размера, что и функция
mallocx()
и возвращает реальный размер выделения, который был бы получен в результате эквивалентной операции
mallocx()
или
\fB0\fR
если вводимые данные превышают максимально поддерживаемый класс размера и/или выравнивание\&. Поведение не определено, если
\fIsize\fR
это
\fB0\fR\&.
.PP
Программа
mallctl()
предоставляет общий интерфейс для интроспекции аллокатора памяти, а также для установки изменяемых параметров и запуска действий\&. Период\-разделенный
\fИмя\fR
задает место в пространстве имен, структурированном в виде дерева; см.
MALLCTL NAMESPACE
раздел документации по содержимому дерева\&. Чтобы прочитать значение, передайте указатель через
\fIoldp\fR
на пространство, достаточное для размещения значения, и указатель на его длину через
\fIoldlenp\fR; в противном случае передайте
\fBNULL\fR
и
\fBNULL\fR\&. Аналогично, чтобы записать значение, передайте указатель на него через
\fInewp\fR, и его длину через
\fInewlen\fR; в противном случае передайте
\fBNULL\fR
и
\fB0\fR\&.
.PP
Программа
mallctlnametomib()
предоставляет возможность избежать повторного поиска имен для приложений, которые многократно запрашивают одну и ту же часть пространства имен, путем преобразования имени в
\(lqManagement Information Base\(rq
(MIB), которая может быть многократно передана в
mallctlbymib()\&. После успешного возврата из
mallctlnametomib(),
\fImibp\fR
содержит массив
\fI*miblenp\fR
целых чисел, где
\fI*miblenp\fR
это меньшее из числа компонентов в
\fIname\fR
и входное значение
\fI*miblenp\fR\&. Таким образом, можно передать
\fI*miblenp\fR
меньшее, чем количество компонентов имен, разделенных периодом\&, что приводит к частичной MIB, которая может быть использована в качестве основы для построения полной MIB\&. Для компонентов имен, которые являются целыми числами (e\&.g\&. the 2 in
arenas\&.bin\&.2\&.size), соответствующий компонент MIB всегда будет целым числом\&. Поэтому вполне законно построить код, подобный следующему:
.sp
.if n \{\
.RS 4
.\}
.nf
unsigned nbins, i;
size_t mib[4];
size_t len, miblen;

len = sizeof(nbins);
mallctl("arenas\&.nbins", &nbins, &len, NULL, 0);

miblen = 4;
mallctlnametomib("arenas\&.bin\&.0\&.size", mib, &miblen);
for (i = 0; i < nbins; i++) {
	size_t bin_size;

	mib[2] = i;
	len = sizeof(bin_size);
	mallctlbymib(mib, miblen, (void *)&bin_size, &len, NULL, 0);
	/* Сделайте что-нибудь с bin_size\&.\&.\&.\&. */
}
.fi
.if n \{\
.RE
.\}
.PP
.RS 4
.RE
.PP
Программа
malloc_stats_print()
записывает сводную статистику через функцию
\fIwrite_cb\fR
указатель функции обратного вызова и
\fIcbopaque\fR
данные, переданные в
\fIwrite_cb\fR, или
malloc_message()
если
\fIwrite_cb\fR
является
\fBNULL\fR\&. Статистика представлена в человекочитаемом виде, если только
\(lqJ\(rq
указан как символ в
\fIopts\fR
в этом случае статистика представляется в виде
\m[blue]\fBJSON format\fR\m[]\&\s-2\u[2]\d\s+2\&. Эту функцию можно вызывать многократно\&. Общую информацию, которая никогда не меняется во время выполнения, можно опустить, указав
\(lqg\(rq
в качестве символа внутри
\fIopts\fR
строки\&. Обратите внимание, что
malloc_stats_print()
использует
mallctl*()
поэтому при одновременном использовании этих функций несколькими потоками может быть получена противоречивая статистика\&. Если
\fB\-\-enable\-stats\fR
указано во время настройки,
\(lqm\(rq,
\(lqd\(rq, и
\(lqa\(rq
могут быть указаны, чтобы опустить статистику по объединенной арене, разрушенной объединенной арене и по каждой арене, соответственно;
\(lqb\(rq
и
\(lql\(rq
могут быть указаны, чтобы опустить статистику по размерному классу для бинов и крупных объектов, соответственно;
\(lqx\(rq
можно указать, чтобы опустить всю статистику по мьютексам;
\(lqe\(rq
может быть использован для опускания статистики экстентов\&. Нераспознанные символы игнорируются\&. Обратите внимание, что кэширование потоков может помешать полностью обновить некоторые статистические данные, поскольку для объединения счетчиков, отслеживающих операции с кэшем потоков, потребуется дополнительная блокировка\&.
.PP
Сайт
malloc_usable_size()
возвращает полезный размер выделения, на которое указывает
\fIptr\fR\&. Возвращаемое значение может быть больше, чем размер, который был запрошен при выделении\&. Для этого используется
malloc_usable_size()
не является механизмом для \-местного
realloc(); скорее она предоставляется исключительно как инструмент для целей интроспекции\&. Любое несоответствие между запрошенным размером выделения и размером, сообщенным функцией
malloc_usable_size()
не следует полагаться, поскольку такое поведение полностью зависит от реализации\&.
.SH "ТЮНИНГ"
.PP
Однажды, при первом обращении к одной из процедур выделения памяти, аллокатор инициализирует свои внутренние компоненты, частично основываясь на различных опциях, которые могут быть указаны при компиляции\- или запуске\-времени\&.
.PP
Строка, указанная через
\fB\-\-with\-malloc\-conf\fR, строка, на которую указывает глобальная переменная
\fImalloc_conf\fR, строка, на которую указывает глобальная переменная
\(lqname\(rq
файла, на который ссылается символическая ссылка с именем
/etc/malloc\&.conf, и значение переменной окружения
\fBMALLOC_CONF\fR, будут интерпретироваться, в этом порядке, слева направо, как опции\&. Обратите внимание, что
\fImalloc_conf\fR
может быть прочитан до
main()
поэтому объявление
\fImalloc_conf\fR
должно содержать инициализатор, содержащий конечное значение, которое будет прочитано jemalloc\&.
\fB\-\-with\-malloc\-conf\fR
и
\fImalloc_conf\fR
являются механизмами времени компиляции, в то время как
/etc/malloc\&.conf
и
\fBMALLOC_CONF\fR
могут быть безопасно установлены в любое время до вызова программы\&.
.PP
Строка опций представляет собой список пар опция:значение, разделенных запятыми\&. Каждой паре опций соответствует один ключ
опции\&.*.
mallctl (см.
ПРОСТРАНСТВО ИМЕН MALLCTL
раздел документации по опциям)\&. Например,
abort:true,narenas:1
устанавливает
opt\&.abort
и
opt\&.narenas
опции\&. Некоторые опции имеют булевые значения (true/false), другие - целочисленные значения (base 8, 10 или 16, в зависимости от префикса), третьи - необработанные строковые значения\&.
.SH "ЗАМЕТКИ ПО РЕАЛИЗАЦИИ"
.PP
Традиционно аллокаторы использовали
\fBsbrk\fR(2)
для получения памяти, что является неоптимальным по нескольким причинам, включая условия гонки, повышенную фрагментацию и искусственные ограничения на максимальное количество используемой памяти\&. Если
\fBsbrk\fR(2)
поддерживается операционной системой, этот аллокатор использует как
\fBmmap\fR(2)
и
\fBsbrk\fR(2), в этом порядке предпочтения; в противном случае только
\fBmmap\fR(2)
используется\&.
.PP
Этот аллокатор использует несколько арен, чтобы уменьшить количество блокировок для многопоточных программ на многопроцессорных системах\&. Это хорошо работает с точки зрения масштабируемости потоков, но влечет за собой некоторые издержки\&. Есть небольшие фиксированные накладные расходы на каждую арену, и, кроме того, арены управляют памятью совершенно независимо друг от друга, что означает небольшое фиксированное увеличение общей фрагментации памяти\&. Эти накладные расходы обычно не являются проблемой, учитывая количество обычно используемых арен\&. Обратите внимание, что использование значительно большего количества арен, чем по умолчанию, вряд ли повысит производительность, в основном из-за снижения производительности кэша\&. Однако, возможно, имеет смысл уменьшить количество арен, если приложение не использует функции выделения\&.
.PP
В дополнение к нескольким аренам, этот аллокатор поддерживает потокозависимое кэширование\&, что позволяет полностью избежать синхронизации для большинства запросов на выделение\&. Такое кэширование обеспечивает очень быстрое выделение в общем случае, но увеличивает использование памяти и фрагментацию, поскольку в кэше каждого потока может оставаться ограниченное количество объектов\&.
.PP
Память концептуально разбивается на экстенты\&. Экстенты всегда выровнены по кратному размеру страницы\&. Такое выравнивание позволяет быстро находить метаданные для пользовательских объектов\&. Пользовательские объекты делятся на две категории по размеру: маленькие и большие\&. Смежные малые объекты составляют слэб, который находится в одном экстенте, в то время как большие объекты имеют свои собственные экстенты, которые их поддерживают\&.
.PP
Малые объекты управляются группами с помощью слэбов\&. Каждый слэб поддерживает битовую карту, чтобы отслеживать, какие регионы используются\&. Запросы на выделение, не превышающие половину кванта (8 или 16, в зависимости от архитектуры), округляются до ближайшей степени двойки, которая не меньше
sizeof(\fBdouble\fR)\&. Все остальные классы размеров объектов кратны кванту, разделены таким образом, что на каждое удвоение размера приходится четыре класса размеров, что ограничивает внутреннюю фрагментацию примерно до 20% для всех классов размеров, кроме самых маленьких\&. Малые размерные классы меньше, чем четырехкратный размер страницы, а большие размерные классы простираются от четырехкратного размера страницы до самого большого размерного класса, который не превышает
\fBPTRDIFF_MAX\fR\&.
.PP
Выделения упаковываются плотно друг к другу, что может быть проблемой для многопоточных приложений\&. Если вам нужно убедиться, что выделения не страдают от разделения кэшлайна, округляйте запросы на выделение до ближайшего кратного размера кэшлайна или указывайте выравнивание кэшлайна при выделении\&.
.PP
Сайт
realloc(),
rallocx() и
xallocx()
могут изменять размер выделенных ресурсов без их перемещения при определенных обстоятельствах. В отличие от
* allocx()
API, стандартный API формально не округляет полезный размер выделения до ближайшего класса размера, поэтому технически необходимо вызвать
realloc()
чтобы увеличить размер 9-байтового файла до 16 байт или уменьшить размер 16-байтового файла до 9 байт. Увеличение и сжатие обычно выполняются успешно, если предварительный размер и последующий размер соответствуют одному и тому же классу размеров. Текущая реализация также пытается изменить размер больших распределений на месте, если предварительный размер и последующий размер являются большими. Чтобы сжатие было успешным, распределитель экстента должен поддерживать разделение (см.
arena\&.< i>\&.extent_hooks)\&. Расширение выполняется успешно только в том случае, если конечная память в данный момент доступна, а распределитель расширений поддерживает слияние.
.PP
Предполагая, что страницы размером 4 КБАЙТ и объем в 16 байт в 64-разрядной системе, классы размера в каждой категории такие, как показано в
Таблице 1\&.
.sp
. it 1 и-trap
. NR и-no-space-flag 1
. БЕЗ флага прерывания 1
.
Таблица br .B\\ &1.\ \ & Классы размеров
.TS
Вкладка allbox(:);
lB rB lB.
T{
Категория
T}: T{
Расстояние
T}: T{
Размер
Т}
.T&
l r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
l r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l
^ r l.
T{
Маленький 
T}:T{
lg
T}:T{
[8]
T}
:T{
16
T}:T{
[16, 32, 48, 64, 80, 96, 112, 128]
T}
:T{
32
T}:T{
[160, 192, 224, 256]
T}
:T{
64
T}:T{
[320, 384, 448, 512]
T}
:T{
128
T}:T{
[640, 768, 896, 1024]
T}
:T{
256
T}:T{
[1280, 1536, 1792, 2048]
T}
:T{
512
T}:T{
[2560, 3072, 3584, 4096]
T}
:T{
1 KiB
T}:T{
[5 KiB, 6 KiB, 7 KiB, 8 KiB]
T}
:T{
2 KiB
T}:T{
[10 KiB, 12 KiB, 14 KiB]
T}
T{
Огромный 
T}:T{
2 KiB
T}:T{
[16 KiB]
T}
:T{
4 KiB
T}:T{
[20 KiB, 24 KiB, 28 KiB, 32 KiB]
T}
:T{
8 KiB
T}:T{
[40 KiB, 48 KiB, 54 KiB, 64 KiB]
T}
:T{
16 KiB
T}:T{
[80 KiB, 96 KiB, 112 KiB, 128 KiB]
T}
:T{
32 KiB
T}:T{
[160 KiB, 192 KiB, 224 KiB, 256 KiB]
T}
:T{
64 KiB
T}:T{
[320 KiB, 384 KiB, 448 KiB, 512 KiB]
T}
:T{
128 KiB
T}:T{
[640 KiB, 768 KiB, 896 KiB, 1 MiB]
T}
:T{
256 KiB
T}:T{
[1280 KiB, 1536 KiB, 1792 KiB, 2 MiB]
T}
:T{
512 KiB
T}:T{
[2560 KiB, 3 MiB, 3584 KiB, 4 MiB]
T}
:T{
1 MiB
T}:T{
[5 MiB, 6 MiB, 7 MiB, 8 MiB]
T}
:T{
2 MiB
T}:T{
[10 MiB, 12 MiB, 14 MiB, 16 MiB]
T}
:T{
4 MiB
T}:T{
[20 MiB, 24 MiB, 28 MiB, 32 MiB]
T}
:T{
8 MiB
T}:T{
[40 MiB, 48 MiB, 56 MiB, 64 MiB]
T}
:T{
\&.\&.\&.
T}:T{
\&.\&.\&.
T}
:T{
512 PiB
T}:T{
[2560 PiB, 3 EiB, 3584 PiB, 4 EiB]
T}
:T{
1 EiB
T}:T{
[5 EiB, 6 EiB, 7 EiB]
T}
.TE
.sp 1
.SH "ПРОСТРАНСТВО ИМЕН MALLCTL"
.PP
Следующие имена определены в пространстве имен, доступном через
mallctl*()
функции\&. Типы значений указаны в круглых скобках, их статусы для чтения/записи кодируются как
rw,
r\-,
\-w или
\-\-, и за ними следуют обязательные флаги конфигурации сборки, если таковые имеются\&. Элемент name, закодированный как
<i>
или
<j>
, указывает на целочисленный компонент, где целое число изменяется от 0 до некоторого верхнего значения, которое должно быть определено с помощью самоанализа\&. В случае
stats\&.arenas\&.<i>\&.*
и
arena\&.<i>\&.{инициализировано, очистка,распад,dss},
<i>
равно
\fBMALLCTL_ARENAS_ALL\fR
может использоваться для работы на всех аренах или для доступа к суммированию статистических данных со всех арен; аналогично
<i>
значение, равное
\fBMALLCTL_ARENAS_DESTROYED\
, может быть использовано для доступа к суммированию статистики по всем уничтоженным аренам\&. Эти константы могут быть использованы либо через
mallctlnametomib(), либо через mallctlnametomib().
за которым следует
mallctlbymib(), или с помощью такого кода, как следующий:
.sp
.if n \{\
.RS 4
.\}
.nf
#определить STRINGIFY_HELPER(x) #x
#определить STRINGIFY(x) STRINGIFY_HELPER(x)

mallctl("арена\&." STRINGIFY(MALLCTL_ARENAS_ALL) "\&.распад",
NULL, NULL, NULL, 0);
.fi
.если n \{\
.RE
.\}
.sp
Обратите особое внимание на
эпоху
mallctl, который управляет обновлением кэшированной динамической статистики\&.
.
Версия PP (\fBconst char *\fR) r\-
.RS 4
Возвращает строку версии jemalloc\&.
.RE
.PP
epoch (\fBuint64_t\fR) rw
.RS 4
Если передано значение, обновите данные, на основе которых функции
mallctl*()
сообщают значения, и увеличьте значение epoch\&. Возвращает текущую эпоху\&. Это полезно для определения того, вызвал ли другой поток обновление\&.
.RE
.PP
background_thread (\fBbool\fR) rw
.RS 4
Включение/выключение внутренних фоновых рабочих потоков\&. Если установлено значение true, фоновые потоки создаются по требованию (количество фоновых потоков не будет превышать количество процессоров или активных площадок)\&. Потоки запускаются периодически и обрабатывают
очистку
асинхронно\&. При выключении фоновые потоки завершаются синхронно\&. Обратите внимание, что после выполнения функции
\fBfork\fR(2)
состояние дочернего процесса будет отключено независимо от состояния родительского процесса\&. Смотрите
статистику \&.background_thread
для получения соответствующей статистики \&.
opt\&.background_thread
может использоваться для установки параметра по умолчанию\&. Этот параметр доступен только на выбранных платформах, основанных на pthread\&.
.RE
.PP
max_background_threads (\fBsize_t\fR) rw
.RS 4
Максимальное количество фоновых рабочих потоков, которые будут созданы\&. Это значение ограничено
параметром opt\&.max_background_threads
при запуске\&.
.RE
.PP
config\&.cache_oblivious (\fBbool\fR) r\-
.RS 4
\fB\-включить\-кэширование\-забвение\fR
было указано при настройке сборки\&.
.RE
.PP
config\&.debug (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-debug\fR
был указан при сборке конфигурации\&.
.RE
.PP
config\&.fill (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-fill\fR
был указан при настройке сборки\&.
.RE
.PP
config\&.lazy_lock (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-lazy\-lock\fR
был указан при настройке сборки\&.
.RE
.PP
config\&.malloc_conf (\fBconst char *\fR) r\-
.RS 4
Встроенная строка параметров configure\-time\-specified run\-time, пустая, если только при сборке конфигурации не было указано
\fB\-\-with\-malloc\-conf\fR
.
.RE
.PP
config\&.prof (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-prof\fR
был указан при сборке конфигурации\&.
.RE
.PP
config\&.prof_libgcc (\fBbool\fR) r\-
.RS 4
\fB\-\-отключить\-prof\-libgcc\fR
не был указан при настройке сборки\&.
.RE
.PP
config\&.prof_libunwind (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-prof\-libunwind\fR
был указан во время настройки сборки\&.
.RE
.PP
config\&.stats (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-stats\fR
был указан при настройке сборки\&.
.RE
.PP
config\&.utrace (\fBbool\fR) r\-
.RS 4
\fB\-\-включить\-utrace\fR
был указан при сборке конфигурации\&.
.RE
.PP
config\&.xmalloc (\fBbool\fR) r\-
.RS 4
\fB\-\-enable\-xmalloc\fR
был указан при сборке конфигурации\&.
.RE
.PP
opt\&.abort (\fBbool\fR) r\-
.RS 4
Прерывание работы\-включено\-предупреждение включено/отключено\&. Если значение true, большинство предупреждений являются фатальными\&. Обратите внимание, что предупреждения о параметрах среды выполнения не включены (см.
opt\&.abort_conf
для этого)\&. Процесс вызовет
\fBabort\fR(3)
в этих случаях\&. По умолчанию эта опция отключена, если только при настройке не указано
\fB\-\-enable\-debug\fR
, и в этом случае она включена по умолчанию\&.
.RE
.PP
opt\&.confirm_conf (\fBbool\fR) r\-
.RS 4
Подтвердите\-время выполнения\-параметры\-при запуске\-программы\-включено/отключено\&. Если значение true, строка, указанная через
\fB\-\-с помощью\-malloc\-conf\fR, строки, на которую указывает глобальная переменная
\fImalloc_conf\fR, имени
файла, на который ссылается
символическая ссылка с именем
/etc/malloc\&.conf и значение переменной окружения
\fBMALLOC_CONF\fR, будут напечатаны по порядку\&. Затем каждый заданный параметр будет напечатан индивидуально\&. По умолчанию этот параметр отключен\&.
.RE
.PP
opt\&.abort_conf (\fBbool\fR) r\-
.RS 4
Прерывание\-включено\-недопустимо\-конфигурация включена/отключена\&. Если значение true, недопустимые параметры среды выполнения являются фатальными\&. В этих случаях процесс вызовет
\fBabort\fR(3)
\&. По умолчанию эта опция отключена, если только при настройке не указано
\fB\-\-enable\-debug\fR
, и в этом случае она включена по умолчанию\&.
.RE
.PP
opt\&.metadata_thp (\fBconst char *\fR) r\-
.RS 4
Определяет, разрешать ли jemalloc использовать прозрачную огромную страницу (THP) для внутренних метаданных (смотрите
статистику\&.metadata)\&.
\(lq всегда\(rq
разрешает такое использование\&.
\(lqauto\(rq
изначально не использует THP, но может начать использовать его, когда использование метаданных достигнет определенного уровня\&. Значение по умолчанию -
\(lqdisabled\(rq\&.
.RE
.PP
opt\&.retain (\fBbool\fR) r\-
.RS 4
Если значение равно true, сохраните неиспользуемую виртуальную память для последующего повторного использования, а не отбрасывайте ее с помощью вызова
\fBmunmap\fR(2)
или эквивалентный (смотрите
статистику\&.сохранено
для получения дополнительной информации)\&. Это также заставляет jemalloc использовать
\fBmmap\fR(2)
или эквивалентно более жадным способом, отображающим большие фрагменты за один раз \&. По умолчанию эта опция отключена, если только не известно, что отказ от виртуальной памяти вызывает проблемы с производительностью, зависящие от платформы, а именно: 1) для [64-разрядной] Linux, у которой есть особенность в алгоритме распределения виртуальной памяти, которая приводит к полупостоянным дырам в карте виртуальной машины при обычной работе jemalloc; и 2) для [64-разрядной] Windows, которая запрещает разделение / объединение областей с
\fI\fBMEM_RELEASE\fR\fR\&. Хотя те же проблемы могут возникать и на 32-разрядных платформах, сохранение виртуальной памяти для 32-разрядных Linux и Windows по умолчанию отключено из-за практической возможности исчерпания адресного пространства.
.RE
.PP
opt\&.dss (\fBconst char *\fR) r\-
.RS 4
dss (\fBsbrk\fR(2)) приоритет распределения, связанный с
распределением \fBmmap\fR(2)
\&. Следующие настройки поддерживаются, если
\fBsbrk\fR(2)
поддерживается операционной системой:
\(lqdisabled\(rq,
\(lqprimary\(rq и
\(lqsecondary\(rq; в противном случае поддерживается только
\(lqdisabled\(rq
\&. По умолчанию используется
\(lqsecondary\(rq
если
\fBsbrk\fR(2)
поддерживается операционной системой;
\(lqdisabled\(rq
в противном случае\&.
.RE
.PP
opt\&.narenas (\fBunsigned\fR) r\-
.RS 4
Максимальное количество областей, используемое для автоматического мультиплексирования потоков и областей\&. По умолчанию количество процессоров в четыре раза больше или равно одному, если имеется один процессор\&.
.RE
.PP
opt\&.превышение порогового значения (\fBsize_t\fR) r\-
.RS 4
Порог в байтах, при превышении которого запросы считаются слишком большими\&. Запросы на выделение ресурсов большего размера выполняются из выделенной области (управляемой автоматически, но не внутри
narenas), чтобы уменьшить фрагментацию, не смешивая огромные объемы выделений с небольшими\&. Кроме того, API decay гарантирует, что значения, превышающие указанный порог, могут быть переопределены\&. Обратите внимание, что запросы с индексом arena, указанным через
\fBMALLOCX_ARENA\fR, или потоки, связанные с явными аренами, рассматриваться не будут\&. Пороговое значение по умолчанию равно 8 Мб\&. Значения, не относящиеся к классам большого размера, отключают эту функцию\&.
.RE
.PP
opt\&.percpu_arena (\fBconst char *\fR) r\-
.RS 4
Для каждого режима арены процессора\&. Используйте параметр
\(lqpercpu\(rq
, чтобы включить эту функцию, которая использует количество процессоров для определения количества областей и динамически привязывает потоки к областям на основе процессора, на котором поток выполняется в данный момент\&.
\(lqphycpu\(rq
при настройке используется одна область для каждого физического процессора, что означает, что два гиперпотока на одном процессоре совместно используют одну область\&. Обратите внимание, что в данный момент проверка доступности hyper threading во время выполнения не выполняется\&. Если для параметра установлено значение
\(lqdisabled\(rq, этот параметр не повлияет на связь narenas и thread to arena\&. Значение по умолчанию -
\(lqdisabled\(rq\&.
.RE
.PP
opt\&.background_thread (\fBbool\fR) r\-
.RS 4
Включены/отключены внутренние фоновые рабочие потоки\&. Из-за возможных циклических зависимостей включение фонового потока с помощью этой опции может привести к сбою или взаимоблокировке во время инициализации\&. Надежный способ использования этой функции приведен в разделе
background_thread
для получения подробной информации о параметрах динамического управления\&. По умолчанию эта опция отключена\&.
.RE
.PP
opt\&.max_background_threads (\fBsize_t\fR) r\-
.RS 4
Максимальное количество фоновых потоков, которые будут созданы, если

задан параметр background_thread\&. По умолчанию задано количество процессоров\&.
.RE
.PP
opt\&.dirty_decay_ms (\fBssize_t\fR) r\-
.RS 4
Приблизительное время в миллисекундах с момента создания набора неиспользуемых грязных страниц до удаления эквивалентного набора неиспользуемых грязных страниц (т.е. преобразуется в muzzy через e\&.g\&.
мэдвайз(\fI\&.\&.\&.\fR\fI\fBMADV_FREE\fR\fR)
если поддерживается операционной системой или преобразован в чистый иным образом) и/или используется повторно\&. "Грязные" страницы определяются как ранее потенциально записанные приложением и, следовательно, занимающие физическую память, но не используемые в настоящее время\&. Страницы очищаются постепенно в соответствии с сигмоидальной кривой затухания, которая начинается и заканчивается нулевой скоростью очистки \&. При времени затухания, равном 0, все неиспользуемые загрязненные страницы удаляются сразу после создания\&. Время затухания, равное \-1, отключает очистку\&. Время затухания по умолчанию равно 10 секундам\&. Смотрите
арены\&.dirty_decay_ms
и
arena\&.<i>\&.dirty_decay_ms
для получения информации о соответствующих параметрах динамического управления\&. Описание muzzy pages\& смотрите в разделе
opt\&.muzzy_decay_ms.
для описания muzzy pages\&. Обратите внимание, что когда
включена
функция oversize_threshold, арены, зарезервированные для запросов на увеличение размера, могут иметь свои собственные настройки затухания по умолчанию\&.
.RE
.PP
опция\&.muzzy_decay_ms (\fBssize_t\fR) r\-
.RS 4
Приблизительное время в миллисекундах с момента создания набора неиспользуемых размытых страниц до удаления эквивалентного набора неиспользуемых размытых страниц (т.е. преобразования в clean) и/или повторного использования. Нечеткие страницы определяются как ранее бывшие неиспользуемыми грязными страницами, которые впоследствии были удалены таким образом, что они были подвержены капризам операционной системы по исправлению (например, \&.g\&.
madvise(\fI\&.\&.\&.\fR\fI\fBMADV_FREE\fR\fR)), и, следовательно, находится в неопределенном состоянии\&. Страницы очищаются постепенно в соответствии с сигмоидальной кривой затухания, которая начинается и заканчивается нулевой скоростью очистки \&. При времени затухания, равном 0, все неиспользуемые страницы muzzy будут удалены сразу после создания \&. Время затухания, равное \-1, отключает очистку\&. Время затухания по умолчанию равно 10 секундам\&. Смотрите
разделы arenas\&.muzzy_decay_ms
и
arena\&.<i>\&.muzzy_decay_ms
для получения информации о соответствующих параметрах динамического управления.
.RE
.PP
опция\&.lg_extent_max_active_fit (\fBsize_t\fR) r\-
.RS 4
При повторном использовании измененных экстентов это определяет (логарифмическая база 2) максимальное соотношение между размером выбранного активного экстента (от которого нужно отделиться) и размером запрошенного выделения\&. Это предотвращает разделение больших активных экстентов на более мелкие, что может уменьшить фрагментацию в долгосрочной перспективе (особенно для неактивных экстентов). Меньшее значение может уменьшить фрагментацию за счет дополнительных активных экстентов. Значение по умолчанию равно 6, что дает максимальное соотношение 64 (2^6)\&.
.RE
.PP
opt\&.stats_print (\fBbool\fR) r\-
.RS 4
Включить/отключить печать статистики при выходе из программы\&. Если функция включена,
то функция malloc_stats_print()
вызывается при выходе из программы
с помощью функции \fBatexit\fR(3)
\&.
opt\&.stats_print_opts
можно комбинировать для указания параметров вывода\&. Если
во время настройки указано значение \fB\-\-enable\-stats\fR
, это может привести к взаимоблокировке многопоточного процесса, который завершается во время выполнения одного или нескольких потоков в функциях выделения памяти\&. Кроме того,
atexit()
может выделять память во время инициализации приложения, а затем внутренне блокироваться, когда jemalloc, в свою очередь, вызывает
atexit(), поэтому эта опция не является универсальной (хотя приложение может зарегистрировать свою собственную
функцию atexit()
с эквивалентной функциональностью)\&. Поэтому эту опцию следует использовать с осторожностью; в первую очередь она предназначена для настройки производительности при разработке приложений\&. По умолчанию эта опция отключена\&.
.RE
.PP
opt\&.stats_print_opts (\fBconst char *\fR) r\-
.RS 4
Параметры (строка
\fIopts\fR
) для передачи в
malloc_stats_print()
при выходе (включается через
opt\&.stats_print)\&. Смотрите доступные параметры в
malloc_stats_print()\&. Не действует, если
не включена функция opt\&.stats_print
\&. Значение по умолчанию -
\(lq\(rq\&.
.RE
.PP
opt\&.junk (\fBconst char *\fR) r\- [\fB\-\-включить\-заполнение\fR]
.RS 4
Ненужное заполнение\&. Если задано значение
\(lqalloc\(rq, каждый байт неинициализированной выделенной памяти будет инициализирован значением
0xa5\&. Если задано значение
\(lqfree\(rq, вся освобожденная память будет инициализирована значением
0x5a\&. Если задано значение
\(lqtrue\(rq, будет инициализирована как выделенная, так и освобожденная память, и если установлено значение
\(lqfalse\(rq, заполнение нежелательной информацией будет полностью отключено\&. Это предназначено для отладки и негативно повлияет на производительность\&. По умолчанию этот параметр
\(lqfalse\(rq
, если только
\fB\-\-enable\-debug\fR
указывается при настройке, и в этом случае
по умолчанию это \(lqtrue\(rq
\&.
.RE
.PP
opt\&.zero (\fBbool\fR) r\- [\fB\-\-включить\-заполнение\fR]
.RS 4
Заполнение нулем включено/отключено\&. Если включено, каждый байт неинициализированной выделенной памяти будет инициализирован равным 0\&. Обратите внимание, что эта инициализация выполняется только один раз для каждого байта, поэтому
realloc()
и
rallocx()
вызовы не приводят к обнулению ранее выделенной памяти\&. Это предназначено для отладки и негативно повлияет на производительность\&. По умолчанию эта опция отключена\&.
.RE
.PP
выбрать\&.utrace (\fBbool\fR) r\- [\fB\-\-включить\-utrace\fR]
.RS 4
Трассировка распределения на основе
\fButrace\fR(2)
включена/отключена\&. По умолчанию эта опция отключена\&.
.RE
.PP
выберите\&.xmalloc (\fBbool\fR) r\- [\fB\-\-включить\-xmalloc\fR]
.RS 4
Отмена включения/выключения памяти включена/отключена\&. Если эта функция включена, вместо того, чтобы возвращать ошибку для какой-либо функции распределения, отобразите диагностическое сообщение на
\fBSTDERR_FILENO\fR
и заставьте программу завершить работу с ядром (используя
\fBabort\fR(3))\&. Если приложение разработано таким образом, чтобы оно зависело от этого поведения, установите этот параметр во время компиляции, включив в исходный код следующее:
.sp
.если n \{\
.RS 4
.\}
.nf
malloc_conf = "xmalloc:true";
.fi
.if n \{\
.RE
.\}
.sp
По умолчанию эта опция отключена\&.
.RE
.PP
opt\&.tcache (\fBbool\fR) r\-
.RS 4
Включено/отключено кэширование, зависящее от потока (tcache). При наличии нескольких потоков каждый поток использует tcache для объектов определенного размера. Кэширование, зависящее от потока, позволяет выполнять множество распределений без выполнения какой-либо синхронизации потоков за счет увеличения использования памяти. Смотрите параметр
opt.
lg_tcache_max для получения дополнительной информации о настройке. Эта опция включена по умолчанию\&.
.RE
.PP
opt\&.lg_tcache_max (\fBsize_t\fR) r\-
.RS 4
Класс максимального размера (база журнала 2) для кэширования в кэше, специфичном для потока (tcache)\&. Как минимум, кэшируются все классы малого размера, а как максимум - все классы большого размера\&. Максимальный размер по умолчанию равен 32 КБ (2^15)\&.
.RE
.PP
opt\&.thp (\fBconst char *\fR) r\-
.RS 4
Режим прозрачной огромной страницы (THP)\&. Настройки "всегда", "никогда" и "по умолчанию" доступны, если THP поддерживается операционной системой\&. Настройка "всегда" обеспечивает прозрачность hugepage для всех сопоставлений пользовательской памяти с
\fI\fBMADV_HUGEPAGE\fR\fR; "никогда" не гарантирует отсутствие прозрачной огромной страницы с
\fI\fBMADV_NOHUGEPAGE\fR\fR; значение по умолчанию "по умолчанию" не вносит изменений\&. Обратите внимание, что: этот параметр не влияет на THP для внутренних метаданных jemalloc (см.
opt\&.metadata_thp); кроме того, для арен с настраиваемыми
extent_hooks этот параметр не используется, поскольку он реализован как часть настроек extent по умолчанию.
.RE
.PP
opt\&.prof (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Профилирование памяти включено/отключено\&. Если включено, активируется выделение памяти профиля\&. Смотрите опцию
opt\&.prof_active
для быстрой активации/деактивации. Смотрите
пример opt\&.lg_prof_sample
опция для вероятностного контроля выборки\&. Смотрите опцию
opt\&.
prof_accum для контроля отчетов о совокупной выборке\&. Смотрите параметр
opt\&.
lg_prof_interval для получения информации об интервальном сбросе профиля, параметр
opt\&.
prof_gdump для получения информации о сбросе профиля, вызванном паводком, и параметр
opt\&.prof_final
для окончательного сброса профиля. Вывод профиля совместим с командой
\fBjeprof\fR
, которая основана на
\fBpprof\fR
, разработанной как часть
пакета \m[blue]\fBgperftools\fR\m[]\&\s-2\u[3]\d\s+2\&. Видеть
ФОРМАТ ПРОФИЛЯ КУЧИ
для документации по формату профиля кучи\&.
.RE
.PP
opt\&.prof_prefix (\fBconst char *\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Префикс имени файла для дампов профиля\&. Если для префикса задана пустая строка, автоматические дампы не будут выполняться; это в первую очередь полезно для отключения автоматического окончательного дампа кучи (который также отключает отчеты об утечках, если включен)\&. Префикс
по умолчанию - jeprof\&.
.RE
.PP
opt\&.prof_active (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Профилирование активировано/деактивировано\&. Это дополнительный механизм управления, который позволяет запускать приложение с включенным профилированием (см. опцию
opt\&.prof
), но неактивным, а затем переключать профилирование в любое время во время выполнения программы с
помощью prof\&.active
mallctl\&. Эта опция включена по умолчанию\&.
.RE
.PP
opt\&.prof_thread_active_init (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Начальная настройка для
потока\&.prof\&.active
во вновь созданных потоках\&. Начальная настройка для вновь созданных потоков также может быть изменена во время выполнения с помощью
prof\&.thread_active_init
mallctl\&. Эта опция включена по умолчанию\&.
.RE
.PP
opt\&.lg_prof_sample (\fBsize_t\fR) r\- [\fB\-\-включить\-prof\fR]
.RS 4
Средний интервал (логарифмическая база 2) между выборками распределения, измеряемый в байтах активности распределения\&. Увеличение интервала выборки снижает точность профиля, но также уменьшает вычислительную нагрузку\&. Интервал выборки по умолчанию равен 512 КБ (2^19 Бит)\&.
.RE
.PP
opt\&.prof_accum (\fBbool\fR) r\- [\fB\-\-включить\-prof\fR]
.RS 4
Отображение суммарного количества объектов/байт в дампах профилей включено/отключено\&. Если эта опция включена, каждая уникальная обратная трассировка должна сохраняться в течение всего времени выполнения\&. В зависимости от приложения это может привести к большим затратам памяти, а суммарные значения не всегда представляют интерес\&. По умолчанию эта опция отключена\&.
.RE
.PP
opt\&.lg_prof_interval (\fBssize_t\fR) r\- [\fB\-\-включить\-prof\fR]
.RS 4
Средний интервал (база журнала 2) между сбросами профиля памяти, измеряемый в байтах активности выделения памяти\&. Фактический интервал между сбросами может быть нерегулярным, поскольку для предотвращения проблем синхронизации используются децентрализованные счетчики выделения памяти\&. Профили сбрасываются в файлы, названные в соответствии с шаблоном
<префикс>\&.<pid>\&.<seq>\&.i<iseq>\&.heap, где
<префикс>
управляется параметром
opt\&.
prof_prefix\&. По умолчанию интервальный сброс профиля отключен (кодируется как \-1)\&.
.RE
.PP
opt\&.prof_gdump (\fBbool\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Задает начальное состояние
prof\&.gdump, который, если включен, запускает сброс профиля памяти каждый раз, когда общий объем виртуальной памяти превышает предыдущий максимум\&. По умолчанию эта опция отключена\&.
.RE
.PP
opt\&.prof_final (\fBbool\fR) r\- [\fB\-\-включить\-prof\fR]
.RS 4
Используйте
функцию \fBatexit\fR(3)
для сброса конечного объема используемой памяти в файл, названный в соответствии с шаблоном
<префикс>\&.<pid>\&.<seq>\&.f\&.heap, где
<префикс>
управляется параметром
opt\&.
prof_prefix\&. Обратите внимание, что
atexit()
может выделять память во время инициализации приложения, а затем внутренне блокироваться, когда jemalloc, в свою очередь, вызывает
atexit(), поэтому эта опция не является универсальной (хотя приложение может зарегистрировать свою собственную
функцию atexit()
с эквивалентной функциональностью)\&. По умолчанию эта опция отключена\&.
.RE
.PP
opt\&.prof_leak (\fBbool\fR) r\- [\fB\-\-включить\-prof\fR]
.RS 4
Сообщения об утечках включены/отключены\&. Если функция включена, используйте
функцию \fBatexit\fR(3)
для сообщения об утечках памяти, обнаруженных при выборке распределения\&. 

Информацию об анализе выходных данных профиля кучи смотрите в опции opt\&.prof. По умолчанию эта опция отключена\&.
Поток .RE
.PP
\&.arena (\fBunsigned\fR) rw
.RS 4
Получите или задайте арену, связанную с вызывающим потоком\&. Если указанная арена не была инициализирована заранее (см.
arena\&.i\&.initialized
mallctl), она будет инициализирована автоматически как побочный эффект вызова этого интерфейса\&.
.RE
.PP
поток\&.выделенный (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Возвращает общее количество байт, когда-либо выделенных вызывающим потоком\&. Этот счетчик может быть изменен; в таких случаях приложение должно соответствующим образом интерпретировать показания счетчика\&.
Поток .RE
.PP
\&.allocatedp (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Получаем указатель на значение, возвращаемое
потоком\&.выделяем
mallctl\&. Это полезно для того, чтобы избежать дополнительных затрат на повторные
вызовы mallctl*()
\&.
Поток .RE
.PP
\&.освобожден (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Получите общее количество байт, когда-либо освобожденных вызывающим потоком\&. Этот счетчик может быть изменен; в таких случаях приложение должно соответствующим образом интерпретировать счетчик\&.
.RE
.PP
thread\&.deallocatedp (\fBuint64_t *\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Возвращает указатель на значение, возвращаемое программой
thread\&.освободил
mallctl\&. Это полезно для того, чтобы избежать накладных расходов на повторные
вызовы 
\&. .RE
.PP
поток\&.tcache\&.включен (\fBbool\fR) rw
.RS 4
Включить/отключить вызывающий поток\*(Aqs tcache\&. Tcache неявно сбрасывается как побочный эффект отключения (см.
thread\&.tcache\&.сброс)\&.
.RE
.PP
thread\&.tcache\&.сброс (\fBvoid\fR) \-\-
.4 рупии
Очистить вызывающий поток\*(Aqs thread\-specific cache (tcache)\&. Этот интерфейс освобождает все кэшированные объекты и внутренние структуры данных, связанные с вызывающим потоком\*(Aqs tcache\&. Обычно этот интерфейс вызывать не нужно, поскольку происходит автоматическая периодическая инкрементная сборка мусора, и кэш потока автоматически удаляется, когда поток завершает работу\&. Однако сборка мусора запускается при выполнении операции выделения, поэтому поток, который прекращает выделение/отмену, может сохранять свой кэш на неопределенный срок, и в этом случае разработчик может счесть полезной ручную очистку\&.
.RE
.PP
thread\&.prof\&.name (\fBconst char *\fR) r\- или \-w [\fB\-включить\-prof\fR]
.RS 4
Получает/задает описательное имя, связанное с вызывающим потоком, в дампах профиля памяти\&. Создается внутренняя копия строки имени, поэтому нет необходимости поддерживать входную строку после завершения выполнения этого интерфейса\&. Выходную строку этого интерфейса следует скопировать для неэфемерных целей, поскольку множественные детали реализации могут привести к асинхронному освобождению строки. Кроме того, каждый вызов этого интерфейса может выполнять только чтение или запись; одновременное чтение/запись не поддерживается из-за ограничений срока службы строки. Строка имени должна заканчиваться нулем и состоять только из символов из наборов, распознаваемых
\fBisgraph\fR(3)
и
\fBisblank\fR(3)\&.
Поток .RE
.PP
\&.prof\&.active (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Определяет, активна ли выборка в данный момент для вызывающего потока\&. Это механизм активации в дополнение к
prof\&.active; оба они должны быть активны, чтобы вызывающий поток выполнял выборку\&. Этот флаг включен по умолчанию\&.
.RE
.PP
tcache\&.create (\fBunsigned\fR) r\-
.RS 4
Создайте явный кэш для конкретного потока (tcache) и верните идентификатор, который может быть передан в
Макрос \fBMALLOCX_TCACHE(\fR\fB\fItc\fR\fR\fB)\fR
для явного использования указанного кэша, а не автоматически управляемого, который используется по умолчанию\&. Каждый явный кэш может использоваться только одним потоком одновременно; приложение должно гарантировать, что это ограничение выполняется\&.
.RE
.PP
tcache\&.flush (\fBunsigned\fR) \-w
.RS 4
Очистите указанный кэш, относящийся к конкретному потоку (tcache). К этому интерфейсу применимы те же соображения
, что и к thread.tcache.очистите, за исключением того, что tcache никогда не будет автоматически удален.
.RE
.PP
tcache\и.destroy (\fBunsigned\fR) \-w
.RS 4
Очистите указанный кэш для конкретного потока (tcache) и сделайте идентификатор доступным для использования при создании tcache в будущем.
.RE
.PP
arena\&.<i>\&.initialized (\fBbool\fR) r\-
.RS 4
Определяет, инициализирована ли указанная статистика арены\*(Aqs (т.е. арена была инициализирована до текущей эпохи)\&. Этот интерфейс также может быть номинально использован для запроса, инициализированы ли объединенные статистические данные, соответствующие
\fBMALLCTL_ARENAS_ALL\fR
(всегда true)\&.
.RE
.PP
арена\&.<i>\&.распад (\fBvoid\fR) \-\-
.RS 4
Запускаем очистку неиспользуемых грязных страниц на основе decay для арены <i> или для всех арен, если <i> равно
\fBMALLCTL_ARENAS_ALL\fR\&. Доля неиспользуемых грязных/мутных страниц, подлежащих удалению, зависит от текущего времени; подробности смотрите в разделах
opt\&.dirty_decay_ms
и
opt\&.muzy_decay_ms
.
.RE
.PP
arena\&.<i>\&.очистить (\fBvoid\fR) \-\-
.RS 4
Удалить все неиспользуемые грязные страницы для arena <i> или для всех арен, если <i> равно
\fBMALLCTL_ARENAS_ALL\fR\&.
.RE
.PP
арена\&.<i>\&.сброс (\fBvoid\fR) \-\-
.RS 4
Удалите все существующие распределения arena\*(Aqs)\&. Этот интерфейс можно использовать только с аренами, явно созданными с помощью
arenas\&.create\&. Ни к одному из удаленных/кэшированных распределений arena\*(Aqs) не может быть получен доступ позже \&. В соответствии с этим требованием все кэши потоков, которые использовались для выделения/освобождения ресурсов в сочетании с arena, должны быть предварительно очищены\&.
.RE
.PP
арена\&.<i>\&.уничтожить (\fBvoid\fR) \-\-
.RS 4
Уничтожить арену\&. Удалите все существующие распределения arena\*(Aqs, используя тот же механизм, что и для
arena\&.<i>\&.reset
(со всеми теми же ограничениями и побочными эффектами), объедините статистику арены со статистикой, доступной по адресу arena index
\fBMALLCTL_ARENAS_DESTROYED\fR, а затем полностью удалите все метаданные, связанные с ареной\&. Будущие вызовы
arenas\&.create
могут привести к повторному использованию индекса arena\&. Уничтожение завершится ошибкой, если какие-либо потоки в настоящее время связаны с arena в результате вызовов
thread\&.arena\&.
.RE
.PP
арена\&.<i>\&.dss (\fBconst char *\fR) rw
.RS 4
Установите приоритет распределения dss в соответствии с распределением mmap для арены <i> или для всех арен, если <i> равно
\fBMALLCTL_ARENAS_ALL\fR\&. Видеть
выберите\&.dss
для поддерживаемых настроек\&.
.RE
.PP
arena\&.<i>\&.dirty_decay_ms (\fBssize_t\fR) rw
.RS 4
Текущее приблизительное время в миллисекундах с момента создания набора неиспользуемых "грязных" страниц до удаления и/или повторного использования эквивалентного набора неиспользуемых "грязных" страниц. Каждый раз, когда устанавливается этот интерфейс, все неиспользуемые в данный момент грязные страницы считаются полностью удаленными, что приводит к немедленной очистке всех неиспользуемых ненужных страниц, если только время удаления не установлено на \-1 (т.е. очистка отключена)\&. Смотрите
раздел opt\&.dirty_decay_ms
для получения дополнительной информации\&.
.RE
.PP
арена\&.<i>\&.muzzy_decay_ms (\fBssize_t\fR) rw
.RS 4
Текущее приблизительное время в миллисекундах с момента создания набора неиспользуемых размытых страниц до удаления и/или повторного использования эквивалентного набора неиспользуемых размытых страниц. Каждый раз, когда устанавливается этот интерфейс, все неиспользуемые в данный момент страницы muzzy считаются полностью удаленными, что приводит к немедленной очистке всех неиспользуемых страниц muzzy, если только время удаления не установлено на \-1 (т.е. очистка отключена)\&. Смотрите
раздел opt\&.muzzy_decay_ms
для получения дополнительной информации\&.
.RE
.PP
arena\&.<i>\&.retain_grow_limit (\fBsize_t\fR) rw
.RS 4
Максимальный размер для увеличения сохраняемой области (актуален только при
выборе \&.сохранить
включен)\&. Этот параметр определяет максимальное увеличение объема виртуальной памяти или выделение с помощью
arena\&.<i>extent_hooks\&. В частности, если настроенные перехватчики экстента резервируют физическую память (например, \&.g\&. 1G огромных страниц), это полезно для управления параметром выделения\* (размер входного файла Aqs\&. Значение по умолчанию - без ограничений\&.
.RE
.PP
arena\&.<i>\&.расширение_хуков (\fBextent_hooks_t *\fR) rw
.RS 4
Получите или установите функции перехвата управления экстентами для arena <i>\&. Функции должны быть способны работать со всеми существующими экстентами, связанными с arena <i>, обычно путем передачи неизвестных экстентов заменяемым функциям\&. На практике возможно управлять распределением для арен, явно созданных с помощью
arenas\&.create
таким образом, все экстенты берутся из предоставленного приложением распределителя экстентов (путем указания пользовательских функций привязки экстентов во время создания арены). Тем не менее, гарантии API для автоматически созданных областей могут быть ослаблены \-\- установленные там перехватчики могут быть вызваны "по максимуму"; кроме того, могут быть экстенты, созданные до того, как приложение получит возможность взять на себя распределение экстентов\&.
.sp
.если n \{\
.RS 4
.\}
.nf
определение типа extent_hooks_s extent_hooks_t;
структура extent_hooks_s {
extent_alloc_t *alloc;
	extent_dalloc_t *dalloc;
	extent_destroy_t *уничтожить;
	extent_commit_t *зафиксировать;
	extent_decommit_t *отменить фиксацию;
	extent_purge_t *очистить глаза;
	extent_purge_t *очистить принудительно;
	extent_split_t *разделить;
	extent_merge_t *объединить;
};
.fi
.если n \{\
.RE
.\}
.sp
То
\fBextent_hooks_t\fR
структура содержит указатели на функции, которые описаны отдельно ниже\&. jemalloc использует эти функции для управления временем жизни экстента, которое начинается с выделения отображенной выделенной памяти, в простейшем случае за которым следует освобождение\&. Однако существуют соображения производительности и платформы для сохранения экстентов для последующего повторного использования\&. Попытки очистки каскадно переходят от освобождения к выводу из эксплуатации, от принудительной очистки к отложенной очистке, что дает функциям управления масштабами возможность отказаться от наиболее постоянных операций очистки в пользу менее постоянных (и часто менее дорогостоящих) операций\&. Все операции, кроме распределения, можно универсально отключить, установив указатели перехвата в
\fBNULL\fR, или выборочно отключить, вернув failure\&. Обратите внимание, что после установки привязки к экстенту к структуре напрямую обращаются связанные области, поэтому она должна оставаться действительной в течение всего срока службы областей\&.
.HP \w'typedef\ void\ *(extent_alloc_t)('u
.BI "typedef void *(extent_alloc_t)(extent_hooks_t\ * " "расширенные ссылки" ", void\ *" "new_addr" ", size_t " "размер" ", size_t " "выравнивание" ", bool\ *"ноль", bool\ *"фиксация", неподписанный\ "arena_ind");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция выделения экстента соответствует
типу \fBextent_alloc_t\fR
и в случае успеха возвращает указатель на
\fIsize\fR
байт отображенной памяти от имени arena
\fIarena_ind\fR
таким образом, чтобы базовый адрес extent\*(Aqs был кратен
\fIalignment\fR, а также настройка
\fI*zero\fR
указывает, обнулен ли экстент, и
\fI*commit\fR
указывает, зафиксирован ли экстент\&. При ошибке функция возвращает
\fBNULL\fR
и завершает работу
\fI*ноль\fR
и
\fI*фиксация\fR
без изменений\&. Параметр
\fIsize\fR
всегда кратен размеру страницы\&. То
Параметр \fIalignment\fR
всегда имеет степень двойки, по крайней мере, равную размеру страницы\&. Обнуление обязательно, если
значение \fI*zero\fR
равно true при вводе функции\&. Фиксация обязательна, если
\fI*commit\fR
имеет значение true при вводе функции\&. Если
\fInew_addr\fR
не имеет значения
\fBNULL\fR, возвращаемый указатель должен быть
\fInew_addr\fR
в случае успеха или
\fBNULL\fR
при ошибке\&. Выделенная память может быть выделена в абсолютном выражении, как в системе, которая не перегружает, или в неявном выражении, как в системе, которая перегружает и удовлетворяет потребности в физической памяти по требованию с помощью программных ошибок страницы\&. Обратите внимание, что замена функции выделения экстента по умолчанию делает параметр arena\*(Aqs
arena\&.<i>\&.dss
неактуальным\&.
.HP \w'typedef\ bool\ (extent_dalloc_t)('u
.BI "typedef bool (extent_dalloc_t)(extent_hooks_t\ * "расширенные ссылки", void\ * "адрес", size_t\ "размер", bool\ "зафиксирован", без знака\ " "арена_инд" ");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция освобождения экстента соответствует
типу \fBextent_dalloc_t\fR
и освобождает экстент в заданное время.
\fIaddr\fR
и
\fIsize\fR
с помощью
\fIcommitted\fR/списанной памяти, как указано, от имени arena
\fIarena_ind\fR, возвращая значение false в случае успеха\&. Если функция возвращает значение true, это указывает на отказ от освобождения; сопоставление виртуальной памяти, связанное с экстентом, остается сопоставленным, в том же состоянии фиксации и доступным для использования в будущем, и в этом случае оно будет автоматически сохранено для последующего повторного использования.
.HP \w'typedef\ void\ (extent_destroy_t)('u
.BI "typedef void (extent_destroy_t)(extent_hooks_t\ * "экстент_хуки", void\ * "адрес", size_t\ "размер", bool\ "зафиксирован", unsigned\ "arena_ind");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция уничтожения экстента соответствует
типу \fBextent_destroy_t\fR
и безоговорочно уничтожает экстент при заданном
\fIaddr\fR
и
\fIsize\fR
с помощью
\fIcommitted\fR/удаленная память, как указано, от имени arena
\fIarena_ind\fR\&. Эта функция может быть вызвана для уничтожения сохраненных экстентов во время уничтожения arena (см.
arena\&.<i>\&.destroy)\&.
.HP \w'typedef\ bool\ (extent_commit_t)('u
.BI "typedef bool (extent_commit_t)(extent_hooks_t\ * "расширенные крючки", void\ * "адрес", size_t\ "размер", size_t\ "смещение", size_t\ " "длина" ", без знака\ " "arena_ind" ");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция фиксации экстента соответствует
типу \fBextent_commit_t\fR
и фиксирует обнуленную физическую память для возврата страниц в пределах экстента в заданное время.
\fIaddr\fR
и
\fIsize\fR
в

байтах \fIoffset\fR, расширяясь на
\fIlength\fR
от имени arena
\fIarena_ind\fR, возвращающий значение false в случае успеха\&. Выделенная память может быть выделена в абсолютном выражении, как в системе, которая не перегружает, или в неявном выражении, как в системе, которая перегружает и удовлетворяет потребности в физической памяти по требованию с помощью программных ошибок страницы\&. Если функция возвращает значение true, это указывает на недостаточность физической памяти для выполнения запроса\&.
.HP \w'typedef\ bool\ (extent_decommit_t)('u
.BI "typedef bool (extent_decommit_t)(extent_hooks_t\ * "расширенные крючки", void\ * "адрес", size_t\ "размер", size_t\ "смещение", size_t\ " "длина" ", без знака\ " "arena_ind" ");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция удаления экстента соответствует
типу \fBextent_decommit_t\fR
и удаляет любую физическую память, которая поддерживает страницы в пределах экстента в данный момент
\fIaddr\fR
и
\fIsize\fR
в

байтах \fIoffset\fR, расширяясь на
\fIlength\fR
от имени arena
\fIarena_ind\fR, возвращающий значение false в случае успеха, и в этом случае страницы будут зафиксированы с помощью функции extent commit перед повторным использованием\&. Если функция возвращает значение true, это указывает на отказ от удаления; память остается выделенной и доступной для использования в будущем, и в этом случае она будет автоматически сохранена для последующего повторного использования.
.HP \w'typedef\ bool\ (extent_purge_t)('u
.BI "typedef bool (extent_purge_t)(extent_hooks_t\ * "расширенные крючки", void\ * "адрес", size_t\ "размер", size_t\ "смещение", size_t\ " "длина" ", без знака\ " "arena_ind" ");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция очистки экстента соответствует
типу \fBextent_purge_t\fR
и удаляет физические страницы в отображении виртуальной памяти, связанном с экстентом в данный момент времени.
\fIaddr\fR
и
\fIsize\fR
в

байтах \fIoffset\fR, расширяясь на
\fIlength\fR
от имени arena
\fIarena_ind\fR\&. Функция отложенной очистки экстента (например, реализованная с помощью
мэдвайз(\fI\&.\&.\&.\ fR\fI\fBMADV_FREE\fR\fR)) может задержать очистку на неопределенный срок и оставить страницы в пределах очищенного диапазона виртуальной памяти в неопределенном состоянии, в то время как функция принудительной очистки экстента немедленно очищает страницы в виртуальной памяти. диапазон будет заполнен нулем при следующем обращении к ним. Если функция возвращает значение true, это указывает на ошибку очистки\&.
.HP \w'typedef\ bool\ (extent_split_t)('u
.BI "typedef bool (extent_split_t)(extent_hooks_t\ * "расширенные ссылки", void\ * "адрес", size_t\ "размер", size_t\ "размер_а", size_t\ "размер_b", bool\ "зафиксирован", без знака\ " "арена_инд" ");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция разделения экстента соответствует
типу \fBextent_split_t\fR
и при необходимости разбивает экстент на заданные значения.
\fIaddr\fR
и
\fIsize\fR
разделяются на два смежных экстента, первый из
которых состоит из
байтов \fIsize_a\fR, а второй - из
байтов \fIsize_b\fR
, работающих в
памяти \fIcommitted\fR/списанной памяти, как указано, от имени arena
\fIarena_ind\fR, возвращающая значение false в случае успеха\&. Если функция возвращает значение true, это означает, что экстент остается неразделенным и, следовательно, с ним следует продолжать работать как с целым\&.
.HP \w'typedef\ bool\ (extent_merge_t)('u
.BI "typedef bool (extent_merge_t)(extent_hooks_t\ * "расширенные крючки" ", void\ * " "addr_a" ", size_t\ " "size_a" ", void\ *" "addr_b" ", size_t\ " "size_b" ", bool " "зафиксирован" ", unsigned " " "arena_ind" ");"
.sp
.если n \{\
.RS 4
.\}
.nf
.fi
.если n \{\
.RE
.\}
.sp
Функция слияния экстентов соответствует
\fBextent_merge_t\fR
введите и, при необходимости, объедините смежные экстенты с заданными
\fIaddr_a\fR
и
\fIsize_a\fR
с заданными
\fIaddr_b\fR
и
\fIsize_b\fR
объединяются в один непрерывный экстент, работающий с
\fIcommitted\fR/списанной памятью, как указано, от имени arena
\fIarena_ind\fR, возвращающая значение false в случае успеха\&. Если функция возвращает значение true, это означает, что экстенты остаются различными отображениями и, следовательно, должны по-прежнему обрабатываться независимо\&.
.RE
.PP
арены\&.narenas (\fBunsigned\fR) r\-
.RS 4
Текущее ограничение на количество арен\&.
.RE
.PP
арены\&.dirty_decay_ms (\fBssize_t\fR) rw
.RS 4
Текущее значение по умолчанию для каждой арены - приблизительное время в миллисекундах от создания набора неиспользуемых "грязных" страниц до удаления и/или повторного использования эквивалентного набора неиспользуемых "грязных" страниц, используемое для инициализации
arena.<i>.dirty_decay_ms
во время создания arena. Смотрите
раздел opt\&.dirty_decay_ms
для получения дополнительной информации\&.
.RE
.PP
арены\&.muzzy_decay_ms (\fBssize_t\fR) rw
.RS 4
Текущее значение по умолчанию для\-arena приблизительное время в миллисекундах с момента создания набора неиспользуемых muzzy-страниц до удаления и/или повторного использования эквивалентного набора неиспользуемых muzzy-страниц, используемое для инициализации
arena\&.<i>\&.muzzy_decay_ms
во время создания арены\&. 
Дополнительную информацию смотрите в разделе opt\&.muzzy_decay_ms
\&.
.RE
.PP
арены\&.quantum (\fBsize_t\fR) r\-
.RS 4
Квантовый размер\&.
.RE
.PP
арены\&.страница (\fBsize_t\fR) r\-
.RS 4
Размер страницы\&.
.RE
.PP
arenas\&.tcache_max (\fBsize_t\fR) r\-
.RS 4
Максимальный размер потока\- класс кэшированного размера\&.
.RE
.PP
арены\&.nbins (\fBunsigned\fR) r\-
.RS 4
Количество классов размера ячейки\&.
.RE
.PP
арены\&.nhbins (\fBunsigned\fR) r\-
.RS 4
Общее количество классов размера ячейки кэша потоков\&.
.RE
.PP
арены\&.bin\&.<i>\&.размер (\fBsize_t\fR) r\-
.RS 4
Максимальный размер, поддерживаемый размерным классом\&.
.RE
.PP
арены\&.bin\&.<i>\&.nregs (\fBuint32_t\fR) r\-
.RS 4
Количество областей на слэбе\&.
.RE
.PP
arenas\&.bin\&.<i>\&.размер_слоя (\fBsize_t\fR) r\-
.RS 4
Количество байт на слое\&.
.RE
.PP
арены\&.nlextents (\без подписи\fR) r\-
.RS 4
Общее количество классов большого размера\&.
.RE
.PP
арены\&.lextent\&.<i>\&.размер (\fBsize_t\fR) r\-
.RS 4
Максимальный размер, поддерживаемый этим классом больших размеров\&.
.RE
.PP
арены\&.create (\fBunsigned\fR, \fBextent_hooks_t *\fR) rw
.RS 4
Явно создайте новую арену за пределами диапазона автоматически управляемых арен с необязательно указанными привязками к экстенту и верните новый индекс арены\&.
.RE
.PP
arenas\&.поиск (\fBunsigned\fR, \fBvoid*\fR) rw
.RS 4
Индекс области, к которой относится распределение\&.
.RE
.PP
prof\&.thread_active_init (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Контролируйте начальную настройку для
потока\&.prof\&.active
во вновь созданных потоках\&. 
Дополнительную информацию смотрите в опции opt\&.prof_thread_active_init
\&.
.RE
.PP
prof\&.active (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Определяет, активна ли выборка в данный момент\&. Смотрите параметр
opt\&.
prof_active для получения дополнительной информации, а также взаимосвязанный
поток\&.prof\&.active
mallctl\&.
.RE
.PP
prof\&.dump (\fBconst char *\fR) \-w [\fB\-\-enable\-prof\fR]
.RS 4
Сбросьте профиль памяти в указанный файл или, если указано значение NULL, в файл в соответствии с шаблоном
<префикс>\&.<pid>\&.<seq>\&.m<mseq>\&.heap, где
<префикс>
управляется параметром
opt\&.
prof_prefix\&.
.RE
.PP
prof\&.gdump (\fBbool\fR) rw [\fB\-\-enable\-prof\fR]
.RS 4
Если эта функция включена, запускайте сброс профиля памяти каждый раз, когда общий объем виртуальной памяти превышает предыдущий максимум\&. Профили сбрасываются в файлы, названные в соответствии с шаблоном
<префикс>\&.<pid>\&.<seq>\&.u<useq>\&.heap, где
<префикс>
управляется параметром
opt\&.
prof_prefix\&.
.RE
.PP
prof\и.reset (\fBsize_t\fR) \-w [\fB\-\-enable\-prof\fR]
.RS 4
Сбросьте всю статистику профиля памяти и, при необходимости, обновите частоту дискретизации (см.
opt\&.lg_prof_sample
и
prof\&.lg_sample)\&.
.RE
.PP
prof\&.lg_sample (\fBsize_t\fR) r\- [\fB\-\-enable\-prof\fR]
.RS 4
Получить текущую частоту дискретизации (см.
opt\&.lg_prof_sample)\&.
.RE
.PP
prof\&.интервал (\fBuint64_t\fR) r\- [\fB\-\-включить\-prof\fR]
.RS 4
Среднее количество байт, выделяемых между дампами профиля на основе интервалов. 

Дополнительную информацию смотрите в параметре opt.lg_prof_interval.
.RE
.PP
stats\&.выделено (\fBsize_t\fR) r\- [\fB\-\-enable\-статистика\fR]
.RS 4
Общее количество байт, выделенных приложением\&.
.RE
.PP
stats\&.active (\fBsize_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Общее количество байт на активных страницах, выделенных приложением\&. Это значение кратно размеру страницы и больше или равно
статистика\&.выделено\&. Сюда не входят
stats\&.arenas\&.<i>\&.pdirty,
stats\&.arenas\&.<i>\&.pmuzzy, а также страницы, полностью посвященные метаданным распределителя.
.RE
.PP
статистика\и.метаданные (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество байт, выделенных для метаданных, которые включают базовые распределения, используемые для структур метаданных распределителя, зависящих от bootstrap (см.
stats\&.arenas\&.<i>\&.base) и внутренние распределения (см.
stats\&.arenas\&.<i>\&.internal).\&. Использование прозрачной огромной страницы (включенной с
помощью опции\&.metadata_thp) не учитывается\&.
.RE
.PP
статистика\&.metadata_thp (\fBsize_t\fR) r\- [\fB\-\-enable\-статистика\fR]
.RS 4
Количество прозрачных огромных страниц (THP), используемых для метаданных\&. 
Подробности смотрите в статьях\&.metadata
и
opt\&.metadata_thp).
.RE
.PP
статистика\&.resident (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Максимальное количество байт на физически постоянных страницах данных, отображаемых распределителем, включая все страницы, посвященные метаданным распределителя, страницы, поддерживающие активное распределение, и неиспользуемые "грязные" страницы\&. Это скорее максимальное значение, чем точное, поскольку страницы могут фактически не быть физически резидентными, если они соответствуют виртуальной памяти с нулевым значением по требованию, которая еще не была затронута. Это кратно размеру страницы и больше, чем
stats.active.
.RE
.PP
stats\&.mapped (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество байт в активных экстентах, отображаемых распределителем\&. Это больше, чем
stats\&.active\&. Это не включает неактивные экстенты, даже те, которые содержат неиспользуемые грязные страницы, что означает, что между этим и
stats\&.resident\& нет строгой упорядоченности.
.RE
.PP
статистика\&.сохранено (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество байт в отображениях виртуальной памяти, которые были сохранены, а не возвращены операционной системе через e\&.g\&.
\fBmunmap\fR(2)
или что-то подобное\&. Сохраняемая виртуальная память обычно не затрагивается, выводится из эксплуатации или очищается, поэтому она не имеет строго связанной физической памяти (подробности смотрите в
разделе привязки
к экстенту)\&. Сохраняемая память исключается из статистики сопоставленной памяти, например, \&.
статистика\&.сопоставлено\&.
.RE
.PP
stats\&.background_thread\&.num_threads (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество
фоновых потоков
, запущенных в данный момент\&.
.RE
.PP
stats\&.background_thread\&.num_runs (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество запусков из всех
фоновых потоков\&.
.RE
.PP
статистика\&.background_thread\&.run_interval (\fBuint64_t\fR) r\- [\fB\-\-enable\-статистика\fR]
.RS 4
Средний интервал выполнения
фоновых потоков в наносекундах\&.
.RE
.PP
статистика\&.мьютексы\&.ctl\&.{счетчик}; (конкретный тип счетчика\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIctl\fR
(глобальная область действия; связан с mallctl)\&.
{счетчик}
- это один из приведенных ниже счетчиков:
.PP
.RS 4
\fInum_ops\fR
(\fBuint64_t\fR): Общее количество операций получения блокировки для этого мьютекса\&.
.sp
\fInum_spin_acq\fR
(\fBuint64_t\fR): Количество раз, когда мьютекс был повторно получен\&. Если мьютекс в данный момент заблокирован и не может быть получен немедленно, будет выполнена короткая повторная попытка в jemalloc\&. Полученный с помощью spin, как правило, означает, что конфликт был незначительным и не вызывал переключения контекста\&.
.sp
\fInum_wait\fR
(\fBuint64_t\fR): Количество раз, когда мьютекс был получен в режиме ожидания, что означает, что конфликт мьютексов не был разрешен повторной попыткой, и, вероятно, для получения мьютекса была задействована операция блокировки. Это событие обычно влечет за собой более высокую стоимость / более длительную задержку, и его следует расследовать, если оно случается часто\&.
.sp
\fImax_wait_time\fR
(\fBuint64_t\fR): Максимальное время в наносекундах, затрачиваемое на одну операцию блокировки, полученную в результате ожидания\&. Обратите внимание, что во избежание накладных расходов на профилирование в общем пути, при этом не учитываются случаи, полученные в результате повторной обработки\&.
.sp
\Общее время ожидания\fR
(\fBuint64_t\fR): Суммарное время в наносекундах, затраченное на операции блокировки, связанные с ожиданием\&. Аналогично, случаи, связанные с повторным использованием, не учитываются\&.
.sp
\fImax_num_thds\fR
(\fBuint32_t\fR): Максимальное количество потоков, ожидающих этот мьютекс одновременно\&. Аналогично, случаи, полученные с помощью spin, не рассматриваются\&.
.sp
\fInum_owner_switch\fR
(\fBuint64_t\fR): Количество раз, когда текущий владелец мьютекса отличается от предыдущего\&. Это событие обычно не означает проблему; скорее, это показатель того, как часто разные потоки обращаются к защищенным данным\&
.RE
.RE
.PP
статистика\&.мьютексы\&.background_thread\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIbackground_thread\fR
(глобальная область действия;

связанная с фоновым потоком)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютексов\&.
.RE
.PP
статистика\&.мьютексы\&.prof\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIprof\fR
(глобальная область видимости; связана с профилированием)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютекса\&.
.RE
.PP
статистика\&.мьютексы\&.сброс (\fBvoid\fR) \-\- [\fB\-\-включить\-статистику\fR]
.RS 4
Сбросить всю статистику профиля мьютекса, включая глобальные мьютексы, мьютексы arena и мьютексы bin\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.dss (\fBconst char *\fR) r\-
.RS 4
dss (\fBsbrk\fR(2)) приоритет распределения, связанный с
распределением \fBmmap\fR(2)
. 
Подробности смотрите в opt\&.dss
.
Статистика .RE
.PP
\&.арены\&.<i>\&.dirty_decay_ms (\fBssize_t\fR) r\-
.RS 4
Приблизительное время в миллисекундах с момента создания набора неиспользуемых "грязных" страниц до удаления и/или повторного использования эквивалентного набора неиспользуемых "грязных" страниц\&. Подробности смотрите в разделе
opt\&.dirty_decay_ms
\&.
.RE
.PP
статистика\&.арены\&.<i>\&.muzzy_decay_ms (\fBssize_t\fR) r\-
.RS 4
Приблизительное время в миллисекундах с момента создания набора неиспользуемых muzzy-страниц до удаления и/или повторного использования эквивалентного набора неиспользуемых muzzy-страниц\&. Подробности смотрите в разделе
opt\&.muzzy_decay_ms
\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.nthreads (\fBunsigned\fR) r\-
.RS 4
Количество потоков, назначенных на данный момент arena\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.время безотказной работы (\fBuint64_t\fR) r\-
.RS 4
Время, прошедшее (в наносекундах) с момента создания арены\&. Если <i> равно
\fB0\fR
или
\fBMALLCTL_ARENAS_ALL\fR, это время безотказной работы с момента инициализации malloc\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.pactive (\fBsize_t\fR) r\-
.RS 4
Количество страниц в активных экстентах\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.плотность (\fBsize_t\fR) r\-
.RS 4
Количество страниц в неиспользуемых экстентах, которые потенциально могут быть загрязнены и для которых
не была вызвана функция madvise()
или аналогичная функция\&. 
Описание загрязненных страниц см. в opt\&.dirty_decay_ms
.
Статистика .RE
.PP
\&.arenas\&.<i>\&.pmuzzy (\fBsize_t\fR) r\-
.RS 4
Количество страниц в неиспользуемых пространствах, которые являются нечеткими\&. Смотрите
opt\&.muzzy_decay_ms
для описания muzzy pages\&.
.RE
.PP
статистика\&.арены\&.<i>\&.отображено (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество отображенных байт\&.
.RE
.PP
статистика\&.арены\&.<i>\&.сохранено (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество сохраненных байт\&. Подробности смотрите в разделе
статистика\&.сохранено
\&.
.RE
.PP
статистика\&.арены\&.<i>\&.extent_avail (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество выделенных (но неиспользуемых) структур экстентов в этой области\&.
.RE
.PP
статистика\&.арены\&.<i>\&.база (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество байт, выделенных для структур метаданных распределителя, чувствительных к bootstrap\&.
.RE
.PP
статистика\&.арены\&.<i>\&.internal (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество байт, выделенных для внутренних распределений\&. Внутренние распределения отличаются от распределений, созданных приложением, тем, что они предназначены для внутреннего использования и не указаны в профилях кучи\&.
.RE
.PP
статистика\&.арены\&.<i>\&.metadata_thp (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество прозрачных огромных страниц (THP), используемых для метаданных\&. Подробнее смотрите в разделе
opt\&.metadata_thp
\&.
.RE
.PP
статистика\&.арены\&.<i>\&.резидент (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Максимальное количество байт на физически постоянных страницах данных, отображаемых arena, включая все страницы, посвященные метаданным распределителя, страницы, поддерживающие активные распределения, и неиспользуемые "грязные" страницы\&. Это скорее максимальное значение, чем точное, поскольку страницы могут фактически не быть физически резидентными, если они соответствуют виртуальной памяти с нулевым значением, которая еще не была затронута. Это кратно размеру страницы.
Статистика .RE
.PP
\&.arenas\&.<i>\&.dirty_npurge (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество выполненных операций очистки загрязненных страниц\&.
.RE
.PP
статистика\&.арены\&.<i>\&.dirty_nmadvise (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество
вызовов madvise()
или аналогичных им, выполненных для очистки грязных страниц\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.dirty_purged (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество удаленных грязных страниц\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.muzzy_npurge (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество выполненных операций очистки страниц с помутнением памяти\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.muzzy_nmadvise (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество
madvise()
или аналогичные вызовы, выполняемые для очистки запутанных страниц\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.muzzy_purged (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество удаленных запутанных страниц\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.маленькие\&.выделенные (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество байт, выделяемых в данный момент небольшими объектами\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.small\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Суммарное количество раз, когда с арены запрашивалось небольшое распределение ресурсов (ячейки Aqs, заполнять ли соответствующий tcache, если
выбрать \&.tcache
включен, или для непосредственного удовлетворения запроса на выделение в противном случае\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.small\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество раз, когда небольшое распределение возвращалось в arena\*(ячейки Aqs), независимо от того, очищать ли соответствующий tcache, если
включена функция opt\&.tcache
, или напрямую освобождать распределение в противном случае\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.small\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-enable\-stats\fR]
.RS 4
Суммарное количество запросов на распределение, удовлетворенных всеми классами размера ячейки\&.
.RE
.PP
статистика\&.арены\&.<i>\&.малые\&.заполнения (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.4 доллара
Совокупное количество заполнений tcache всеми классами малого размера\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.small\&.nflushes (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Совокупное количество сбросов tcache всеми малогабаритными классами\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.большие\&.выделенные (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество байт, выделяемых в данный момент крупными объектами\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.large\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Суммарное количество раз, когда из арены был выделен большой объем, независимо от того, нужно ли заполнять соответствующий tcache, если
опция \&.tcache
включена и класс размера находится в пределах кэшируемого диапазона, или напрямую удовлетворять запрос на выделение в противном случае\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.large\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество раз, когда большой объем данных был возвращен на арену, следует ли очистить соответствующий tcache, если
включена функция opt\&.tcache
и класс размера находится в пределах кэшируемого диапазона, или напрямую освободить выделение в противном случае\&.
.RE
.PP
статистика\&.арены\&.<i>\&.большие\&.запросы (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Совокупное количество запросов на выделение, удовлетворенных всеми крупногабаритными классами\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.большие\&.nfills (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Совокупное количество заполнений tcache всеми классами большого размера\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.large\&.n сбрасывает (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Суммарное количество сбросов tcache всеми классами большого размера\&.
.RE
.PP
статистика\&.арены\&.<i>\&.ячейки\&.<j>\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество раз, когда область ячейки соответствующего класса размера выделялась из arena, независимо от того, заполнялся ли соответствующий tcache, если
включена функция opt\&.tcache
, или для непосредственного удовлетворения запроса на выделение в противном случае\&.
.RE
.PP
статистика\&.арены\&.<i>\&.ячейки\&.<j>\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество раз, когда область хранилища соответствующего класса размера возвращалась на арену, следует ли очищать соответствующий tcache, если
выбрать \&.tcache
включен, или напрямую освободить выделение в противном случае\&.
.RE
.PP
статистика\&.арены\&.<i>\&.ячейки\&.<j>\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Совокупное количество запросов на выделение, удовлетворенных областями ячеек соответствующего класса размера\&.
.RE
.PP
статистика\&.арены\&.<i>\&.ячейки\&.<j>\&.текущие значения (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Текущее количество регионов для этого размерного класса\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.ячейки\&.<j>\&.nfills (\fBuint64_t\fR) r\-
.RS 4
Общее количество заполнений кэша tcache\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.ячейки\&.<j>\&.n очищается (\fBuint64_t\fR) r\-
.RS 4
Суммарное количество очищений tcache\&.
Статистика .RE
.PP
\&.arenas\&.<i>\&.bins\&.<j>\&.nslabs (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество созданных плит\&.
.RE
.PP
статистика\&.арены\&.<i>\&.ячейки\&.<j>\&.nreslabs (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.Рупий 4
Суммарное количество раз, когда текущая таблица, из которой выполняется выделение, изменялась\&.
.RE
.PP
статистика\&.арены\&.<i>\&.ячейки\&.<j>\&.curslabs (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Текущее количество плит\&.
.RE
.PP
статистика\&.арены\&.<i>\&.ячейки\&.<j>\&.nonfull_slabs (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Текущее количество незаполненных плит\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.ячейки\&.<j>\&.мьютекс\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIarena\&.<i>\&.bins\&.<j>\fR
(область действия ячейки arena; связанная с работой ячейки)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютекса\&.
.RE
.PP
статистика\&.арены\&.<i>\&.экстенты\&.<j>\&.n{тип экстента} (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Количество экстентов данного типа в этой области в корзине соответствует индексу размера страницы <j>\&. Тип экстента может быть изменен: "грязный", "размытый" или "сохраненный"\&.
.RE
.PP
статистика\&.арены\&.<i>\&.экстенты\&.<j>\&.{extent_type}_bytes (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.Рупий 4
Сумма байтов, управляемых экстентами данного типа в этой области, в корзине, соответствующей индексу размера страницы <j>\&. Тип экстента может быть одним из следующих: "грязный", "размытый" или "сохраненный"\&.
.RE
.PP
статистика\&.арены\&.<i>\&.лексиконы\&.<j>\&.nmalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Общее количество раз, когда на арене выделялась большая часть соответствующего размерного класса, независимо от того, нужно ли заполнять соответствующий tcache, если
включена функция opt\&.tcache
и размерный класс находится в пределах кэшируемого диапазона, или напрямую удовлетворять запрос на выделение в противном случае\&.
.RE
.PP
статистика\&.арены\&.<i>\&.лексиконы\&.<j>\&.ndalloc (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.Рупий 4
Общее количество раз, когда большая часть соответствующего класса размера возвращалась на арену, зависело от того, очищать ли соответствующий tcache, если
опция \&.tcache
включена и класс размера находится в пределах кэшируемого диапазона, или напрямую освобождать выделение в противном случае\&.
.RE
.PP
статистика\&.арены\&.<i>\&.лексиконы\&.<j>\&.nrequests (\fBuint64_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Совокупное количество запросов на выделение, удовлетворенных большими экстентами соответствующего класса размера\&.
.RE
.PP
статистика\&.арены\&.<i>\&.лекстенты\&.<j>\&.curlextents (\fBsize_t\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Текущее количество крупных распределений для этого размерного класса\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.мьютексы\&.большие\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIarena\&.<i>\&.large\fR
(область действия арены; связано с большим распределением ресурсов)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютексов\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.мьютексы\&.extent_avail\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
\fIarena\&.<i>\&.extent_avail \
для мьютекса (область видимости арены; связанная с доступностью степень)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютекса\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.мьютексы\&.расширение_дирти\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIarena\&.<i>\&.extents_dirty\fR
(область действия арены, связанная с грязными экстентами)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютексов\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.мьютексы\&.расширение_музыки\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
\fIarena\&.<i>\&.extents_muzzy \
использует мьютекс (область видимости арены; связанные с ней масззи-экстенты)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютексов\&.
.RE
.PP
статистика\&.арены\&.<i>\&.мьютексы\&.сохраненные значения\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIarena\&.<i>\&.extents_retained\fR
(область действия арены; связанные с сохраненными экстентами)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютексов\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.мьютексы\&.decay_dirty\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
\fIarena\&.<i>\&.мьютекс decay_dirty \fR
(область действия arena; относится к "грязным страницам")\&.
{счетчик}
- это один из счетчиков в
счетчиках профилирования мьютексов\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.мьютексы\&.decay_muzzy\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIarena\&.<i>\&.decay_muzzy \fR
(область действия арены; распад для связанных с muzzy страниц)\&.
{counter}
- это один из счетчиков в
счетчиках профилирования мьютекса\&.
Статистика .RE
.PP
\&.арены\&.<i>\&.мьютексы\&.база\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
\fIarena\&.<i>\&.базовый мьютекс\fR
(область действия arena; связанный с базовым распределителем)\&.
{счетчик}
является одним из счетчиков в
счетчиках профилирования мьютексов\&.
.RE
.PP
статистика\&.арены\&.<i>\&.мьютексы\&.tcache_list\&.{счетчик} (\fBcounter определенного типа\fR) r\- [\fB\-\-включить\-статистику\fR]
.RS 4
Статистика по
мьютексу \fIarena\&.<i>\&.tcache_list\fR
(область действия арены; привязка tcache к арене)\&. Ожидается, что к этому мьютексу будут обращаться реже\&.
{counter}
- это один из счетчиков в
счетчиках профилирования мьютекса\&.
.RE
.SH "ФОРМАТ ПРОФИЛЯ КУЧИ"
.PP
Хотя функциональность профилирования кучи изначально была разработана для обеспечения совместимости с командой
\fBpprof\fR
, которая разработана как часть
пакета \m[blue]\fBgperftools\fR\m[]\&\s-2\u[3]\d\s+2, добавление для каждой функции профилирования кучи потоков требовался другой формат профиля кучи\&. Команда
\fBjeprof\fR
является производной от
\fBpprof\fR, с улучшениями для поддержки описанного здесь формата профиля кучи\&.
.PP
В следующем гипотетическом профиле
кучи \fB[\&.\&.\&.]\fR
указывает на исключение в целях компактности\&.
.sp
.если n \{\
.RS 4
.\}
.nf
heap_v2/524288
  т*: 28106: 56637512 [0: 0]
  [\&.\&.\&.]
  t3: 352: 16777344 [0: 0]
  [\&.\&.\&.]
t99: 17754: 29341640 [0: 0]
  [\&.\&.\&.]
@ 0x5f86da8 0x5f5a1dc [\&.\&.\&.] 0x29e4d4e 0xa200316 0xabb2988 [\&.\&.\&.]
  t*: 13: 6688 [0: 0]
  t3: 12: 6496 [0: ]
  t99: 1: 192 [0: 0]
[\&.\&.\&.]

ОТОБРАЖЕННЫЕ_БИБЛИОТЕКИ:
[\&.\&.\&.]
. fi
.если n \{\
.RE
.\}
.sp
Следующее соответствует приведенному выше профилю кучи, но большинство токенов заменены на
\fB<описание>\fR
, чтобы указать описания соответствующих полей\&.
.sp
.если n \{\
.RS 4
.\}
.nf
<heap_profile_format_version>/<mean_sample_interval>
  <агрегат>: <curobjs>: <curbytes> [<cumobjs>: <cumbytes>]
  [\&.\&.\&.]
  <thread_3_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <кумбайт>]
  [\&.\&.\&.]
  <thread_99_aggregate>: <curobjs>: <curbytes>[<cumobjs>: <кумбайт>]
  [\&.\&.\&.]
@ <верхний_фрейм> <рамка> [\&.\&.\&.] <рамка> <рамка> <рамка> [\&.\&.\&.]
  <backtrace_aggregate>: <curobjs>: <curbytes> [<cumobjs>: <кумбайт>]
  <backtrace_thread_3>: <curobjs>: <curbytes> [<cumobjs>: <кумбайт>]
  <backtrace_thread_99>: <curobjs>: <curbytes> [<cumobjs>: <кумбайт>]
[\&.\&.\&.]

СОПОСТАВЛЕННЫЕ БИБЛИОТЕКИ:
</proc/<pid>/maps>
.fi
.если n \{\
.RE
.\}
.SH "ОТЛАДКА ПРОБЛЕМ С MALLOC"
.PP
При отладке рекомендуется настроить/создать jemalloc с параметрами
\fB\-\-enable\-debug\fR
и
\fB\-\-enable\-fill\fR
и перекомпилировать программу с подходящими параметрами и символами для поддержки отладчика\&. При такой настройке jemalloc включает в себя широкий спектр утверждений во время выполнения, которые выявляют ошибки приложения, такие как double\-free, write\-after\-free и т.д.\&.

Программы .PP часто случайно зависят от
того, что неинициализированная память rq
на самом деле заполнена нулевыми байтами. Ненужное заполнение (см.
вариант \&.junk
option) приводит к выявлению таких ошибок в виде явно неверных результатов и/или сбоев в работе\&. И наоборот, нулевое заполнение (см. опцию
opt\&.zero
) устраняет признаки таких ошибок\&. Используя эти два варианта, обычно можно быстро обнаружить, диагностировать и устранить такие ошибки\&.
.PP
Данная реализация не содержит подробных сведений о проблемах, которые она обнаруживает, поскольку хранение такой информации негативно скажется на производительности \&.
.SH "ДИАГНОСТИЧЕСКИЕ СООБЩЕНИЯ"
.PP
Если какая-либо из функций выделения/освобождения памяти обнаружит ошибку или предупреждение, в дескриптор файла будет выведено сообщение
\fBSTDERR_FILENO\fR\&. Ошибки приведут к тому, что процесс сбросит ядро\&. Если
установлен параметр opt\&.abort
, большинство предупреждений обрабатываются как ошибки\&.
.PP
Переменная
\fImalloc_message\fR
позволяет программисту переопределить функцию, которая выдает текстовые строки, формирующие ошибки и предупреждения, если по какой-либо причине
файловый дескриптор \fBSTDERR_FILENO\fR
не подходит для этого\&.
malloc_message()
принимает
аргумент указателя \fIcbopaque\fR
, который равен
\fBNULL\fR
если это не переопределено аргументами в вызове
функции malloc_stats_print(), за которыми следует строковый указатель\&. Пожалуйста, обратите внимание, что любые действия, которые пытаются выделить память в этой функции, могут привести к сбою или взаимоблокировке\&.
.PP
Все сообщения имеют префикс
\(lq<jemalloc>: \(rq\&.
.SH "ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ"
.SS "Стандартный API"
.PP
Функции
malloc()
и
calloc()
в случае успеха функции возвращают указатель на выделенную память; в противном
случае возвращается указатель \fBNULL\fR
и
\fIerrno\fR
присваивается значение
ENOMEM\&.
.PP
Функция
posix_memalign()
в случае успеха функция возвращает значение 0; в противном случае она возвращает значение ошибки\&. Функция
posix_memalign()
завершится ошибкой, если:
.PP
EINVAL
.RS 4
Параметр
\fIalignment\fR
не имеет степени 2, по крайней мере, такой же большой, как
sizeof(\fBvoid *\fR)\&.
.RE
.PP
ENOMEM
.RS 4
Ошибка выделения памяти\&.
.RE
.PP
Функция
aligned_alloc()
в случае успеха возвращает указатель на выделенную память; в противном
случае
возвращается указатель
\fBNULL\fR
и устанавливается значение \fIerrno\fR\&. Функция
aligned_alloc()
завершится ошибкой, если:
.PP
EINVAL
.RS 4
Параметр
\fIalignment\fR
не имеет степени 2\&.
.RE
.PP
ENOMEM
.RS 4
Ошибка выделения памяти\&.
ПОВТОРИТЕ

использование функции realloc
()
функция возвращает указатель, возможно, идентичный
\fIptr\fR, на выделенную память в случае успеха; в противном
случае возвращается указатель \fBNULL\fR
, а
\fIerrno\fR
присваивается значение
ENOMEM
, если ошибка была результатом сбоя выделения\&. Функция
realloc()
всегда оставляет исходный буфер нетронутым при возникновении ошибки\&.
.PP
Функция
free()
не возвращает значения\&.
.SS "Нестандартный API"
.PP
Функции
mallocx()
и
rallocx()
возвращают указатель на выделенную память в случае успеха; в противном
случае \fBNULL\fR
возвращается указатель, указывающий на то, что для обслуживания запроса на выделение было доступно недостаточно непрерывной памяти\&.
.PP
Функция
xallocx()
возвращает реальный размер результирующего распределения с измененным размером, на который указывает
\fIptr\fR, что является значением меньшим, чем
\fIsize\fR
, если распределение не удалось соответствующим образом увеличить на месте\&.
.PP
Функция
sallocx()
возвращает реальный размер распределения, на который указывает
\fIptr\fR\&.
.PP
Функция
nallocx()
возвращает реальный размер, который был бы получен в результате успешного выполнения эквивалентной
функции mallocx()
вызов функции или ноль, если недостаточно доступной памяти для выполнения вычисления размера\&.
.PP
Функции
mallctl(),
mallctlnametomib() и
mallctlbymib()
возвращают значение 0 в случае успешного выполнения; в противном случае они возвращают значение ошибки\&. Функции завершатся ошибкой, если:
.PP
EINVAL
.RS 4
\fInewp\fR
не является
\fBNULL\fR, а
\fInewlen\fR
слишком велик или слишком мал\&. В качестве альтернативы,
\fI*oldlenp\fR
слишком большой или слишком маленький; в этом случае считывается как можно больше данных, несмотря на ошибку\&.
.RE
.PP
ENOENT
.RS 4
\fIname\fR
или
\fImib\fR
указывает неизвестное/недопустимое значение\&.
.RE
.PP
EPERM
.RS 4
Попытка считывания или записи недействительного значения или попытка записи значения, доступного только для чтения.
.RE
.PP
EAGAIN
.RS 4
Произошел сбой выделения памяти.
.RE
.PP
EFAULT
.RS 4
Произошел сбой интерфейса с побочными эффектами, не связанными напрямую с
mallctl*()
обработка чтения/записи\&.
.RE
.PP
Функция
malloc_usable_size()
возвращает полезный размер распределения, на который указывает
\fIptr\fR\&.
.SH "СРЕДА"
.PP
Следующая переменная среды влияет на выполнение функций распределения:
.PP
\fBMALLOC_CONF\fR
.RS 4
Если переменная окружения
\fBMALLOC_CONF\fR
если значение задано, содержащиеся в нем символы будут интерпретироваться как опции\&.
.RE
.SH "ПРИМЕРЫ"
.PP
Для удаления ядра при возникновении проблемы:
.sp
.если n \{\
.RS 4
.\}
.nf
ln \-s \*(Aqabort:true\*(Aq /etc/malloc\&.conf
.fi
.if n \{\
.RE
.\}
.PP ) . Если нет, то это ошибка.
Указать в источнике, что автоматически должна быть создана только одна арена:
.sp
.если n \{\
.RS 4
.\}
.nf
malloc_conf = "арены:1";
.fi
.если n \{\
.RE
.\}
.SH "СМОТРИ ТАКЖЕ"
.PP
\fBmadvise\fR(2),
\fBmmap\fR(2),
\fBsbrk\fR(2),
\fButrace\fR(2),
\fBalloca\fR(3),
\fBatexit\fR(3),
\fBgetpagesize\fR(3)
.SH "СТАНДАРТЫ"
.PP

- это функции malloc(),
calloc(),
realloc() и
free().
функции соответствуют стандарту ISO/IEC 9899:1990 (\(lqISO C90\(rq)\&.
.

УКАЖИТЕ posix_memalign()
функция соответствует стандарту IEEE Std 1003\&.1\-2001 (\(lqPOSIX\&.1\(rq)\&.
.SH "ИСТОРИЯ"
.PP
Функции
malloc_usable_size()
и
posix_memalign()
впервые появились во FreeBSD 7\&.0\&.
.PP
Функции
aligned_alloc(),
malloc_stats_print() и
mallctl*()
впервые появились во FreeBSD 10\&.0\&.
.PP
Функции
*allocx()
впервые появились во FreeBSD 11\&.0\&.
.SH "АВТОР"
.PP
\Джейсон Эванс\fR
.RS 4
.RE
.SH "ПРИМЕЧАНИЯ"
.IP " 1." 4
Веб-сайт
jemalloc .RS 4
\%http://jemalloc.net/
.RE
.IP " 2." 4
Формат JSON
.RS 4
\%http://www.json.org/
.RE
.IP " 3." 4
пакет gperftools
.RS 4
\%http://code.google.com/p/gperftools/
.RE
