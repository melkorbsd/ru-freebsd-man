.\" #
.\" # Copyright (c) 2014, Juniper Networks, Inc.
.\" # All rights reserved.
.\" # This SOFTWARE is licensed under the LICENSE provided in the
.\" # ../Copyright file. By downloading, installing, copying, or
.\" # using the SOFTWARE, you agree to be bound by the terms of that
.\" # LICENSE.
.\" # Phil Shafer, July 2014
.\"
.Dd December 4, 2014
.Dt LIBXO 3
.Os
.Sh ИМЯ
.Nm xo_format
.Найдите содержимое дескрипторов формата для xo_emit 
.Sh Описание 
.Pp 
.Nm libxo 
использует строки формата для управления преобразованием данных в 
различные стили вывода, включая 
.Em text , 
.Em XML , 
.Em JSON, 
и 
.Em HTML .
Каждая строка формата содержит набор из нуля или более
.Dq "описания полей", 
которые описывают независимые поля данных.
Описание каждого поля содержит набор модификаторов 
.Dq, 
a 
.Dq "строка содержимого", 
и ноль, один или два 
.Dq "дескрипторы формата" .
Модификаторы сообщают 
.Nm libxo 
что это за поле и как с ним обращаться, в то время как дескрипторы формата представляют собой 
инструкции по форматированию с использованием
.Xr printf 3 в стиле Ns 
строки формата, сообщающие
.Nm libxo 
как отформатировать поле.
Описание поля помещается внутри 
набор фигурных скобок с двоеточием 
.Ql ( \&: ) 
после модификаторов и косой черты
.Ql ( \&/ )
перед каждым дескриптором формата.
Текст может быть перемешан с 
описаниями полей в строке формата.
.Pp
Описание поля приведено следующим образом:
.Bd -literal -offset indent
 \(aq{\(aq [ роль | модификатор ]* [\(aq,\(aq длинные \ имена ]* \(aq:\(aq [ содержимое ]
 [ \(aq/\(поле aq\-формат [ \(aq/\(кодировка aq\-формат ]] \(aq}\(aq 
.Ed 
.Pp 
Роль описывает функцию поля, в то время как модификаторы
включите необязательное поведение.
Содержимое, поле \-формат и 
кодировка \-формат используются по-разному в зависимости от роли.
Они описаны в следующих разделах.
.Pp 
Фигурные скобки можно убрать с помощью двойных фигурных скобок, аналогичных "%%" в
.Xr printf 3 .
Строка формата "{{фигурные скобки}}" выдаст "{фигурные скобки}".
.Pp
В следующем примере отображаются три дескриптора полей.
Первое поле 
представляет собой заполняющее поле, содержащее три пробела для заполнения, второе - это метка 
("В наличии"), а третье - поле значения ("в\-stock").
Поле in\-stock имеет формат "%u", который будет анализировать следующий аргумент 
передается в 
.Xr xo_emit 3 , 
функционирует как целое число без знака.
.Bd -literal -offset indent
 xo_emit("{P: }{Lwc:В наличии}{:в\-stock/%u}\\n", 65);
.Ed 
.Рр
Эта единственная строка кода может генерировать текст ("В наличии: 65\\n"), XML
("<in\-stock>65</in\-stock>"), JSON (\(aq"in\-stock": 65\(aq)) или HTML (тоже 
длинный, чтобы быть перечисленным здесь).
.Pp 
В то время как роли и модификаторы обычно используют один символ для краткости, 
для каждого из них существуют альтернативные названия, которые позволяют использовать более подробные сведения 
строки форматирования.
Эти имена должна стоять запятая, и может следовать любой
один\-символьным значениям:
.Bd -literal -offset indent
 xo_emit("{L, белый, двоеточие: В наличии}{,ключ:в наличии\-stock/%u}\\n", 65);
.Ed 
.Ss "Роли на местах"
Роли на местах являются необязательными и указывают роль и форматирование 
содержимого.
Роли перечислены ниже; разрешена только одна роль:
.Bl -column "M" "Name12341234"
.It Sy "M" "Название" "Описание"
.It C "цвет" "Поле представляет собой цвет или эффект"
.It "оформление" "Поле не является текстовым (например, двоеточие, запятая)"
.It "ошибка" "Поле является сообщением об ошибке"
.It L "метка", "Поле - это текст, добавляющий value"
.It N "примечание", "Поле - это текст, следующий за valueм"
.It P "заполнение", "Поле - это пробелы, необходимые для выравнивания по вертикали"
.It поле "title " - "value заголовка для заголовков".
.It U "единицы измерения" "Поле - это единицы измерения для поля предыдущего значения"
.It V "value" "Поле - это название поля (по умолчанию)"
.It W "предупреждение" "Поле - это предупреждающее сообщение"
.It \&[ "start\-anchor" "Начать раздел текста с привязанной переменной шириной"
.It \&] "stop\-anchor " "Завершить раздел текста с привязанной переменной шириной"
.El 
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("{L:Бесплатно}{D::}{P: }{:бесплатно/%u} {U:Блоки}\\n", 
 free_blocks);
.Ed
.Pp
Когда роль не обеспечили, о "ценности" роль используется в качестве значения по умолчанию.
.Pp
Функции и модификаторы также могут использовать более информативные имена, когда перед ней стоит
запятая:
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("{,надпись: свободная}{, оформление::}{, отступ:}"
 "{,value: свободно/%u} {,единицы измерения: блоки}\\n", 
 free_blocks);
.Ed 
.Ss "Роль цвета ({C:})"
Цвета и эффекты определяют способ отображения текстовых значений; 
они используются для стилей отображения (ТЕКСТ и HTML).
.Bd -literal -offset indent 
 xo_emit("{C: жирный шрифт}{:value}{C:no\-bold}\\n", value);
.Ed 
.Pp 
Цвета и эффекты остаются в силе до тех пор, пока не будут изменены другими полями "C" \-role 
.
.Bd -literal -offset indent
 xo_emit("{C: жирный шрифт}{C: обратный} оба {C:no\-bold} только обратный \\n");
.Ed 
.Pp
Если содержимое пустое, выполняется действие "сброс".
.Bd -literal -offset indent 
 xo_emit("{C: both,underline}{:value}{C:}\\n", value);
.Ed 
.Pp
Содержимое должно представлять собой список из нуля или более цветов, разделенных запятыми, или 
эффекты отображения.
.Bd -literal -offset indent 
 xo_emit("{C:bold,underline,inverse} Все три{C:no\-bold,no\-inverse}\\n");;
.Ed 
.Pp
Цветовое содержимое может быть либо статическим, когда оно размещается непосредственно внутри 
дескриптора поля, либо может использоваться дескриптор формата printf\-style, 
если перед ним стоит косая черта ("/"):
.Bd -literal -offset indent 
 xo_emit("{C:/%s%s}{:value}{C:}", need_bold ? "жирный" : "", 
 need_underline ? "подчеркивание" : """, value);
.Ed 
.Pp 
Названия цветов имеют префикс либо "fg \-", либо "bg \-" для изменения 
цветов переднего плана и фона соответственно.
.Bd -literal -offset indent 
xo_emit("{C:/fg\-%s,bg\-%s}{Lwc:стоимость}{:стоимость/%u}{C: сброс}\\n", 
 fg_color, bg_color, стоимость);
.Ed 
.Pp
В следующей таблице перечислены поддерживаемые эффекты:
.Bl -column "нет \-underline"
.It "Название", "Описание"
.It "bg \-xxxxx" "Изменить цвет фона"
.It "bold" "Запускает эффект текста жирным шрифтом"
.It "fg \-xxxxx" "Изменяет цвет переднего плана"
.It "inverse" "Запускает эффект текста обратным образом"
.It "no \-bold" "Остановить эффект выделения текста жирным шрифтом"
.It "no \-inverse" "Остановить эффект обратного текста"
.It "no \-underline" "Остановить эффект подчеркивания текста"
.It "обычный" "Сброс эффектов (только)"
.It "сброс" "Сброс цветов и эффектов (восстановление значений по умолчанию)"
. Это "подчеркивание" "Запуск эффекта подчеркивания текста"
.El 
.Pp
Поддерживаются следующие названия цветов:
.Bl -column "no\-underline"
.It Sy "Name"
.It черный
.It синий
.It голубой
.It по умолчанию
.It зеленый
.It пурпурный
.It красный
.Оно белое
.Оно желтое 
.El 
.Ss "Роль декоратора ({D:})"
Украшениями обычно являются знаки препинания, такие как двоеточия, 
точки с запятой и запятые, используемые для украшения текста и упрощения его оформления 
для обычных читателей.
Четко обозначив их, сценарии использования HTML 
могут использовать CSS для управления параметрами отображения.
.Bd -literal -offset indent 
 xo_emit("{D:((}{:name}{D:))}\\n", имя);
.Ed 
.Ss "Роль Gettext ({G:})"
.Nm libxo 
поддерживает интернационализацию (i18n) за счет использования 
.Xr gettext 3 .
Используйте роль "{G:}", чтобы запросить, чтобы оставшаяся часть
строка формата, следующая за полем "{G:}", обрабатывается с помощью 
.Fn gettext .
Поскольку
.Fn gettext 
использует строку в качестве ключа к каталогу сообщений, 
.Nm libxo 
использует упрощенную версию строки формата, которая удаляет 
несущественное форматирование полей и модификаторы, останавливая второстепенное форматирование 
изменения, не влияющие на дорогостоящий процесс перевода.
Разработчик 
изменения, такие как изменение "/% 06d" на "/% 08d", не должны вызывать ручную проверку 
проверка всех файлов .po.
.Pp
Упрощенная версия может быть сгенерирована для отдельного сообщения с помощью команды 
"xopo \-s <текст>" или для всего .pot может быть переведен с помощью 
команда "xopo \-f <ввод> \-o <вывод>".
.Bd -literal -offset indent 
 xo_emit("{G:} Недопустимый токен \\n");
.Ed 
.Pp
Роль {G:} позволяет задавать доменное имя.
.Fn gettext 
вызовы будут 
продолжать использовать это доменное имя до получения текущей строки формата 
обработка завершена, что позволяет библиотечной функции генерировать строки 
используя его \(собственный каталог aqs.
Имя домена может быть либо статическим в качестве 
содержимого поля, либо формат может использоваться для получения имени домена 
из аргументов.
.Bd -literal -offset indent 
 xo_emit("Служба{G: libc} недоступна в ограниченном режиме\\n"); 
.Ed
.Ss "Роль метки ({L:})"
Метки - это текст, который появляется перед valueм.
.Bd -literal -offset indent 
 xo_emit("{Lwc:Стоимость}{:стоимость/%u}\\n", стоимость);
.Ed 
.Pp
Если метка должна содержать косую черту, ее необходимо экранировать с помощью двух 
обратных косых черт, одной для компилятора C и одной для 
.Nm libxo .
.Bd -literal -offset indent 
 xo_emit("{Lc: Низкий \\\\/уровень предупреждения}{:уровень/%s}\\n", уровень);
.Ed 
.Ss "Роль примечания ({N:})"
Примечания - это текст, который появляется после значения.
.Bd -literal -offset indent 
 xo_emit("{:стоимость/%u} {N:в год}\\n", стоимость);
.Ed 
.Ss "Роль заполнения ({P:})"
Заполнение представляет собой пробелы, используемые перед полями и между ними.
Содержимое заполнения может быть либо статическим, когда оно размещается непосредственно внутри 
дескриптора поля, либо может использоваться дескриптор формата в стиле printf\, 
если перед ним стоит косая черта ("/"):
.Bd -literal -offset indent 
 xo_emit("{P: }{Lwc:Стоимость}{:стоимость/%u}\\n", стоимость);
 xo_emit("{P:/30s}{Lwc:стоимость}{:стоимость/%u}\\n", "", стоимость);
.Ed 
.Ss "Роль заголовка ({T:})"
Заголовки - это заголовки заголовков или столбцов, которые предназначены для отображения 
пользователю.
Заголовок может быть либо статическим, когда он размещается непосредственно внутри 
дескриптора поля, либо может использоваться дескриптор формата printf\-style,
если перед ним косая черта ("/"):
.Bd -literal -offset indent 
 xo_emit("{T: Статистика интерфейса}\\n");
 xo_emit("{T:/%20.20s}{T:/%6.6s}\\n", "Наименование товара", "Стоимость");
.Ed 
.Ss "Роль единиц измерения ({U:})"
Единицы измерения - это измерение, с помощью которого измеряются значения, такие как градусы, 
мили, байты и децибелы.
Поле единиц измерения содержит эту информацию 
для поля предыдущего значения.
.Bd -literal -offset indent 
 xo_emit("{Lwc: Расстояние}{:distance/%u}{Uw: мили}\\n", мили);
.Ed 
.Pp
Обратите внимание, что value модификатора \(aqw \(aqq изменено на обратное для единиц измерения;
пробел добавляется перед содержимым, а не после него.
.Pp
Когда 
.XOF_UNITS ДВ 
флаг устанавливается, подразделения выводятся в XML как
.Edиницы йй 
атрибут:
.Bd -literal -offset indent
 <distance units="miles">50</distance>
.Ed 
.Pp 
Единицы измерения также могут быть отображены в HTML как атрибут "data \-units":
.Bd -literal -offset indent 
 <div class="data" данные\-tag="расстояние" данные\-единицы измерения ="мили"
 data\-xpath="/top/данные/расстояние">50</div>
.Ed 
.Ss "Роль значения ({V:} и {:})"
Роль value используется для представления значения данных, которое является 
интересным для стилей вывода без отображения (XML и JSON).
value
является ролью по умолчанию; если другое обоvalue роли не указано, поле 
является valueм.
Имя поля должно отображаться в дескрипторе поля, 
за которым следуют один или два дескриптора формата.
Первый формат 
дескриптор используется для стилей отображения (ТЕКСТ и HTML), в то время как 
второй используется для стилей кодирования (XML и JSON).
Если второй формат не указан 
, по умолчанию в качестве формата кодировки используется первый формат, 
с удалением любой минимальной ширины.
Если первый формат не указан, в обоих 
дескрипторах формата по умолчанию используется "%s".
.Bd -literal -offset indent 
xo_emit("{:длина/%02u}x{:ширина/%02u}x{: высота /%02u}\\n", 
 длина, ширина, высота);
 xo_emit("{:автор} написал"{:стихотворение}" в {: год/%4d}\\n, 
 автор, стихотворение, год); 
.Ed 
.Ss "Роли якоря ({[:} и {]:})"
Роли привязки позволяют дополнять набор строк как группу, 
но при этом они все равно будут видны для
.Xr xo_emit 3 
как отдельные поля.
Привязка start 
или stop может указывать ширину поля, и она может быть либо непосредственно в 
дескрипторе, либо передаваться в качестве аргумента.
Любые поля между привязками start 
и stop дополняются, чтобы соответствовать заданной минимальной ширине.
.Pp
Чтобы задать ширину напрямую, закодируйте ее как содержимое тега привязки:
.Bd -literal -offset indent 
 xo_emit("({[:10}{: min/%d}/{:max/%d}{]:})\\n", min, max); 
.Ed 
.Pp
Чтобы передать ширину в качестве аргумента, используйте "% d" в качестве формата, который должен быть указан 
после "/".
Обратите внимание, что для значений ширины поддерживается только "% d".
Использование любого другого значения может испортить вам день.
.Bd -literal -offset indent 
 xo_emit("({[:/%d}{:min/%d}/{:max/%d}{]:})\\n", ширина, минимальная, максимальная); 
.Ed 
.Pp
Если ширина отрицательная, справа будет добавлено дополнение, подходящее 
для выравнивания по левому краю.
В противном случае заполнение будет добавлено к 
слева от полей между привязками start и stop, что подходит для 
выравнивания по правому краю.
Если ширина равна нулю, ничего не происходит.
Если 
количество столбцов выходных данных между привязками start и stop меньше 
абсолютного значения заданной ширины, ничего не происходит.
.Pp 
Ширина более 8 кб считается вероятной ошибкой и не поддерживается.
Если установлено value 
.Dv XOF_WARN 
, будет сгенерировано предупреждение.
.Ss "Модификаторы полей"
Модификаторы полей - это флаги, которые изменяют способ отправки содержимого для 
определенных стилей вывода:
.Bl -column M "Name123456789"
.It Sy M "Name " "Description"
.It "аргумент" "Содержимое отображается как ""const char *""аргумент"
.It c "двоеточие " "После метки добавляется двоеточие (""":""")"
.It d "отображать" "Выделяет только поле для стилей отображения (текст / HTML)"
.It e "encoding" "Выдает только для стилей кодирования (XML / JSON)"
.It h "humanize (hn)" "Форматирует большие числа в удобочитаемом стиле"
.It " " "hn\-space " "Очеловечить: поместить пробел между числом и единицей измерения"
.It " " "hn\-decimal " "Очеловечить: добавить десятичную цифру, если число < 10"
.It " " "hn\-1000 " "Очеловечить: использовать 1000 в качестве делителя вместо 1024"
.It k "key " "Поле - это ключ, подходящий для предикатов XPath"
.It l "лист \-list ", "Поле представляет собой лист \-list , список конечных значений"
.It n "без \-quotes ", "Не заключать поле в кавычки при использовании стиля JSON".
.It q "кавычки", "Заключать поле в кавычки при использовании стиля JSON"
.It t "обрезать", "Обрезать начальные и конечные пробелы".
.It с "пробелом" "После метки добавляется пробел ("" " "")"
.El 
.Pp 
Например, строка-модификатор "Lwc" означает, что у поля есть метка 
роль (текст, описывающий следующее поле), за которым должен следовать 
двоеточие (\(aqc\(aq) и пробел (\(aqw\(aq).
Строка-модификатор "Vkq" означает, что у поля 
есть роль значения, что оно является ключом для текущего экземпляра, и
это value должно быть заключено в кавычки при кодировании для JSON.
.Pp
Функции и модификаторы также могут использовать более информативные имена, когда перед ней стоит
запятая.
Например, строка-модификатор "Lwc" (или "L, белый, двоеточие")
означает, что поле играет роль метки (текст, описывающий следующее поле) 
за ним должно следовать двоеточие (\(aqc\(aqq) и пробел (\(aqw \(aqq).
Строка-модификатор "Vkq" (или ":ключ, кавычка") означает, что поле имеет value 
роль (роль по умолчанию), что это ключ для текущего экземпляра, 
и что value должно быть заключено в кавычки при кодировании в формате JSON.
.Ss "Модификатор аргумента ({a:})"
Модификатор аргумента указывает, что содержимое поля 
дескриптор будет помещен в качестве аргумента UTF\-8 string (const char *) 
в параметрах xo_emit.
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("{La:} {a:}\\n", "Текст метки", "метка", "значение");
 ТЕКСТ:
 Текстовое value метки
 JSON:
 "label": "value"
 XML:
 <label>value</label>
.Ed 
.Pp 
Модификатор аргумента позволяет передавать имена полей значений 
в стеке, избегая необходимости создавать дескриптор поля с использованием
.Xr snprintf 1 .
Для многих полевых ролей модификатор аргумента не требуется,
поскольку у этих ролей есть определенные механизмы для аргументов, 
такие как "{C:fg\-%s}".
.Ss "Модификатор двоеточия ({c:})"
Модификатор двоеточия добавляет одно двоеточие к значению данных:
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("{Lc:Name}{:name}\\n", "phil");
 ТЕКСТ:
 Имя:phil 
.Ed 
.Pp
Модификатор двоеточия используется только для вывода текста и HTML-кода 
стили.
Обычно он комбинируется с модификатором пробела (\(aq{w:}\(aq).
Это чисто удобная функция.
.Ss "Модификатор отображения ({d:})"
Модификатор отображения указывает, что поле должно создаваться только для 
стилей вывода на дисплей, текста и HTML.
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("{Lcw:Name}{d:name} {:id/%d}\\n", "phil", 1);
 ТЕКСТ:
 Имя: phil 1
 XML:
 <id>1</id>
.Ed 
.Pp
Модификатор отображения противоположен модификатору кодирования, и 
они часто используются для предоставления различных представлений базовых данных.
.Ss "Модификатор кодирования ({e:})"
Модификатор encoding указывает, что поле должно быть сгенерировано только для 
стилей вывода encoding, таких как JSON и XML.
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("{Lcw:Name}{:имя} {e:id/%d}\\n", "фил", 1);
 ТЕКСТ:
 Имя: фил
 XML:
 <имя>фил</name><id>1</id>
.Ed 
.Pp
Модификатор encoding противоположен модификатору display, и 
они часто используются для предоставления различных представлений базовых данных.
.Ss "Модификатор Humanize ({h:})"
Гуманизировать модификатор используется для отображения больших чисел как в
человека\-формат, читабельный.
В то время как цифры "44470272" абсолютно читабельный к компьютерам и
ученые, люди, как правило, найти "44М" более содержательными.
.Pp 
"hn" может использоваться как псевдоним для "humanize".
.Pp
Модификатор humanize влияет только на стили отображения (ТЕКСТ и HMTL).
Опция "no \-humanize" заблокирует функцию модификатора humanize.
.Pp 
Существует ряд модификаторов, которые влияют на детали гуманизации.
Они доступны только в виде полных имен, а не отдельных символов.
Модификатор "hn\-space" помещает пробел между числом и любым символом множителя 
, таким как "M" или "K" (например, "44 K").
Модификатор "hn \-decimal" добавит десятичную точку и одну десятую цифру 
если число меньше 10 (например, "4.4K").
Модификатор "hn \-1000" будет использовать 1000 в качестве делителя вместо 1024, следуя 
JEDEC \-стандарт вместо более естественной двоичной степени \-of \-two 
традиция.
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("{h:input/%u}, {h,hn\-пробел: вывод/%u}, "
 "{h,hn\-десятичная дробь: ошибки/%u}, {h,hn\-1000: емкость/%u}, "
 "{h,hn\-десятичный: осталось/%u}\\n", 
 ввод, вывод, ошибки, емкость, осталось);
 ТЕКСТ:
 21, 57 K, 96M, 44M, 1.2G
.Ed 
.Pp
В стиле HTML исходное числовое value отображается в атрибуте 
"data\-number" элемента <div>:
.Bd -literal -offset indent 
 <div class="data" data\-tag="ошибки"
 data\-number="100663296">96M</div>
.Ed 
.Ss "Модификатор Gettext ({g:})"
Модификатор gettext используется для перевода отдельных полей с использованием 
домена gettext (обычно задается с использованием роли "{G:}") и текущих 
языковых настроек.
Как только libxo отобразит value поля, оно передается 
в
.Xr gettext 3 , 
где оно используется как ключ для поиска родного языка 
перевод.
.Pp
В следующем примере строки "State" и "full" передаются 
в 
.Fn gettext 
для поиска переведенных строк на основе locale\.
.Bd -literal -offset indent 
 xo_emit("{Lgwc:State}{g:state}\\n", "полный");
.Ed 
.Ss "Модификатор ключа ({k:})"
Модификатор ключа используется для указания того, что конкретное поле помогает
уникальная идентификация экземпляра данных списка.
.Bd -literal -offset indent
 ПРИМЕР:
 xo_open_list("user");
 for (i = 0; i < num_users; i++) {
 xo_open_instance("user");
 xo_emit("У пользователя {k:name} есть билеты {:count}\\n", 
 user[i].u_name, user[i].u_tickets);
 xo_close_instance("user");
 }
 xo_close_list("user");
.Ed 
.Pp 
В настоящее время модификатор key используется только при генерации значений XPath 
для стиля вывода HTML, когда установлен параметр
.Dv XOF_XPATH 
, но в ближайшем будущем возможны другие варианты использования.
.Ss "Модификатор Leaf\-List ({l:})"
Модификатор leaf\-list используется для различения списков, каждый из которых 
экземпляр состоит только из одного значения. В XML они 
отображаются как отдельные элементы, где JSON отображает их как массивы.
.Bd -literal -offset indent
 ПРИМЕР:
 xo_open_list("user");
 for (i = 0; i < num_users; i++) {
 xo_emit("Участник {l:имя}\\n", user[i].u_name);
 }
 xo_close_list("user");
 XML:
 <user>phil</user>
 <user>pallavi</user>
 JSON:
 "user": [ "фил", "паллави" ]
.Ed 
.Ss "Модификатор без кавычек ({n:})"
Модификатор без \-quotes  (и его двойник, модификатор \(aqquotes\(aqq)) влияют 
на цитирование значений в стиле вывода JSON.
JSON использует кавычки для 
строковых значений, но не заключает в кавычки числовые, логические и нулевые данные.
.Xr xo_emit 3
применяет простую эвристику, чтобы определить, нужны ли кавычки 
, но часто это должно контролироваться вызывающей стороной.
.Bd -literal -offset indent
 ПРИМЕР: 
 const char *bool = is_true ? "true" : "false";
 xo_emit("{n:fancy/%s}", bool);
 JSON:
 "fancy": верно 
.Ed 
.Ss "Модификатор множественного числа ({p:})"
Модификатор множественного числа выбирает подходящую форму множественного числа для выражения 
на основе последнего введенного числа и текущих языковых настроек 
.
Содержимое поля должно состоять из английских значений единственного числа 
и множественного числа, разделенных запятой:
.Bd -literal -offset indent 
 xo_emit("{:байты} {Ngp:байт, байты}\\n", байты);
.Ed 
.Pp
Модификатор множественного числа предназначен для работы с модификатором gettext ({g:})
но может работать независимо.
.Pp
При использовании без модификатора gettext или когда сообщение не отображается в каталоге сообщений 
первый маркер выбирается, когда последнее 
числовое value равно 1; в противном случае используется второе value,
имитируя простые правила множественного числа в английском языке.
.Pp
При использовании с модификатором gettext, the 
.Xr ngettext 3 
функция 
вызывается для выполнения тяжелой работы, используя каталог сообщений для 
преобразования форм единственного и множественного числа в родной язык.
.Ss "Модификатор кавычек ({q:})"
Модификатор кавычек (и его двойник, \(aqno-кавычки\(модификатор aq) влияют на 
цитирование значений в стиле вывода JSON.
JSON использует кавычки для 
строковых значений, но не заключает в кавычки числовые, логические и нулевые данные.
.Xr xo_emit 3
применяет простую эвристику для определения того, нужны ли кавычки 
, но часто это должно контролироваться вызывающей стороной.
.Bd -буквальный отступ -смещение
 ПРИМЕР:
 xo_emit("{q:time/%d}", 2014);
 JSON:
 "год": "2014"
.Ed 
.Ss "Модификатор пробела ({w:})"
Модификатор пробела добавляет к значению данных один пробел:
.Bd -буквенный отступ -смещение
 ПРИМЕР:
 xo_emit("{Lw:Name}{:name}\\n", "phil");
 ТЕКСТ:
 Имя фил 
.Ed 
.Pp
Модификатор пробела используется только для вывода текста и HTML-кода 
стили.
Обычно он комбинируется с модификатором двоеточия (\(aq{c:}\(aq).
Это исключительно функция удобства.
.Pp
Обратите внимание, что value модификатора \(aqw\(aqq изменено на обратное для роли единиц измерения
({Uw:}); пробел добавляется перед содержимым, а не после него.
.Ss "Форматирование поля"
Формат поля аналогичен строке формата для
.Xr printf 3 .
Его использование зависит от роли поля, но обычно используется для 
форматирования поля \(содержимое aqs.
.Pp
Если строка формата не указана для поля значения, по умолчанию используется значение 
"%s".
.Pp
Примечание . определение поля может содержать ноль или более директив printf\ в стиле 
.Dq , 
которые представляют собой последовательности, начинающиеся с a \(aq%\(aq и заканчивающиеся 
один из следующих символов: "diouxXDOUeEfFgGaAcCsSp".
Каждой директиве 
соответствует один из нескольких аргументов функции 
.Xr xo_emit 3 
.
.Pp
Строка формата имеет вид:
.Bd -literal -offset indent
 \(aq%\(aq format\-модификатор * формат\-символ 
.Ed 
.Pp
Формат\-модификатор может быть:
.Bl -bullet 
.It 
символ \(aq # \(aq), обозначающий выходное значение, должен иметь префикс 
"0x", обычно для обозначения базового значения 16 (hex).
.It
знак "минус" (\(ая\-\(р-р), с указанием выходное значение должно быть мягким на
правой, а не левой.
.It 
начальный ноль (\(aq0 \ (aq), указывающий выходное значение, должен быть дополнен на
оставлено с нулями вместо пробелов (\(aq \(aq).
.It 
одна или несколько цифр (\(aq0\(aq \- \(aq9\(aq), указывающих минимальную ширину аргумента) 
.
Если ширина в столбцах выходного значения меньше, чем 
минимальная ширина, value будет дополнено, чтобы достичь минимального значения.
.It 
точка, за которой следует одна или несколько цифр, указывающих максимальное. 
количество байт, которое будет проверяться на предмет строкового аргумента, или максимальная. 
ширина для нестрокового аргумента.
При обработке строк ASCII это значение
используется как ширина поля, но для многобайтовых символов один символ 
символ может состоять из нескольких байтов.
.Xr xo_emit 3
никогда не будет разыменовывать память сверх заданного количества байт.
.It 
вторая точка, за которой следует одна или несколько цифр, указывающих максимальную 
ширину строкового аргумента.
Этот модификатор нельзя указывать для аргументов, отличных от\-string.
.It 
один или несколько символов \(aqh\(aqq, указывающих на более короткие входные данные.
.It 
один или более символов \(aql\(aq, обозначающих более длинные входные данные.
.It 
символ \(aqz\(aq, обозначающий аргумент \(aqsize_t\(aq.
.It 
символ \(aqt\(aqq, обозначающий аргумент \(aqptrdiff_t\(aq.
.It
в \(Ак \(персонажа ах, указывая на пространство должно быть эмитированным до
положительные числа.
.It
символ \(aq+\(aq, обозначающий знак, должен быть указан перед любым числом.
.El 
.Pp
Обратите внимание, что \(aqq\(aq, \(aqD\(aq, \(AQo\(aq и \(aqU\(aq)) считаются устаревшими и в конечном итоге будут 
удалены.
.Pp
Символ формата описан в следующей таблице:
.Bl -column C "Тип аргумента12"
.It Sy "C" "Тип аргумента" "Формат"
.It "int" "основание 10 (десятичное)"
. Это i "int" "основание 10 (десятичное)"
. Это o "int" "основание 8 (восьмеричное)"
.It u "без знака" "основание 10 (десятичное)"
.It x "без знака" "основание 16 (шестнадцатеричное)"
.It X "длинное без знака" "основание 16 (шестнадцатеричное)"
.It "длинный" "основание 10 (десятичное)"
.It "длинный без знака" "основание 8 (восьмеричное)"
.It U "длинный без знака" "основание 10 (десятичное)"
.It e "double" "[\-]d.ddde+\-dd"
.It E "double" "[\-]d.dddE+\-dd"
.It означает "двойной" "[\-]ddd.ddd"
.It означает "двойной" "[\-]ddd.ddd"
.Он "удваивается " "как \(aqe\(aq или \(aqf\(aq"
.Он "удваивается " "как \(aqE\(aq или \(aqF\(aq"
.It "двойной" "[\-]0xh.hhhp[+\-]d"
.It "двойной" "[\-]0Xh.hhhp[+\-]d"
.It c "unsigned char " "символ"
.It C "wint_t " "символ"
. Это "char * " "строка UTF \-8"
.It "wchar_t * " "строка unicode / WCS"
.It "void * " "\(aq%#lx \(aq"
.El 
.Pp
В \(aqh\(AQ и \(ДУК\(р-р модификаторы влияют на размер и лечение
аргумент:
.Bl -column "Mod" "d, i" "o, u, x, X"
.It "Mod" "d, i" "o, u, x, X"
.It "hh" "подписанный символ" "неподписанный символ"
.It "h" "короткий" "неподписанный короткий"
.It "l" "длинный" "неподписанный длинный"
.It "ll" "long long" "unsigned long long"
.It "j " "intmax_t " "uintmax_t"
.It "t " "ptrdiff_t " "ptrdiff_t"
.It "z " "size_t " "size_t"
.It "q " "quad_t " "u_quad_t"
.El 
.Ss "Строки UTF \-8 и Locale"
Все строки для 
.Nm libxo 
должны быть UTF \-8.
.Nm libxo 
обработает их преобразование 
в строки на основе locale \ для отображения пользователю.
.Pp
Для строк модификаторы \(aqh\(aqq и \(aql\(aqq влияют на интерпретацию 
байты, на которые указывает аргумент.
Строка \(aq%s\(aq по умолчанию является \(aqchar *\(aq 
указателем на строку, закодированную как UTF\-8.
Поскольку UTF\-8 совместим с
.Em ASCII 
данные, обычные 7 \-битные
.Может использоваться строка Em ASCII 
.
"%ls" ожидает получения 
"wchar_t *" указателя на строку из широких \символов, закодированную как 32 \-битные
Значения в Юникоде.
"%hs" ожидает указатель "char *" на многобайтовую 
строку, закодированную с текущей локалью, как указано в 
.Ev LC_CTYPE ,
.Ev LANG , 
или 
.Ev LC_ALL 
переменные окружения.
Используется первая из этого списка 
переменных, и если ни одна из переменных не задана, по умолчанию используется языковой стандарт
.Их в UTF\-8 .
.Pp
.Нм libxo
будет
преобразовать эти аргументы по мере необходимости либо в UTF\-8 (для XML, JSON и
Стили HTML) или строки на основе locale\ для отображения в текстовом стиле.
.Bd -literal -offset indent 
 xo_emit("Все строки имеют формат utf\-8 content {:tag/%ls}", 
 L"за исключением широких строк");
.Ed 
.Pp 
"%S" эквивалентно "%ls".
.Pp 
Например, функции передаются имя locale\-base, размер шляпы 
и value времени.
Размер шапки отформатирован в виде строки UTF\-8 (ASCII)
, а value времени отформатировано в виде строки wchar_t.
.Bd -literal -offset indent 
 аннулирует print_order (const char *name, int size, 
 struct tm * timep) { 
 буфер символов[32];
 постоянный символ *size_val = "unknown";

 if (размер > 0)
 snprintf(buf, sizeof(buf), "%d", размер);
 size_val = buf;
 }

 wchar_t, когда[32];
 wcsftime(когда, sizeof(когда), L"%d%b%y", timep);

 xo_emit("Шапкой для {:name/%hs} является {:size/%s}.\\n", 
 name, size_val);
 xo_emit("Это было заказано в {:order\-time/%ls}.\\n", 
 когда);
 }
.Ed 
.Pp
Важно отметить, что
.Xr xo_emit 3
выполнит преобразование 
, необходимое для создания соответствующего вывода.
При выводе в текстовом стиле используется 
текущая локаль (как описано выше), в то время как XML, JSON и HTML используют
Кодировке UTF\-8.
.Pp
Кодировке UTF\-8 и\кодировке локали строки можно использовать несколько байтов для кодирования одного
столбец данных.
Традиционное value "precision" (оно же "max \-width") 
для форматирования printf "% s" становится перегруженным, поскольку оно определяет как 
количество байтов, на которые можно безопасно ссылаться, так и максимальное 
количество столбцов для генерации.
.Xr xo_emit 3 
использует точность, аналогичную первой, 
и добавляет третье value для указания максимального количества столбцов.
.Pp
В этом примере поле name печатается минимум с 3 столбцами 
и максимум с 6.
Для заполнения этих столбцов используется до десяти байт.
.Bd -literal -offset indent 
 xo_emit("{:name/%3.10.6s}", имя);
.Ed 
.Ss "Символы вне определений полей"
Символами в строке формата , которые не являются частью определения поля , являются
копируются в выходные данные для текстового стиля и игнорируются для стилей JSON 
и XML.
Для HTML эти символы помещаются в <div> с классом "text".
.Bd -literal -offset indent
 ПРИМЕР:
 xo_emit("Шапка {:size/%s}.\\n", size_val);
 ТЕКСТ:
 Шапка очень маленькая.
 XML:
 <размер>очень маленький</size>
 JSON:
 "size": "очень маленький"
 HTML:
 <div class="text">Шляпа такая </div>
 <div class="data" data\-tag="size">очень маленький</div>
 <div class="text">.</div>
.Ed 
.Ss "\(aq%n\(aq не поддерживается"
.Nm libxo 
не поддерживает директиву \(aq%n\(aq.
Это плохая идея, и мы 
просто не делаем этого.
.Ss "Формат кодирования (eformat)"
Строка "eformat" - это строка формата, используемая при кодировании поля 
для JSON и XML.
Если она не указана, по умолчанию используется основной формат 
с удалением любой минимальной ширины.
Если основное value не указано, по умолчанию используется value "%s".
.ПРИМЕР Sh
В этом примере выводится value для количества товаров на складе.:
.Bd -literal -offset indent 
 xo_emit("{P: }{Lwc:В наличии}{:в\-stock/%u}\\n", 
 instock);
.Ed 
.Pp
Этот вызов сгенерирует следующий вывод:
.Bd -литерал -смещенный отступ
 ТЕКСТ:
 В наличии: 144
 XML:
 <в\-stock>144</в\-stock>
 JSON:
 "в\-stock": 144, 
 HTML:
 <div class="строка">
 <div class="padding"> </div>
 <div class="label">В наличии</div>
 <div class="украшение">:</div>
 <div class="padding"> </div>
 <div class="data" data\-tag="в наличии">144</div>
 </div>
.Ed 
.Pp 
Очевидно, что HTML выигрывает награду за многословие, и этот вывод 
не включает
.Dv XOF_XPATH 
или 
.Dv XOF_INFO 
данные, которые расширили бы предпоследнюю строку до:
.Bd -literal -offset indent 
 <div class="data" data\-tag="в\-stock"
 data\-xpath="/начало/данные / товар /в\-stock"
 data\-type="количество"
 data\-help="Количество товаров на складе">144</div>
.Ed 
.Sh ЧТО ДЕЛАЕТ НАЗВАНИЕ ПОЛЯ ПОДХОДЯЩИМ?
Чтобы создать полезные и согласованные названия полей, следуйте этим рекомендациям:
.Ss "Используйте нижний регистр, даже для TLA"
Нижний регистр более цивилизован.
Даже TLA должны быть в нижнем регистре 
чтобы избежать сценариев, в которых различия между "XPath" и 
"Xpath" сводят ваших пользователей с ума.
Использование "xpath" проще и качественнее.
.Ss "Используйте дефисы, а не подчеркивания"
Использование дефисов является традиционным в XML, и 
.Dv XOF_UNDERSCORES
при желании flag можно использовать для создания символов подчеркивания в JSON.
Но в исходном имени поля следует использовать дефисы.
.Ss "Использовать полные слова"
Не сокращайте, особенно если сокращение неочевидно или 
не широко используется.
Используйте "data \-size", а не "dsz" или "dsize".
Используйте 
"интерфейс" вместо "ifname", "if\-name", "iface", "if" или "intf".
.Ss "Используйте <глагол>\-<единицы измерения>"
Использование формы <глагол>\-<единицы измерения> или <глагол>\-<классификатор>\-<единицы измерения> помогает в 
создании согласованных, полезных названий, избегая ситуации, когда одно приложение 
использует "отправленный \-packets" и другой "-packets \-отправлены" и еще один 
"-packets \-мы \-отправили \-отправили".
В <units> может быть удален, когда это
очевидно, как очевидно слов в классификации.
Используйте "получать \-after \-window\-packets" вместо 
"полученные \-packets \-data \-after \-window".
.Ss "Повторно использовать существующие имена полей".
Нет ничего хуже, чем писать выражения типа:
.Bd -literal -offset indent 
 if ($src1/process[pid == $pid]/name ==
 $src2/proc\-таблица/proc/p[process\-id == $pid]/proc\-имя) {
 ...
 } 
.Ed 
.Pp 
Найдите кого-нибудь еще, кто предоставляет похожие данные, и следуйте их 
полям и иерархии.
Помните, что цитаты нет 
.Dq "Последовательность - это хобби маленьких умов" 
но
.Dq "Глупая последовательность - удел маленьких умишек" .
.Ss "Думайте о своих пользователях"
Проявляйте сочувствие к своим пользователям, выбирая четкие и полезные поля, которые 
содержат четкие и полезные данные.
Возможно, вам потребуется дополнить отображаемое содержимое с помощью
.Xr xo_attr 3 
вызовы или поля "{e:}", чтобы сделать данные полезными.
.Ss "Не используйте постфикс произвольного числа"
Что означает "errors2"?
Никто не узнает.
Лучшим выбором было бы "ошибки \-after \-restart".
Подумайте о своих пользователях и о будущем.
Если вы сделаете "errors2", следующий парень с радостью сделает 
"errors3", и не успеете вы оглянуться, как кто-нибудь спросит, в чем 
разница между errors37 и errors63.
.Ss "Будьте последовательны, единообразны, неудивительны и предсказуемы"
Представьте свой полевой словарь как API.
Вы хотите, чтобы он был полезным, 
выразительным, осмысленным, прямым и очевидным.
Вы хотите, чтобы клиент 
приложение \ (программист aqs) переключался между ними без необходимости 
понимать различные мнения о том, как называются поля.
Они должны 
рассматривать систему как единое целое, а не как мешок с кошками.
.Pp 
Названия полей представляют собой средства, с помощью которых клиентские программисты взаимодействуют 
с нашей системой.
Выбирая мудрые имена сейчас, вы делаете их жизнь лучше.
.Рр
После использования
.Xr xolint 1 
чтобы найти ошибки в ваших дескрипторах полей, используйте 
.Dq "xolint \-V"
проверка орфографии названий полей и выявление различий 
названия для одних и тех же данных.
.Dq dropped\-short 
и 
.Dqdropped \-too\-short 
оба названия приемлемы, но использование их обоих заставит пользователей спросить о 
разнице между двумя полями.
Если разницы нет, 
используйте только одно из названий полей.
Если разница есть, измените имена 
, чтобы сделать это различие более очевидным.
.Sh СМОТРИТЕ ТАКЖЕ
.Xr libxo 3, 
.Xr xolint 1 , 
.Xr xo_emit 3
.ИСТОРИЯ Sh
Библиотека 
.Nm libxo 
впервые появилась в 
.Fx 11.0 .
.Sh АВТОРЫ
.Nm libxo 
был написан
.Филом Шейфером из Mt phil@freebsd.org .
