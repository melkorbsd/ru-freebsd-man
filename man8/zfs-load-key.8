.\"
.\" CDDL HEADER START
.\"
.\" The contents of this file are subject to the terms of the
.\" Common Development and Distribution License (the "License").
.\" You may not use this file except in compliance with the License.
.\"
.\" You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
.\" or https://opensource.org/licenses/CDDL-1.0.
.\" See the License for the specific language governing permissions
.\" and limitations under the License.
.\"
.\" When distributing Covered Code, include this CDDL HEADER in each
.\" file and include the License file at usr/src/OPENSOLARIS.LICENSE.
.\" If applicable, add the following below this CDDL HEADER, with the
.\" fields enclosed by brackets "[]" replaced with your own identifying
.\" information: Portions Copyright [yyyy] [name of copyright owner]
.\"
.\" CDDL HEADER END
.\"
.\" Copyright (c) 2009 Sun Microsystems, Inc. All Rights Reserved.
.\" Copyright 2011 Joshua M. Clulow <josh@sysmgr.org>
.\" Copyright (c) 2011, 2019 by Delphix. All rights reserved.
.\" Copyright (c) 2013 by Saso Kiselkov. All rights reserved.
.\" Copyright (c) 2014, Joyent, Inc. All rights reserved.
.\" Copyright (c) 2014 by Adam Stevko. All rights reserved.
.\" Copyright (c) 2014 Integros [integros.com]
.\" Copyright 2019 Richard Laager. All rights reserved.
.\" Copyright 2018 Nexenta Systems, Inc.
.\" Copyright 2019 Joyent, Inc.
.\"
.Dd Январь 13, 2020
.Dt ZFS-LOAD-KEY 8
.Os
.
.Sh ИМЯ
.Nm zfs-load-key
.Nd загружать, выгружать или изменять ключ шифрования набора данных ZFS
.Sh СИНТАКСИС
.Nm zfs
.Cm load-key
.Op Fl nr
.Op Fl L Ar keylocation
.Fl a Ns | Ns Ar filesystem
.Nm zfs
.Cm unload-key
.Op Fl r
.Fl a Ns | Ns Ar filesystem
.Nm zfs
.Cm change-key
.Op Fl l
.Op Fl o Ar keylocation Ns = Ns Ar value
.Op Fl o Ar keyformat Ns = Ns Ar value
.Op Fl o Ar pbkdf2iters Ns = Ns Ar value
.Ar filesystem
.Nm zfs
.Cm change-key
.Fl i
.Op Fl l
.Ar filesystem
.
.Sh ОПИСАНИЕ
.Bl -tag -width ""
.It Xo
.Nm zfs
.Cm load-key
.Op Fl nr
.Op Fl L Ar keylocation
.Fl a Ns | Ns Ar filesystem
.Xc
Загрузите ключ для
.Ar filesystem ,
позволяя ему и всем дочерним элементам, которые наследуют
.Sy keylocation
свойства, к которым необходимо получить доступ.
Ожидается, что ключ будет отправлен в формате, указанном пользователем в
.Sy keyformat
и местоположение, указанное пользователем свойстом
.Sy keylocation .
Обратите внимание, что если 
.Sy keylocation
установлен на
.Sy prompt ,
терминал будет ожидать ввода ключа в интерактивном режиме.
Загрузка ключа не приведет к автоматическому подключению набора данных.
Если требуется такая функциональность,
.Nm zfs Cm mount Fl l
запросит ключ и смонтирует набор данных
.Po
Смотрите
.Xr zfs-mount 8
.Pc .
Как только ключ будет загружен, свойство
.Sy keystatus
станет
.Sy available .
.Bl -tag -width "-r"
.It Fl r
Рекурсивно загружает ключи для указанной файловой системы и всех
последующих корней шифрования.
.It Fl a
Загружает ключи для всех корней шифрования во всех импортированных пулах.
.It Fl n
Проведите пробный запуск
.Pq Qq No-op
.Cm load-key .
Это приведет к
.Nm zfs
чтобы просто проверить правильность введенного ключа.
Эта команда может быть запущена, даже если ключ уже загружен.
.It Fl L Ar keylocation
Используйте
.Ar keylocation
вместо свойства
.Sy keylocation .
Это не изменит значение свойства в наборе данных.
Обратите внимание, что при использовании любого из
.Fl r
или
.Fl a ,
.Ar keylocation
может быть дано только в качестве
.Sy prompt .
.El
.It Xo
.Nm zfs
.Cm unload-key
.Op Fl r
.Fl a Ns | Ns Ar filesystem
.Xc
Выгружает ключ из ZFS, лишая возможности доступа к набору данных и всем
его дочерним элементам, которые наследуют свойства
.Sy keylocation .
Для этого необходимо, чтобы набор данных в данный момент не был открыт или подключен.
Как только ключ будет выгружен, свойство
.Sy keystatus
станет
.Sy unavailable .
.Bl -tag -width "-r"
.It Fl r
Рекурсивно выгружает ключи для указанной файловой системы и всех
последующих корней шифрования.
.It Fl a
Выгружает ключи для всех корней шифрования во всех импортированных пулах.
.El
.It Xo
.Nm zfs
.Cm change-key
.Op Fl l
.Op Fl o Ar keylocation Ns = Ns Ar value
.Op Fl o Ar keyformat Ns = Ns Ar value
.Op Fl o Ar pbkdf2iters Ns = Ns Ar value
.Ar filesystem
.Xc
.It Xo
.Nm zfs
.Cm change-key
.Fl i
.Op Fl l
.Ar filesystem
.Xc
Изменяет ключ пользователя (например, парольную фразу), используемый для доступа к набору данных.
Для выполнения этой команды требуется, чтобы существующий ключ для набора данных был уже загружен.
Эта команда также может использоваться для изменения свойств
.Sy keylocation ,
.Sy keyformat ,
и
.Sy pbkdf2iters
по мере необходимости.
Если набор данных ранее не был корневым для шифрования, он станет таковым.
В качестве альтернативы можно использовать флаг
.Fl i
может быть установлен для того, чтобы вместо этого корневой сервер шифрования унаследовал родительский ключ.
.Pp
Если ключ пользователя скомпрометирован,
.Nm zfs Cm change-key
не обязательно защищает существующие или недавно записанные данные от атак.
Новые данные будут по-прежнему шифроваться с помощью того же главного ключа,
что и существующие данные.
Главный ключ будет скомпрометирован, если злоумышленник получит
пользовательский ключ и соответствующий закрытый главный ключ.
В настоящий момент,
.Nm zfs Cm change-key
не перезаписывает предыдущий сохраненный на диске мастер-ключ, поэтому он
доступен с помощью криминалистического анализа в течение неопределенного периода времени.
.Pp
В случае взлома мастер-ключа в идеале диски должны быть надежно
стерты, чтобы удалить все старые данные (которые можно прочитать с помощью скомпрометированного
мастер-ключа), создать новый пул и скопировать данные обратно.
Это можно приблизить на месте, создав новые наборы данных, скопировав данные
.Pq e.g. using Nm zfs Cm send | Nm zfs Cm recv ,
а затем расчищает свободное пространство с помощью
.Nm zpool Cm trim Fl -secure
если поддерживается вашим оборудованием, в противном случае
.Nm zpool Cm initialize .
.Bl -tag -width "-r"
.It Fl l
Убедитесь, что ключ загружен, прежде чем пытаться изменить его.
Это фактически эквивалентно запуску
.Nm zfs Cm load-key Ar filesystem ; Nm zfs Cm change-key Ar filesystem
.It Fl o Ar property Ns = Ns Ar value
Позволяет пользователю устанавливать свойства ключа шифрования
.Pq Sy keyformat , keylocation , No and Sy pbkdf2iters
при смене ключа.
Это единственный способ изменить
.Sy keyformat
и
.Sy pbkdf2iters
после того, как набор данных будет создан.
.It Fl i
Указывает, что zfs должна выполнить наследование ключа 
.Ar filesystem
от родительского ключа.
Обратите внимание, что эта команда может быть запущена только в корневом каталоге шифрования, у которого есть зашифрованный родительский ключ.
.El
.El
.Ss Encryption
Включение функции
.Sy encryption
позволяет создавать зашифрованные файловые системы и тома.
ZFS шифрует данные файлов и томов, атрибуты файлов, списки управления доступом, биты разрешений,
списки каталогов, сопоставления FLUID и данные
.Sy userused Ns / Ns Sy groupused .
ZFS не будет шифровать метаданные, относящиеся к структуре пула, включая
имена наборов данных и моментальных снимков, иерархию наборов данных, свойства, размер файла, пробелы в файлах и таблицы дедупликации (хотя сами дедуплицированные данные
зашифрованы).
.Pp
Сменой ключей управляет ZFS.
Изменение пользовательского ключа (например, парольной фразы)
не требует повторного шифрования всего набора данных.
Наборы данных могут быть очищены,
повторно проверены, переименованы и удалены без загрузки ключей шифрования (см. подкоманду
.Cm load-key
для получения дополнительной информации о загрузке ключа).
.Pp
Для создания зашифрованного набора данных требуется указать свойства
.Sy encryption No and Sy keyformat
во время создания, а также необязательный
.Sy keylocation No and Sy pbkdf2iters .
После ввода ключа шифрования
созданный набор данных станет корневым для шифрования.
Все наборы данных-потомков
по умолчанию наследуют свой ключ шифрования от корневого каталога шифрования, что означает, что
загрузка, выгрузка или изменение ключа для корневого каталога шифрования будут неявно
выполняться одинаково для всех наследуемых наборов данных.
Если такое наследование нежелательно, просто укажите
.Sy keyformat
при создании дочернего набора данных или используйте
.Nm zfs Cm change-key ,
чтобы разорвать существующую связь, создайте новый корень шифрования для дочернего элемента.
Обратите внимание, что дочерний
.Sy keyformat
может совпадать с родительским, при этом все еще создается новый корень шифрования, и
это изменяет само по себе свойство
.Sy encryption ,
не создает новый корень шифрования; в этом случае просто используется
другой набор шифров с тем же ключом, что и у корневого ключа шифрования.
Единственное исключение заключается в том, что клоны всегда будут использовать исходный ключ шифрования.
В результате этого исключения некоторые свойства, связанные с шифрованием, могут быть изменены.
.Pq namely Sy keystatus , keyformat ,  keylocation , No and Sy pbkdf2iters
не наследуются, как другие свойства ZFS, а вместо этого используются значения, определяемые
их корнем шифрования.
Наследование корня шифрования можно отследить с помощью функции, доступной только для чтения свойств
.Sy encryptionroot .
.Pp
Шифрование изменяет поведение нескольких
операций ZFS.
После сжатия применяется шифрование, что позволяет сохранить степень сжатия.
Обычно контрольные суммы в ZFS имеют длину 256 бит, но для зашифрованных данных
контрольная сумма составляет 128 бит от выбранной пользователем контрольной суммы и 128 бит от MAC из
пакета шифрования, что обеспечивает дополнительную защиту от злонамеренного
изменения данных.
Дедупликация по-прежнему возможна при включенном шифровании, но в целях безопасности
наборы данных будут дедуплицироваться только в отношении самих себя, своих моментальных
снимков и своих клонов.
.Pp
Существует несколько ограничений на наборы зашифрованных данных.
Зашифрованные данные не могут быть внедрены через свойство
.Sy embedded_data .
Зашифрованные наборы данных могут не содержать
.Sy copies Ns = Ns Em 3
поскольку реализация хранит некоторые метаданные шифрования там, где
обычно находится третья копия.
Поскольку сжатие применяется перед шифрованием, наборы данных могут
быть уязвимы для атаки, подобной преступлению, если приложения, получающие доступ к данным, допускают это.
Дедупликация с шифрованием приведет к утечке информации о том, какие блоки
эквивалентны в наборе данных, и потребует дополнительных затрат процессора на каждый
записанный блок.
.
.Sh СМОТРИТЕ ТАКЖЕ
.Xr zfsprops 7 ,
.Xr zfs-create 8 ,
.Xr zfs-set 8
